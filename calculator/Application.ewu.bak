$version 13.04

// This is the root component of the entire GUI application.
$rect <-300,140,-100,180>
$output false
class Application : Core::Group
{
  $rect <380,550,580,590>
  inherited property Bounds = <0,0,340,600>;

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset StackingPriority = 3;
    preset Bounds = <26,54,316,119>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "result here";
    preset Font = Application::DigitalResFont;
    preset Color = #0D1A38FF;
  }

  $rect <20,20,160,60>
  object Application::NumKeyBtns Keypad
  {
    preset StackingPriority = 2;
    preset Bounds = <21,146,321,586>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle OutputBgk
  {
    preset StackingPriority = 2;
    preset Bounds = <21,50,321,125>;
    preset ColorBL = ScreenOnB;
    preset ColorBR = ScreenOnB;
    preset ColorTR = ScreenT;
    preset ColorTL = ScreenT;
    preset Radius = 5;
    preset Color = ScreenOn;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset StackingPriority = 2;
    preset Bounds = <21,50,321,125>;
    preset Radius = 5;
    preset Width = 2;
    preset Color = #030324FF;
  }

  $rect <430,40,630,80>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = CalculateExpression;
    preset OnHold = null;
  }

  $rect <430,90,630,130>
  slot CalculateExpression
  {
    var string str = "";
    var string temp = "";
    var int32 cursorPosition = Text.String.length - 1; 

    if( KeyHandler.CharCode != '\0' )
    {  
      str = KeyHandler.CharCode;
    }
    else
    {
      str = Keypad.keyString;
    }

    if( Text.String == "result here" || str == "C" || str == "c" )
    {
      ResetVariables();
    }

    if(KeyHandler.Code == Core::KeyCode.Left)
    {
      if (cursorPosition > 0)
      {    
        cursorPosition--; 
      }
    }

    if( KeyHandler.Code == Core::KeyCode.Right )
    {
      if (cursorPosition < Text.String.length)
      {
        
        cursorPosition++; 
      }
    }

    if ( str != "=" &&  str != "C" && str != "c" && OutputBgk.Color != ScreenOff)
    {
        var char lastChar = Text.String[Text.String.length - 1];
        if ( str == "(" )
        {               
            if ( Text.String.length > 0 )
            {
                if ( IsDigit(lastChar) || lastChar == ')' )
                {
                    temp = Text.String + "x" + str;
                }
                else
                {
                    temp = Text.String + str;
                }
            }
            else
            {
                temp = Text.String + str;
            }
        }
        else if( str == "B" || str == "b" || KeyHandler.Code == Core::KeyCode.Delete )
        {
            temp = Text.String.remove(Text.String.length - 1, 1);
        }
        else if( IsDigit(str[0]) )
        {
           if( lastChar == ')' )
           {
               temp = Text.String + "x" + str;
           }
           else
           {
               temp = Text.String + str;
           }
        }
        else if ( str == "%" || str == "^" )
        {
          temp = Text.String + "%" + str;
        }
        else
        {
            temp = Text.String + str;
        }
        Text.String = temp;
        cursorPosition++;
    }

    if (str == "=" )
    {
      temp = Text.String;
      Text.String = RemoveExtraSymbols(temp);
      if(IsExpressionValid(Text.String))
      {
        Text.String = EvaluateRPN(Text.String);
        CorrectInput = true;
        cursorPosition = Text.String.length;
      }
      else
      {
        CorrectInput = false;
      }
    }


  }

  // Key Event Handler
  note group KeyHandlerNote
  {
    attr Bounds = <380,0,670,160>;
  }

  $rect <420,370,630,410>
  method float ExecTwoOp( arg float first, arg float second, arg string op )
  {
    var float res = 0.0;

    switch ( op[0] )
          {
            case '+':
              res = first + second;
            case '-':
              res = first - second;
            case 'x':
              res = first * second;
            case '/':
              if (second != 0.0)
                res = first / second;
              else
              { 
                if(first < 0.0)
                  {res = float_infn();}
                if(first > 0.0)
                  {res = float_infp();}
                if(first == 0.0)
                  {res = float_nan();}
              }
            case '%':
              { 
                var float temp = first * second;
                res = temp / 100;     
              }
            case '^': 
              res =  math_pow( first, second );
            default:
              res = 0.0;
          }

    return res;
  }

  $rect <420,470,630,510>
  method void ResetVariables()
  {
    Text.String = "";
  }

  $rect <730,50,930,90>
  method bool IsOperator( arg char op )
  {
    return ( op == '+' || op == '-' || op == 'x' || op == '/' ||  op == '%' || op == '^');
  }

  // Operation Handler
  note group Note
  {
    attr Bounds = <380,180,670,530>;
  }

  $rect <1100,50,1300,90>
  method int32 GetPriorityOfOperator( arg char op )
  {
    var int32 priority = 0;

    switch ( op )
          {
            case '+':
              priority = 1;
            case '-':
              priority = 1;
            case 'x':
              priority = 2;
            case '/':
              priority = 2;
            case '%':
             priority = 3;
            case '^': 
              priority = 3;
            default:
              priority = 1;
          }

    return priority;
  }

  $rect <1085,100,1310,140>
  method Application::Tuple GetNumberFromPosition( arg int32 startPos, arg string expression )
  {
    var int32 endPos;
    var Application::Tuple res = new Application::Tuple;
    var string nrStr = "";
    var int32 i = startPos;

    if( expression != "" )
    {
      if ( expression[i] == '-' )  
      {
        nrStr += expression[i];
        i++;
      }
      for( ; i < expression.length; i++ )
      {
        if( !IsOperator( expression[i] ) && IsDigit( expression[i] ) )
        {  
          nrStr += expression[i];
          endPos = i;
        }
        else
        {  
          break;    
        }
      }
    } 

    res.EndPosition = endPos;
    res.Subexpression = "none";
    res.IdentifiedNumber = nrStr.parse_float( -1.0 );
    return res; 
  }

  $rect <730,440,930,480>
  method bool IsExpressionValid( arg string expression )
  {
    // check for valid operators
    // check that operators are used correctly
    // correct paranthesis

    if ( expression == "" )
    {
         CorrectInput = false;
         ErrorTxt = "Expression is null.";
         return false;
    }
    else
    {
        if( !CorrectParentheses(expression) )
        {
           CorrectInput = false;
           ErrorTxt = "Parantheses used incorrectly.";
           return false;
        }
        else if ( !CharactersAllowed(expression) )
        {
           CorrectInput = false;
           ErrorTxt = "Expression contains characters that are not allowed.";
           return false;
        }
        else if( !OperatorsCorrectlyUsed(expression) )
        {
           CorrectInput = false;
           ErrorTxt = "Operators used incorrectly.";
           return false;
        }    
    }

    return true;
  }

  $rect <730,390,930,430>
  method bool IsDigit( arg char op )
  {
    return ( (op >= '0') && (op <= '9') || op == '.');
  }

  $rect <730,290,930,330>
  method bool CorrectParentheses( arg string expression )
  {
    var Application::CharStack stk = new Application::CharStack;
    var int32 i = 0;

    for( ; i < expression.length ; i++ )
    {
      if( expression[i] == '(' )
      {
        stk.Push(expression[i]);
      }
      else if( expression[i] == ')' ) 
      {
        if( stk.IsEmpty() )
        {
          return false;
        }
        stk.Pop();
      }
    }

    return stk.IsEmpty();
  }

  $rect <730,340,940,380>
  method bool OperatorsCorrectlyUsed( arg string expression )
  {
    var int32 i = 0;

    if( expression != "" )
    {  
      for ( ; i < expression.length; i++ )
      {
       if(i == 0)
        {
          if( !((expression[i] >= '0' && expression[i] <= '9') || expression[i] == '-' || expression[i] == '(') )
          {
            return false; 
          }
        }
        else
        {
          if( IsMinus(expression[i]) && OperatorNotMinus(expression[i - 1]) && !IsDigit(expression[i + 1]) )
          {
              return false;
          }
          if( IsMinus(expression[i]) && IsDigit(expression[i - 1]) && IsOperator(expression[i + 1]) )
          {
            return false;
          }
          if( OperatorNotMinus(expression[i]) && OperatorNotMinus(expression[i - 1]) )
          {
            return false;
          }
          if( IsMinus(expression[i]) && IsMinus(expression[i - 1]) )
          {
            return false;
          }
          if( expression[i] == '.' && expression[i - 1] == '.' )
          {
            return false; 
          }      
          if( i == expression.length - 1 && IsOperator(expression[i]) )
          {
            return false;  
          }
        }
      }
    }

    return true;
  }

  $rect <730,200,930,240>
  method bool IsParenthesis( arg char op )
  {
    if( op == '(' || op == ')')
      return true;

    return false;
  }

  $rect <730,240,930,280>
  method bool CharactersAllowed( arg string expression )
  {
    var int32 i = 0;

    for( ; i < expression.length; i++ )
    {
      if ( IsOperator(expression[i]) == false && IsParenthesis(expression[i]) == false && IsDigit(expression[i]) == false
          && IsWhiteSpace(expression[i]) == false )
        return false;
    }

    return true;
  }

  $rect <730,540,930,580>
  method bool IsWhiteSpace( arg char op )
  {
    return ( op == ' ' || op == '\t' );
  }

  $rect <380,600,580,640>
  inherited method Init()
  {
    signal BatteryDialog.onUseBattery;
  }

  $rect <20,20,160,60>
  object Application::Battery BatteryDialog
  {
    preset Bounds = <110,160,230,215>;
    preset Visible = true;
  }

  // Validations
  note group Note1
  {
    attr Bounds = <690,0,980,750>;
  }

  // Error Dialog
  note group Note2
  {
    attr Bounds = <1000,180,1420,450>;
  }

  // Get Methods
  note group Note3
  {
    attr Bounds = <1000,0,1420,160>;
  }

  $rect <730,640,930,680>
  method bool IsNumber( arg string expression )
  {
    var int32 i = 0;

    for( ; i < expression.length ; i++ )
    {
      if( !IsDigit(expression[i]) && !IsDot(expression[i]) )
      {
        return false;
      }
    }

    return true;
  }

  $rect <730,590,930,630>
  method bool IsDot( arg char op )
  {
    return op == '.';
  }

  $rect <420,320,630,360>
  method Application::StrVector TokenizeExpression( arg string expression )
  {
    var Application::StrVector tokens = new Application::StrVector;
    var int32 i = 0;

    for ( ; i < expression.length; i++ )  
    {
        if ( IsSpace(expression[i]) )
        {
            continue;
        }
        else if ( IsDigit(expression[i]) || (expression[i] == '.' && IsDigit(expression[i + 1])) ||
                 (expression[i] == '-' && (i == 0 || IsOperator(expression[i - 1]) || expression[i - 1] == '(') 
                 && (IsDigit(expression[i + 1]) || expression[i + 1] == '.')) )
        {
            var Application::Tuple gr = GetNumberFromPosition(i, expression);
            var string number = gr.IdentifiedNumber;
            i = gr.EndPosition;
            tokens.PushBack(number);
            continue;    
        }
        else if ( IsOperator(expression[i]) || IsParenthesis(expression[i]) )
        {
            var string c = "";
            c = expression[i];
            tokens.PushBack(c);
            continue;
        }
        else
        {
            continue;
        }
    }

    return tokens;



  }

  $rect <730,490,930,530>
  method bool IsSpace( arg char op )
  {
    return op == '\0' || op == '\t' || op =='\n';
  }

  $rect <420,270,640,310>
  method Application::StrVector ShuntingYardAlgorithm( arg string expression )
  {
    var Application::StrVector tokens  = new Application::StrVector;
    var Application::StrQueue output = new Application::StrQueue;
    var Application::StrStack operators = new Application::StrStack;

    tokens = TokenizeExpression( expression );
    var Application::StringElement token = tokens.Front;

    while( token != null )
    {
      if( token.DataStr.length == 1 )
      {
        var char t = token.DataStr[0];
        if( IsDigit(t) )
        {
          output.Push(token.DataStr);
          output.Print();
        }
        else if( IsParenthesis(t) )
        {
          if( t == '(')
          {
            operators.Push("(");
          }
          else if( t == ')')
          {
            while ( !operators.IsEmpty() && operators.GetTop() != "(" )
            {
              output.Push(operators.GetTop());
              operators.Pop();
            }
            if( !operators.IsEmpty() )
            {
              operators.Pop();
            }
          }
        }
        else if ( IsOperator(t) )
        {
          if( !operators.IsEmpty() )
          {
            var char top = operators.GetTop()[0];
            if( IsOperator(top) )
            {   
              while( !operators.IsEmpty() && operators.GetTop() != "(" && 
                  (GetPriorityOfOperator(top) == GetPriorityOfOperator(t) || GetPriorityOfOperator(top) > GetPriorityOfOperator(t)) )
              {
                output.Push(operators.GetTop());
                operators.Pop();
              }
              operators.Push(token.DataStr);
            }
            if( top == '(' )
            {
              operators.Push(token.DataStr);
            }
          }
          else
          {
            operators.Push(token.DataStr);
          }
        }   
      }
      else if( IsNumber(token.DataStr) || IsNegativeNumber(token.DataStr) )
      {
        output.Push(token.DataStr);
      }

      token = token.Next;
    }

    while( !operators.IsEmpty() )
    {
      output.Push(operators.GetTop());
      operators.Pop();
    }

    var Application::StrVector expr  = new Application::StrVector;
    var Application::SimpleStringElement aux = output.Front;

    while( aux != null )
    {
      expr.PushBack(aux.DataStr);
      aux = aux.Next;
    }
    aux = null;

    return expr;

  }

  $rect <420,220,640,260>
  method string EvaluateRPN( arg string expression )
  {
    var Application::StrVector RPN  = new Application::StrVector;
    var Application::FloatStack stk = new Application::FloatStack;
    var float firstOp;
    var float secondOp;

    RPN = ShuntingYardAlgorithm( expression );
    var Application::StringElement token = RPN.Front;

    while( token != null )
    {
      if( IsOperator(token.DataStr[0]) && !IsNegativeNumber(token.DataStr) )
      {
        secondOp = stk.GetTop();
        stk.Pop();
        firstOp = stk.GetTop();
        stk.Pop();
        stk.Push(ExecTwoOp(firstOp, secondOp, token.DataStr[0]));
      }
      else 
      {
        stk.Push(token.DataStr.parse_float( -1.0 ));
      }
      token = token.Next;
    }

    var string result = "";
    result = stk.GetTop();

    return result;
  }

  $rect <730,690,930,730>
  method bool IsNegativeNumber( arg string expression )
  {
    var string subexpr = expression.right(expression.length - 1);

    if( expression[0] == '-' && IsNumber(subexpr) && expression.length > 1)
    {
      return true;
    }

    return false;
  }

  $rect <1010,610,1210,650>
  method void PowerOff()
  {
    BatteryDialog.Int32Effect.Enabled = true;
    TurnScreenOff();
    ResetVariables();
  }

  $rect <1010,510,1210,550>
  object Core::PropertyObserver BatteryLevelObserver
  {
    preset OnEvent = onBatteryOut;
    preset Outlet = ^BatteryDialog.BatteryPercentage;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver' \
  // is notified.
  $rect <1010,560,1210,600>
  slot onBatteryOut
  {
    if( BatteryDialog.BatteryPercentage == 0 )
    {
      BatteryLvl = 0;
      PowerOff();
    }
  }

  $rect <1460,40,1660,80>
  var color ScreenOn = #CFE4F8FF;

  $rect <1460,90,1660,130>
  var color ScreenOnB = #99A8B7FF;

  $rect <1460,140,1660,180>
  var color ScreenT = #FFFFFFFF;

  $rect <1460,190,1660,230>
  var color ScreenOff = #4E555CFF;

  $rect <1460,240,1660,280>
  var color ScreenOffBL = #948F64FF;

  $rect <1460,290,1660,330>
  var color ScreenOffBR = #9E986AFF;

  // Screen Colors & Methods
  note group Note4
  {
    attr Bounds = <1440,0,1680,450>;
  }

  $rect <20,20,160,60>
  object Application::ChangeBattery ReplaceBatteryDialog
  {
    preset Bounds = <-150,156,-20,221>;
    preset Visible = false;
  }

  $rect <1240,510,1430,550>
  object Core::PropertyObserver StateObserver
  {
    preset OnEvent = onStateTrue;
    preset Outlet = ^BatteryDialog.State;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver' \
  // is notified.
  $rect <1240,560,1440,600>
  slot onStateTrue
  {
    if ( BatteryDialog.State == true )
    {
      BatteryDialog.Visible = false;
      ReplaceBatteryDialog.Visible = true;
      ReplaceBatteryDialog.Bounds.x = 106;
      ReplaceBatteryDialog.Text.String = "add new battery..";
      ReplaceBatteryDialog.Enabled = true; 
    }
  }

  $rect <1460,340,1660,380>
  method void TurnScreenOn()
  {
    OutputBgk.Color = ScreenOn;
    OutputBgk.ColorBL = ScreenOnB;
    OutputBgk.ColorBR = ScreenOnB;
  }

  $rect <1460,390,1660,430>
  method void TurnScreenOff()
  {
    OutputBgk.Color = ScreenOff;
    OutputBgk.ColorBL = ScreenOffBL;
    OutputBgk.ColorBR = ScreenOffBR;
  }

  // Battery Dialog
  note group Note5
  {
    attr Bounds = <1000,470,1680,670>;
  }

  $rect <1450,510,1650,550>
  object Core::PropertyObserver NewBatteryObserver
  {
    preset OnEvent = onValidBattery;
    preset Outlet = ^ReplaceBatteryDialog.NewBatteryLvl;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver' \
  // is notified.
  $rect <1450,560,1650,600>
  slot onValidBattery
  {
    if( ReplaceBatteryDialog.NewBatteryLvl >= 20 || ReplaceBatteryDialog.Enabled == false)
    {
      PowerOn();
    }
    else if ( ReplaceBatteryDialog.NewBatteryLvl < 20)
    {
      CorrectInput = false;
      ErrorTxt = "Battery not charged.";
    }
  }

  $rect <1240,610,1440,650>
  method void PowerOn()
  {
    KeyHandler.Enabled = true;
    TurnScreenOn();
    ResetVariables();
    BatteryDialog.State = false;
    BatteryLvl = ReplaceBatteryDialog.NewBatteryLvl;
    BatteryDialog.BatteryPercentage = ReplaceBatteryDialog.NewBatteryLvl;
    BatteryDialog.Text.Color = BatteryDialog.Green;
    BatteryDialog.Visible = true; 
    BatteryDialog.Enabled = true;
    Keypad.StackingPriority = 3;
  }

  $rect <420,420,620,460>
  method string RemoveExtraSymbols( arg string expression )
  {
    var int32 i = 0;
    var string cleanExpression = "";

    for( ; i < expression.length; i++ )
    {
      if( expression [i] == '%' && ( expression[i + 1] == '%' || expression[i + 1] == '^' ))
      {
        continue;
      }
      cleanExpression += expression[i];
    }

    return cleanExpression;
  }

  $rect <1210,230,1410,270>
  property bool CorrectInput = true;

  $rect <1210,280,1410,320>
  onget CorrectInput
  {
    // Per default return the value stored already in the property.
    return pure CorrectInput;

    /*

      TO DO:

      If the property should return the value stored in the underlying device
      or in the middleware, remove the above 'return' statement and instead do
      following:

      Declare a local variable to receive the value from the underlying device.
      The type of the variable has to correspond to the data type of the property.
      For example in case of an 'int32' property:
      
        var int32 result;

      Implement a native statement to access the value and to store it in the
      variable 'result'. Then return the value. For example:

        $if !$prototyper
          native ( result )
          {
            result = YourDevice_GetSomeValue();
          }
        $endif

        return result;

    */
  }

  $rect <1010,280,1210,320>
  onset CorrectInput
  {
    // The property doesn't change -> nothing to do.
    if ( pure CorrectInput == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure CorrectInput = value;

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^CorrectInput;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <1010,230,1210,270>
  $output true
  method void UpdateProperty( arg bool aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure CorrectInput )
    {
      // Remember the new value in the internal memory of the property.
      pure CorrectInput = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^CorrectInput;
    }
  }

  $rect <1210,330,1410,370>
  property string ErrorTxt;

  $rect <1210,380,1410,420>
  onget ErrorTxt
  {
    // Per default return the value stored already in the property.
    return pure ErrorTxt;

    /*

      TO DO:

      If the property should return the value stored in the underlying device
      or in the middleware, remove the above 'return' statement and instead do
      following:

      Declare a local variable to receive the value from the underlying device.
      The type of the variable has to correspond to the data type of the property.
      For example in case of an 'int32' property:
      
        var int32 result;

      Implement a native statement to access the value and to store it in the
      variable 'result'. Then return the value. For example:

        $if !$prototyper
          native ( result )
          {
            result = YourDevice_GetSomeValue();
          }
        $endif

        return result;

    */
  }

  $rect <1010,380,1210,420>
  onset ErrorTxt
  {
    // The property doesn't change -> nothing to do.
    if ( pure ErrorTxt == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure ErrorTxt = value;

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^ErrorTxt;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <1010,330,1210,370>
  $output true
  method void UpdateProperty1( arg string aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure ErrorTxt )
    {
      // Remember the new value in the internal memory of the property.
      pure ErrorTxt = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^ErrorTxt;
    }
  }

  $rect <1200,690,1400,730>
  property int32 BatteryLvl = 101;

  $rect <1600,690,1800,730>
  onget BatteryLvl
  {
    // Per default return the value stored already in the property.
    return pure BatteryLvl;

    /*

      TO DO:

      If the property should return the value stored in the underlying device
      or in the middleware, remove the above 'return' statement and instead do
      following:

      Declare a local variable to receive the value from the underlying device.
      The type of the variable has to correspond to the data type of the property.
      For example in case of an 'int32' property:
      
        var int32 result;

      Implement a native statement to access the value and to store it in the
      variable 'result'. Then return the value. For example:

        $if !$prototyper
          native ( result )
          {
            result = YourDevice_GetSomeValue();
          }
        $endif

        return result;

    */
  }

  $rect <1400,690,1600,730>
  onset BatteryLvl
  {
    // The property doesn't change -> nothing to do.
    if ( pure BatteryLvl == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure BatteryLvl = value;

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^BatteryLvl;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <1000,690,1200,730>
  $output true
  method void UpdateProperty2( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure BatteryLvl )
    {
      // Remember the new value in the internal memory of the property.
      pure BatteryLvl = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^BatteryLvl;
    }
  }

  $rect <730,100,930,140>
  method bool IsMinus( arg char op )
  {
    return op == '-';
  }

  $rect <730,150,930,190>
  method bool OperatorNotMinus( arg char op )
  {
    return ( op == '+' || op == 'x' || op == '/' ||  op == '%' || op == '^');
  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Init
  $member Bounds
  $member KeyHandlerNote
  $member ScreenOn
  $member ScreenOnB
  $member ScreenT
  $member ScreenOff
  $member ScreenOffBL
  $member ScreenOffBR
  $member OutputBgk
  $member Border
  $member Text
  $member Keypad
  $member KeyHandler
  $member CalculateExpression
  $member ExecTwoOp
  $member ResetVariables
  $member IsOperator
  $member Note
  $member GetPriorityOfOperator
  $member GetNumberFromPosition
  $member IsExpressionValid
  $member IsDigit
  $member CorrectParentheses
  $member OperatorsCorrectlyUsed
  $member IsParenthesis
  $member CharactersAllowed
  $member IsWhiteSpace
  $member IsNumber
  $member IsDot
  $member IsNegativeNumber
  $member IsSpace
  $member TokenizeExpression
  $member ShuntingYardAlgorithm
  $member EvaluateRPN
  $member BatteryDialog
  $member Note1
  $member Note2
  $member Note3
  $member Note4
  $member PowerOff
  $member BatteryLevelObserver
  $member onBatteryOut
  $member ReplaceBatteryDialog
  $member StateObserver
  $member onStateTrue
  $member TurnScreenOn
  $member TurnScreenOff
  $member Note5
  $member NewBatteryObserver
  $member onValidBattery
  $member PowerOn
  $member RemoveExtraSymbols
  $member CorrectInput
  $member OnGetCorrectInput
  $member OnSetCorrectInput
  $member UpdateProperty
  $member ErrorTxt
  $member OnGetErrorTxt
  $member OnSetErrorTxt
  $member UpdateProperty1
  $member BatteryLvl
  $member OnGetBatteryLvl
  $member OnSetBatteryLvl
  $member UpdateProperty2
  $member IsMinus
  $member OperatorNotMinus
}

$rect <460,20,660,60>
$output false
resource Resources::Font NumFont
{
  attr fontname FontName = Book Antiqua;
  attr fontheight Height = 50;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <460,120,660,160>
$output false
resource Resources::Font DigitalResFont
{
  attr fontname FontName = Digital-7;
  attr fontheight Height = 60;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <-300,240,-100,280>
$output false
class NumKeyBtns : Core::Group
{
  $rect <340,340,540,380>
  inherited property Bounds = <0,0,300,440>;

  $rect <870,40,1110,80>
  object WidgetSet::PushButtonConfig DigitOpConfig
  {
    preset KeyCode = Core::KeyCode.NoKey;
    preset AccentColorFocused = #03040000;
    preset AccentColorDefault = #00000000;
    preset AccentLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset LabelColorActive = #8E6B74FF;
    preset LabelColorFocused = #8E6B74FF;
    preset LabelColorDisabled = #8E6B74FF;
    preset LabelColorDefault = #000000FF;
    preset LabelFont = Application::NumFont;
    preset FaceLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset FaceFrameActive = 1;
    preset FaceFrameFocused = 1;
    preset FaceFrameDisabled = 0;
    preset FaceFrameDefault = 0;
    preset FaceBitmapActive = Application::CustomBtn;
    preset FaceBitmapFocused = Application::CustomBtn;
    preset FaceBitmapDisabled = Application::CustomBtn;
    preset FaceBitmapDefault = Application::CustomBtn;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Two
  {
    preset Bounds = <80,150,150,220>;
    preset OnActivate = onActivateKey;
    preset Label = "2";
    preset Appearance = DigitOpConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Three
  {
    preset Bounds = <151,150,221,220>;
    preset OnActivate = onActivateKey;
    preset Label = "3";
    preset Appearance = DigitOpConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Four
  {
    preset Bounds = <10,220,80,290>;
    preset OnActivate = onActivateKey;
    preset Label = "4";
    preset Appearance = DigitOpConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Five
  {
    preset Bounds = <80,220,150,290>;
    preset OnActivate = onActivateKey;
    preset Label = "5";
    preset Appearance = DigitOpConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Six
  {
    preset Bounds = <150,220,220,290>;
    preset OnActivate = onActivateKey;
    preset Label = "6";
    preset Appearance = DigitOpConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Seven
  {
    preset Bounds = <10,290,80,360>;
    preset OnActivate = onActivateKey;
    preset Label = "7";
    preset Appearance = DigitOpConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Eight
  {
    preset Bounds = <80,290,150,360>;
    preset OnActivate = onActivateKey;
    preset Label = "8";
    preset Appearance = DigitOpConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Nine
  {
    preset Bounds = <150,290,220,360>;
    preset OnActivate = onActivateKey;
    preset Label = "9";
    preset Appearance = DigitOpConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Zero
  {
    preset Bounds = <80,360,150,430>;
    preset OnActivate = onActivateKey;
    preset Label = "0";
    preset Appearance = DigitOpConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Clear
  {
    preset Bounds = <10,7,80,77>;
    preset OnActivate = onActivateKey;
    preset Label = "C";
    preset Appearance = MultiplyConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Equals
  {
    preset Bounds = <149,360,293,428>;
    preset OnActivate = onActivateKey;
    preset Label = "=";
    preset Appearance = EqualsConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Plus
  {
    preset Bounds = <222,290,292,360>;
    preset OnActivate = onActivateKey;
    preset Label = "+";
    preset Appearance = DigitOpBoldConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Minus
  {
    preset Bounds = <221,220,291,290>;
    preset OnActivate = onActivateKey;
    preset Label = "-";
    preset Appearance = MultiplyConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Multiply
  {
    preset Bounds = <221,150,291,220>;
    preset OnActivate = onActivateKey;
    preset Label = "x";
    preset Appearance = MultiplyConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Divide
  {
    preset Bounds = <222,80,292,150>;
    preset OnActivate = onActivateKey;
    preset Label = "/";
    preset Appearance = DivideConfig;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset StackingPriority = -1;
    preset Bounds = <0,1,300,440>;
    preset Radius = 5;
    preset Width = 2;
    preset Color = #030324FF;
  }

  $rect <870,290,1110,330>
  object WidgetSet::PushButtonConfig EqualsConfig
  {
    preset OnUpdate = null;
    preset KeyCode = Core::KeyCode.Equals;
    preset LabelColorActive = #FFFCFEFF;
    preset LabelColorFocused = #FFFCFEFF;
    preset LabelColorDisabled = #FFFCFEFF;
    preset LabelColorDefault = #990002FF;
    preset LabelFont = Application::EqFont;
    preset FaceFrameActive = 1;
    preset FaceFrameFocused = 1;
    preset FaceFrameDisabled = 0;
    preset FaceFrameDefault = 0;
    preset FaceBitmapActive = Application::EqualsBtn;
    preset FaceBitmapFocused = Application::EqualsBtn;
    preset FaceBitmapDisabled = Application::EqualsBtn;
    preset FaceBitmapDefault = Application::EqualsBtn;
  }

  $rect <360,60,560,100>
  slot onActivateKey
  {
    sender; /* the method is called from the sender object */
    var WidgetSet::PushButton currentSender = ( WidgetSet::PushButton )sender;

    if ( currentSender != null ) 
    {
      keyString = currentSender.Label;
      var char charCode = '\0';
      var Core::KeyCode keyCode = Core::KeyCode.NoKey;

      if ( keyString != "" ) 
      {   
        charCode = keyString[0];
        if ( charCode != '\0' && keyCode == Core::KeyCode.NoKey ) 
        {
          GetRoot().DriveKeyboardHitting(Core::KeyCode.NoKey, charCode, true);
          GetRoot().DriveKeyboardHitting(Core::KeyCode.NoKey, charCode, false);
        }

        if ( keyCode != Core::KeyCode.NoKey ) 
        {
          GetRoot().DriveKeyboardHitting(keyCode, '\0', true);
          GetRoot().DriveKeyboardHitting(keyCode, '\0', false);
        }

      } 
      else
        trace "textKeyView is null";
    } 
    else 
        trace "focusedView is null";
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Dot
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <9,360,79,430>;
    preset OnActivate = onActivateKey;
    preset Label = ".";
    preset Appearance = DigitOpConfig;
  }

  $rect <360,260,560,300>
  object Core::Timer FlashKeyTimer
  {
    preset OnTrigger = triggerTimer;
    preset Period = 0;
    preset Begin = 100;
    preset Enabled = false;
  }

  $rect <600,260,800,300>
  slot triggerTimer
  {
    sender; /* the method is called from the sender object */
    InvalidateViewState();
  }

  // Flash effect
  note group Note
  {
    attr Bounds = <340,210,820,330>;
  }

  // Handling pressed key
  note group Note1
  {
    attr Bounds = <340,0,820,190>;
  }

  // Push Button Configurations
  note group Note2
  {
    attr Bounds = <840,0,1140,500>;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton empty00
  {
    preset Bounds = <1189,145,1254,195>;
    preset Label = "Caption";
    preset Appearance = DigitOpConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton One
  {
    preset Bounds = <10,150,80,220>;
    preset OnActivate = onActivateKey;
    preset Label = "1";
    preset Appearance = DigitOpConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Power
  {
    preset Bounds = <80,80,150,150>;
    preset OnActivate = onActivateKey;
    preset IconFrameActive = 1;
    preset IconFrameFocused = 1;
    preset IconFrameDefault = 0;
    preset IconFrame = 0;
    preset Icon = null;
    preset Label = "^";
    preset Appearance = PowConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Percentage
  {
    preset Bounds = <150,79,220,149>;
    preset OnActivate = onActivateKey;
    preset Label = "%";
    preset Appearance = PercentConfig;
  }

  $rect <870,140,1110,180>
  object WidgetSet::PushButtonConfig PowConfig
  {
    preset KeyCode = Core::KeyCode.Power;
    preset IconMarginBottom = 2;
    preset IconMarginTop = 2;
    preset IconMarginRight = 2;
    preset IconMarginLeft = 2;
    preset IconAlignment = Views::ImageAlignment[AlignHorzCenter, AlignVertCenter];
    preset FaceFrameActive = 1;
    preset FaceFrameFocused = 1;
    preset FaceFrameDisabled = 0;
    preset FaceFrameDefault = 0;
    preset FaceBitmapActive = Application::PowBtn;
    preset FaceBitmapFocused = Application::PowBtn;
    preset FaceBitmapDisabled = Application::PowBtn;
    preset FaceBitmapDefault = Application::PowBtn;
  }

  $rect <870,190,1110,230>
  object WidgetSet::PushButtonConfig PercentConfig
  {
    preset KeyCode = Core::KeyCode.NoKey;
    preset FaceFrameActive = 1;
    preset FaceFrameFocused = 1;
    preset FaceFrameDisabled = 0;
    preset FaceFrameDefault = 0;
    preset FaceBitmapActive = Application::PercentBtn;
    preset FaceBitmapFocused = Application::PercentBtn;
    preset FaceBitmapDisabled = Application::PercentBtn;
    preset FaceBitmapDefault = Application::PercentBtn;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton empty01
  {
    preset Bounds = <1189,5,1254,55>;
    preset Label = "Caption";
    preset Appearance = PowConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton empty02
  {
    preset Bounds = <1189,75,1254,125>;
    preset Label = "Caption";
    preset Appearance = PercentConfig;
  }

  $rect <870,90,1110,130>
  object WidgetSet::PushButtonConfig DigitOpBoldConfig
  {
    preset KeyCode = Core::KeyCode.NoKey;
    preset AccentColorFocused = #03040000;
    preset AccentColorDefault = #00000000;
    preset AccentLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset LabelColorActive = #8E6B74FF;
    preset LabelColorFocused = #8E6B74FF;
    preset LabelColorDisabled = #8E6B74FF;
    preset LabelColorDefault = #000000FF;
    preset LabelFont = Application::NumBoldFont;
    preset FaceLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset FaceFrameActive = 1;
    preset FaceFrameFocused = 1;
    preset FaceFrameDisabled = 0;
    preset FaceFrameDefault = 0;
    preset FaceBitmapActive = Application::CustomBtn;
    preset FaceBitmapFocused = Application::CustomBtn;
    preset FaceBitmapDisabled = Application::CustomBtn;
    preset FaceBitmapDefault = Application::CustomBtn;
  }

  $rect <870,240,1110,280>
  object WidgetSet::PushButtonConfig DivideConfig
  {
    preset KeyCode = Core::KeyCode.Divide;
    preset FaceFrameActive = 1;
    preset FaceFrameFocused = 1;
    preset FaceFrameDisabled = 0;
    preset FaceFrameDefault = 0;
    preset FaceBitmapActive = Application::DivideBtn;
    preset FaceBitmapFocused = Application::DivideBtn;
    preset FaceBitmapDisabled = Application::DivideBtn;
    preset FaceBitmapDefault = Application::DivideBtn;
  }

  $rect <870,340,1110,380>
  object WidgetSet::PushButtonConfig MultiplyConfig
  {
    preset KeyCode = Core::KeyCode.Multiply;
    preset AccentColorFocused = #03040000;
    preset AccentColorDefault = #00000000;
    preset AccentLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset LabelColorActive = #8E6B74FF;
    preset LabelColorFocused = #8E6B74FF;
    preset LabelColorDisabled = #8E6B74FF;
    preset LabelColorDefault = #000000FF;
    preset LabelFont = Application::MultiplyFont;
    preset FaceLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset FaceFrameActive = 1;
    preset FaceFrameFocused = 1;
    preset FaceFrameDisabled = 0;
    preset FaceFrameDefault = 0;
    preset FaceBitmapActive = Application::CustomBtn;
    preset FaceBitmapFocused = Application::CustomBtn;
    preset FaceBitmapDisabled = Application::CustomBtn;
    preset FaceBitmapDefault = Application::CustomBtn;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton OpenParanthesis
  {
    preset Bounds = <10,80,45,150>;
    preset OnActivate = onActivateKey;
    preset Label = "(";
    preset Appearance = ParanthesisConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton ClosedParanthesis
  {
    preset Bounds = <45,80,80,150>;
    preset OnActivate = onActivateKey;
    preset Label = ")";
    preset Appearance = ParanthesisConfig;
  }

  $rect <870,390,1110,430>
  object WidgetSet::PushButtonConfig ParanthesisConfig
  {
    preset KeyCode = Core::KeyCode.NoKey;
    preset AccentColorFocused = #03040000;
    preset AccentColorDefault = #00000000;
    preset AccentLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset LabelColorActive = #FFFCFEFF;
    preset LabelColorFocused = #FFFCFEFF;
    preset LabelColorDisabled = #FFFCFEFF;
    preset LabelColorDefault = #000000FF;
    preset LabelFont = Application::NumFont;
    preset FaceLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset FaceFrameActive = 1;
    preset FaceFrameFocused = 1;
    preset FaceFrameDisabled = 0;
    preset FaceFrameDefault = 0;
    preset FaceBitmapActive = Application::ParenthesisBtn;
    preset FaceBitmapFocused = Application::ParenthesisBtn;
    preset FaceBitmapDisabled = Application::ParenthesisBtn;
    preset FaceBitmapDefault = Application::ParenthesisBtn;
  }

  $rect <870,440,1110,480>
  object WidgetSet::PushButtonConfig BackConfig
  {
    preset KeyCode = Core::KeyCode.Backspace;
    preset FaceFrameActive = 1;
    preset FaceFrameFocused = 1;
    preset FaceFrameDisabled = 0;
    preset FaceFrameDefault = 0;
    preset FaceBitmapActive = Application::BackBtn;
    preset FaceBitmapFocused = Application::BackBtn;
    preset FaceBitmapDisabled = Application::BackBtn;
    preset FaceBitmapDefault = Application::BackBtn;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton BackBtn
  {
    preset Bounds = <222,7,292,77>;
    preset OnActivate = onActivateKey;
    preset Label = "B";
    preset Appearance = BackConfig;
  }

  $rect <590,50,790,90>
  property string keyString;

  $rect <590,90,790,130>
  onset keyString
  {
    // The value doesn't change - nothing to do.
    if ( pure keyString == value )
      return;

    // Remember the property's new value.
    pure keyString = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <590,130,790,170>
  onget keyString
  {
    return pure keyString;
  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Bounds
  $member Border
  $member DigitOpConfig
  $member EqualsConfig
  $member onActivateKey
  $member FlashKeyTimer
  $member triggerTimer
  $member Note
  $member Note1
  $member Note2
  $member empty00
  $member empty01
  $member empty02
  $member One
  $member Two
  $member Three
  $member Four
  $member Five
  $member Six
  $member Seven
  $member Eight
  $member Nine
  $member Zero
  $member Clear
  $member Plus
  $member Minus
  $member Multiply
  $member Divide
  $member Dot
  $member Power
  $member Percentage
  $member OpenParanthesis
  $member ClosedParanthesis
  $member Equals
  $member PowConfig
  $member PercentConfig
  $member DigitOpBoldConfig
  $member DivideConfig
  $member MultiplyConfig
  $member ParanthesisConfig
  $member BackConfig
  $member BackBtn
  $member keyString
  $member OnSetkeyString
  $member OnGetkeyString
}

$rect <-37,340,163,380>
$output false
resource Resources::Bitmap CustomBtn
{
  attr bitmapfile FileName = .\resources\buttons.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <70,70>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <-37,390,163,430>
$output false
resource Resources::Bitmap EqualsBtn
{
  attr bitmapfile FileName = .\resources\equals.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <140,70>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <460,170,660,210>
$output false
resource Resources::Font EqFont
{
  attr fontname FontName = Book Antiqua;
  attr fontheight Height = 90;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <-37,440,163,480>
$output false
resource Resources::Bitmap PercentBtn
{
  attr bitmapfile FileName = .\resources\percent.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <70,70>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <-37,490,163,530>
$output false
resource Resources::Bitmap PowBtn
{
  attr bitmapfile FileName = .\resources\pow.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <70,70>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// Components
note group Note
{
  attr Bounds = <-320,100,-80,500>;
}

// Bitmaps
note group Note1
{
  attr Bounds = <-60,300,420,750>;
}

// Fonts
note group Note2
{
  attr Bounds = <440,-20,680,480>;
}

// Application
note group Note3
{
  attr Bounds = <-320,-20,-80,80>;
}

$rect <460,70,660,110>
$output false
resource Resources::Font NumBoldFont
{
  attr fontname FontName = Book Antiqua;
  attr fontheight Height = 50;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <-40,539,160,579>
$output false
resource Resources::Bitmap DivideBtn
{
  attr bitmapfile FileName = .\resources\divide.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <70,70>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <460,270,660,310>
$output false
resource Resources::Font MultiplyFont
{
  attr fontname FontName = Consolas;
  attr fontheight Height = 50;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <200,230,400,270>
$output false
class Tuple
{
  $rect <239,-10,439,30>
  property float IdentifiedNumber;

  $rect <239,30,439,70>
  onset IdentifiedNumber
  {
    // The value doesn't change - nothing to do.
    if ( pure IdentifiedNumber == value )
      return;

    // Remember the property's new value.
    pure IdentifiedNumber = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <239,70,439,110>
  onget IdentifiedNumber
  {
    return pure IdentifiedNumber;
  }

  $rect <240,120,440,160>
  property int32 EndPosition = -1;

  $rect <240,160,440,200>
  onset EndPosition
  {
    // The value doesn't change - nothing to do.
    if ( pure EndPosition == value )
      return;

    // Remember the property's new value.
    pure EndPosition = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <240,200,440,240>
  onget EndPosition
  {
    return pure EndPosition;
  }

  $rect <480,-10,680,30>
  property string Subexpression = "none";

  $rect <480,30,680,70>
  onset Subexpression
  {
    // The value doesn't change - nothing to do.
    if ( pure Subexpression == value )
      return;

    // Remember the property's new value.
    pure Subexpression = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <480,70,680,110>
  onget Subexpression
  {
    return pure Subexpression;
  }

  $rect <10,10,160,50>
  inherited method Init()
  {
    aArg;
    IdentifiedNumber = float_infp();
    EndPosition = -1;
    Subexpression = "none";
  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Init
  $member IdentifiedNumber
  $member OnSetIdentifiedNumber
  $member OnGetIdentifiedNumber
  $member EndPosition
  $member OnSetEndPosition
  $member OnGetEndPosition
  $member Subexpression
  $member OnSetSubexpression
  $member OnGetSubexpression
}

$rect <-300,290,-100,330>
$output false
class ErrorDialog : Core::Group
{
  $rect <20,130,220,170>
  inherited property Bounds = <0,0,250,100>;

  $rect <20,20,160,60>
  object Views::Rectangle Bgk
  {
    preset Bounds = <0,0,250,100>;
    preset Radius = 3;
    preset Color = #E2E6E9FF;
  }

  $rect <20,20,160,60>
  object Views::Border BgkBorder
  {
    preset Bounds = <0,-1,250,100>;
    preset Radius = 3;
    preset Width = 2;
    preset Color = #470400FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle TopBar
  {
    preset Bounds = <0,0,250,30>;
    preset RadiusTR = 3;
    preset RadiusTL = 3;
    preset Radius = 3;
    preset Color = #990002FF;
  }

  $rect <20,20,160,60>
  object Views::Border TopBarBgk
  {
    preset Bounds = <0,0,250,30>;
    preset Width = 2;
    preset Color = #460400FF;
  }

  $rect <630,40,870,80>
  object WidgetSet::PushButtonConfig ExitBtnConfig
  {
    preset KeyCode = Core::KeyCode.Enter;
    preset LabelColorActive = #FFFFFFFF;
    preset LabelColorDisabled = #FFFFFFFF;
    preset LabelColorDefault = #000000FF;
    preset LabelMarginBottom = 3;
    preset LabelAlignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset LabelFont = Application::BtnFont;
  }

  $rect <20,20,160,60>
  object Views::Text ErrorText
  {
    preset Bounds = <5,38,235,78>;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertTop];
    preset String = "no errors";
    preset Font = Application::ErrorFont;
    preset Color = #2D0200FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <213,3,243,28>;
    preset OnActivate = onClose;
    preset Label = "X";
    preset Appearance = ExitBtnConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <159,61,243,91>;
    preset OnActivate = onClose;
    preset Label = "OK";
    preset Appearance = OkBtnConfig;
  }

  $rect <630,90,870,130>
  object WidgetSet::PushButtonConfig OkBtnConfig
  {
    preset KeyCode = Core::KeyCode.Enter;
    preset ThumbBorderColorActive = #20943100;
    preset ThumbBorderColorDefault = #3A842A00;
    preset ThumbBorderWidthActive = 0;
    preset ThumbBorderWidthDefault = 0;
    preset ThumbColorActive = #CC7E5100;
    preset ThumbColorDefault = #B7321F00;
    preset ThumbLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset LabelColorActive = #FFFFFFFF;
    preset LabelColorDisabled = #FFFFFFFF;
    preset LabelColorDefault = #000000FF;
    preset LabelMarginBottom = 3;
    preset LabelAlignment = Views::TextAlignment[AlignHorzAuto, AlignHorzCenter, AlignVertCenter];
    preset LabelFont = Application::BtnFont;
    preset FaceFrameActive = 1;
    preset FaceFrameFocused = 1;
    preset FaceFrameDisabled = 0;
    preset FaceFrameDefault = 0;
    preset FaceBitmapActive = Application::OKBtn;
    preset FaceBitmapFocused = Application::OKBtn;
    preset FaceBitmapDisabled = Application::OKBtn;
    preset FaceBitmapDefault = Application::OKBtn;
  }

  $rect <330,90,530,130>
  slot onClose
  {
    idlesignal OnCloseDialog;
  }

  $rect <330,40,530,80>
  property slot OnCloseDialog = null;

  $rect <20,20,160,60>
  object Views::Text Title
  {
    preset Bounds = <5,0,145,30>;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter, AlignVertTop];
    preset String = "CALCULATOR ERROR";
    preset Font = Application::ErrorFont;
    preset Color = #F2E6DDFF;
  }

  // Button Configs
  note group Note
  {
    attr Bounds = <600,0,900,150>;
  }

  // Close Dialog
  note group Note1
  {
    attr Bounds = <280,0,580,150>;
  }
}

$rect <460,320,660,360>
$output false
resource Resources::Font ErrorFont
{
  attr fontname FontName = Asap Condensed Medium;
  attr fontheight Height = 15;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <460,370,660,410>
$output false
resource Resources::Font BtnFont
{
  attr fontname FontName = Microsoft Yi Baiti;
  attr fontheight Height = 27;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <-37,640,163,680>
$output false
resource Resources::Bitmap OKBtn
{
  attr bitmapfile FileName = .\resources\ok.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <70,30>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <-37,590,163,630>
$output false
resource Resources::Bitmap ParenthesisBtn
{
  attr bitmapfile FileName = .\resources\paranthesis.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <35,70>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <193,340,393,380>
$output false
resource Resources::Bitmap BackBtn
{
  attr bitmapfile FileName = .\resources\back.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <70,70>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <193,390,393,430>
$output false
resource Resources::Bitmap BatteryBgk
{
  attr bitmapfile FileName = .\resources\battery-filled.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <110,50>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <193,440,393,480>
$output false
resource Resources::Bitmap BatteryLine
{
  attr bitmapfile FileName = .\resources\battery-line.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <5,46>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <-300,340,-100,380>
$output false
class Battery : Core::Group
{
  $rect <140,0,340,40>
  inherited property Bounds = <0,0,120,54>;

  $rect <20,20,160,60>
  object Views::Image Bgk
  {
    preset Bounds = <5,2,115,52>;
    preset Bitmap = Application::BatteryBgk;
  }

  $rect <20,20,160,60>
  object Views::Image line1
  {
    preset Bounds = <7,4,12,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <0,350,200,390>
  slot onUseBattery
  {
    BatteryPercentage -= 0.05;
    var string str = "100";

    str = BatteryPercentage;

    if( BatteryPercentage < 50 )
    {
      Text.Color = Orange;
    }
    if ( BatteryPercentage < 20 )
    {
      Text.Color = Red;
    }

    Text.String = str;

    if( BatteryPercentage < 0 )
      BatteryPercentage = 0;

    if( BatteryPercentage < 20 )
      UpdateLowBatteryLines(BatteryPercentage);
    else
      UpdateBatteryLines(BatteryPercentage);
  }

  $rect <20,20,160,60>
  object Views::Image line2
  {
    preset Bounds = <12,4,17,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line3
  {
    preset Bounds = <17,4,22,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line4
  {
    preset Bounds = <22,4,27,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line5
  {
    preset Bounds = <27,4,32,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line6
  {
    preset Bounds = <32,4,37,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line7
  {
    preset Bounds = <37,4,42,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line8
  {
    preset Bounds = <42,4,47,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line9
  {
    preset Bounds = <47,4,52,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line10
  {
    preset Bounds = <52,4,57,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line11
  {
    preset Bounds = <57,4,62,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line12
  {
    preset Bounds = <62,4,67,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line13
  {
    preset Bounds = <67,4,72,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line14
  {
    preset Bounds = <72,4,77,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line15
  {
    preset Bounds = <77,4,82,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line16
  {
    preset Bounds = <82,4,87,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line17
  {
    preset Bounds = <87,4,92,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line18
  {
    preset Bounds = <92,4,97,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line19
  {
    preset Bounds = <97,4,102,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line20
  {
    preset Bounds = <102,4,107,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <0,300,200,340>
  object Core::Timer Timer
  {
    preset OnTrigger = onUseBattery;
    preset Period = 7000;
    preset Enabled = true;
  }

  $rect <200,300,400,340>
  method void UpdateBatteryLines( arg int32 percentage )
  {
    var int32 linesToShow = percentage / 5;

    var int32 i = 0;
      
    for( ; i < 20; i++ )
    {
      if( i < linesToShow )
      {
        batteryLines[i].Visible = true;
      }
      else
      {
        batteryLines[i].Visible = false;
      }     
    }
  }

  $rect <560,0,760,40>
  array Views::Image batteryLines[ 20 ] =
  (
    Default[0] = line1;
    Default[1] = line2;
    Default[2] = line3;
    Default[3] = line4;
    Default[4] = line5;
    Default[5] = line6;
    Default[6] = line7;
    Default[7] = line8;
    Default[8] = line9;
    Default[9] = line10;
    Default[10] = line11;
    Default[11] = line12;
    Default[12] = line13;
    Default[13] = line14;
    Default[14] = line15;
    Default[15] = line16;
    Default[16] = line17;
    Default[17] = line18;
    Default[18] = line19;
    Default[19] = line20;
  );

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <13,6,97,46>;
    preset String = "";
    preset Font = Application::BatteryFont;
    preset Color = #004606FF;
  }

  $rect <20,20,160,60>
  object Views::Image low1
  {
    preset Bounds = <7,4,12,50>;
    preset Bitmap = Application::LowBattery;
    preset Visible = true;
  }

  $rect <20,20,160,60>
  object Views::Image low2
  {
    preset Bounds = <12,4,17,50>;
    preset Bitmap = Application::LowBattery;
    preset Visible = true;
  }

  $rect <20,20,160,60>
  object Views::Image low3
  {
    preset Bounds = <17,4,22,50>;
    preset Bitmap = Application::LowBattery;
    preset Visible = true;
  }

  $rect <20,20,160,60>
  object Views::Image low4
  {
    preset Bounds = <22,4,27,50>;
    preset Bitmap = Application::LowBattery;
    preset Visible = true;
  }

  $rect <350,0,550,40>
  array Views::Image lowBatteryLines[ 20 ] =
  (
    Default[0] = low1;
    Default[1] = low2;
    Default[2] = low3;
    Default[3] = low4;
    Default[4] = line5;
    Default[5] = line6;
    Default[6] = line7;
    Default[7] = line8;
    Default[8] = line9;
    Default[9] = line10;
    Default[10] = line11;
    Default[11] = line12;
    Default[12] = line13;
    Default[13] = line14;
    Default[14] = line15;
    Default[15] = line16;
    Default[16] = line17;
    Default[17] = line18;
    Default[18] = line19;
    Default[19] = line20;
  );

  $rect <200,350,420,390>
  method void UpdateLowBatteryLines( arg int32 percentage )
  {
    HideInitialLines();

    var int32 linesToShow = percentage / 5;

    var int32 i = 0;
      
    for( ; i < 20; i++ )
    {
      if( i < linesToShow )
      {
        lowBatteryLines[i].Visible = true;
      }
      else
      {
        lowBatteryLines[i].Visible = false;
      }     
    }
  }

  $rect <400,300,600,340>
  method void HideInitialLines()
  {
    batteryLines[0].Visible = false;
    batteryLines[1].Visible = false;
    batteryLines[2].Visible = false;
    batteryLines[3].Visible = false;
    batteryLines[4].Visible = false;
    batteryLines[5].Visible = false;
    batteryLines[6].Visible = false;
    batteryLines[7].Visible = false;
    batteryLines[8].Visible = false;
    batteryLines[9].Visible = false;
    batteryLines[10].Visible = false;
    batteryLines[11].Visible = false;
    batteryLines[12].Visible = false;
    batteryLines[13].Visible = false;
    batteryLines[14].Visible = false;
    batteryLines[15].Visible = false;
    batteryLines[16].Visible = false;
    batteryLines[17].Visible = false;
    batteryLines[18].Visible = false;
    batteryLines[19].Visible = false;

  }

  $rect <200,120,400,160>
  property int32 BatteryPercentage = 101;

  $rect <600,120,800,160>
  onget BatteryPercentage
  {
    // Per default return the value stored already in the property.
    return pure BatteryPercentage;

    /*

      TO DO:

      If the property should return the value stored in the underlying device
      or in the middleware, remove the above 'return' statement and instead do
      following:

      Declare a local variable to receive the value from the underlying device.
      The type of the variable has to correspond to the data type of the property.
      For example in case of an 'int32' property:
      
        var int32 result;

      Implement a native statement to access the value and to store it in the
      variable 'result'. Then return the value. For example:

        $if !$prototyper
          native ( result )
          {
            result = YourDevice_GetSomeValue();
          }
        $endif

        return result;

    */
  }

  $rect <400,120,600,160>
  onset BatteryPercentage
  {
    // The property doesn't change -> nothing to do.
    if ( pure BatteryPercentage == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure BatteryPercentage = value;

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^BatteryPercentage;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <0,120,200,160>
  $output true
  method void UpdateBatteryPercentage( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure BatteryPercentage )
    {
      // Remember the new value in the internal memory of the property.
      pure BatteryPercentage = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^BatteryPercentage;
    }
  }

  $rect <600,300,800,340>
  object Effects::Int32Effect Int32Effect
  {
    preset OnFinished = onEffectFinished;
    preset NoOfCycles = 7;
    preset CycleDuration = 500;
    preset Outlet = ^Text.Opacity;
  }

  $rect <600,350,800,390>
  slot onEffectFinished
  {
    State = true; 
  }

  $rect <200,170,400,210>
  property bool State = false;

  $rect <600,170,800,210>
  onget State
  {
    // Per default return the value stored already in the property.
    return pure State;

    /*

      TO DO:

      If the property should return the value stored in the underlying device
      or in the middleware, remove the above 'return' statement and instead do
      following:

      Declare a local variable to receive the value from the underlying device.
      The type of the variable has to correspond to the data type of the property.
      For example in case of an 'int32' property:
      
        var int32 result;

      Implement a native statement to access the value and to store it in the
      variable 'result'. Then return the value. For example:

        $if !$prototyper
          native ( result )
          {
            result = YourDevice_GetSomeValue();
          }
        $endif

        return result;

    */
  }

  $rect <400,170,600,210>
  onset State
  {
    // The property doesn't change -> nothing to do.
    if ( pure State == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure State = value;

    notifyobservers ^State;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <0,170,200,210>
  $output true
  method void UpdateState( arg bool aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure State )
    {
      // Remember the new value in the internal memory of the property.
      pure State = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^State;
    }
  }

  $rect <860,70,1060,110>
  var color Green = #004606FF;

  $rect <860,120,1060,160>
  var color Orange = #BC5F00FF;

  $rect <860,170,1060,210>
  var color Red = #CB0014FF;

  // Text Colors
  note group Note
  {
    attr Bounds = <840,30,1080,230>;
  }

  // Properties
  note group Note1
  {
    attr Bounds = <-10,80,810,230>;
  }

  // Timer, battery update & effects
  note group Note2
  {
    attr Bounds = <-10,250,810,410>;
  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Bounds
  $member Bgk
  $member low1
  $member low2
  $member low3
  $member low4
  $member line1
  $member line2
  $member line3
  $member line4
  $member line5
  $member line6
  $member line7
  $member line8
  $member line9
  $member line10
  $member line11
  $member line12
  $member line13
  $member line14
  $member line15
  $member line16
  $member line17
  $member line18
  $member line19
  $member line20
  $member onUseBattery
  $member Timer
  $member UpdateBatteryLines
  $member batteryLines
  $member Text
  $member lowBatteryLines
  $member UpdateLowBatteryLines
  $member HideInitialLines
  $member BatteryPercentage
  $member OnGetBatteryPercentage
  $member OnSetBatteryPercentage
  $member UpdateBatteryPercentage
  $member Int32Effect
  $member onEffectFinished
  $member State
  $member OnGetState
  $member OnSetState
  $member UpdateState
  $member Green
  $member Orange
  $member Red
  $member Note
  $member Note1
  $member Note2
}

$rect <200,130,400,170>
$output false
class SimpleStringElement
{
  $rect <112,67,312,107>
  property string DataStr;

  $rect <112,107,312,147>
  onset DataStr
  {
    // The value doesn't change - nothing to do.
    if ( pure DataStr == value )
      return;

    // Remember the property's new value.
    pure DataStr = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <112,147,312,187>
  onget DataStr
  {
    return pure DataStr;
  }

  $rect <350,70,550,110>
  property Application::SimpleStringElement Next;

  $rect <350,110,550,150>
  onset Next
  {
    // The value doesn't change - nothing to do.
    if ( pure Next == value )
      return;

    // Remember the property's new value.
    pure Next = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <350,150,550,190>
  onget Next
  {
    return pure Next;
  }

  // Directives to adapt the order of members belonging to this class so they appear 
  // correctly arranged relative to the members inherited from the ancestor (super) 
  // classes. The numbers indicate the order-displacement to apply on the respective 
  // member once all members have been loaded and combined with members from the 
  // ancestor classes.
  $reorder DataStr 1
  $reorder OnSetDataStr 1
  $reorder OnGetDataStr 1
}

$rect <-30,80,170,120>
$output false
class StrQueue
{
  $rect <640,150,840,190>
  method void Push( arg string aValue )
  {
    var Application::SimpleStringElement strElement = new Application::SimpleStringElement;
    strElement.DataStr = aValue;
    strElement.Next = null;

    if( Front == null )
    {
      Front = strElement;
      Back = strElement;
    }
    else
    {
      Back.Next = strElement;
      Back = strElement;
    }
  }

  $rect <640,200,840,240>
  method void Pop()
  {
    var Application::SimpleStringElement aux = Front;

    if( aux == null )
    {
      trace "Queue is empty!";
    }
    else 
    {
       Front = Front.Next;
       aux = null;
    }
  }

  $rect <880,150,1080,190>
  method string GetFront()
  {
    if( Front != null )
    {
      return Front.DataStr;
    }

    return "";
  }

  $rect <880,200,1080,240>
  method string GetBack()
  {
    if( Back != null )
    {
      return Back.DataStr;
    }

    return "";
  }

  $rect <640,300,840,340>
  method bool IsEmpty()
  {
    if( Front == null || Back == null )
    {
      return true; // queue is empty
    }

    return false;
  }

  $rect <640,250,840,290>
  method void Clear()
  {
    while( Front != null )
    {
      Pop();
    }

    Size = 0;
  }

  $rect <640,100,840,140>
  inherited method Init()
  {
    Front = null;
    Back = null;
    Size = 0;
    Empty = true;
  }

  $rect <880,100,1080,140>
  method int32 GetSize()
  {
    while( Front != null )
    {
      Size++;
      Front = Front.Next;
    }

    return Size;
  }

  $rect <880,250,1080,290>
  method void Print()
  {
    var Application::SimpleStringElement aux = Front;

    while( aux != null )
    {
      trace aux.DataStr;
      aux = aux.Next;
    }

    aux = null;
  }

  $rect <124,80,324,120>
  property Application::SimpleStringElement Front;

  $rect <124,120,324,160>
  onset Front
  {
    // The value doesn't change - nothing to do.
    if ( pure Front == value )
      return;

    // Remember the property's new value.
    pure Front = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <124,160,324,200>
  onget Front
  {
    return pure Front;
  }

  $rect <120,220,320,260>
  property Application::SimpleStringElement Back;

  $rect <120,260,320,300>
  onset Back
  {
    // The value doesn't change - nothing to do.
    if ( pure Back == value )
      return;

    // Remember the property's new value.
    pure Back = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <120,300,320,340>
  onget Back
  {
    return pure Back;
  }

  $rect <370,80,570,120>
  property int32 Size;

  $rect <370,120,570,160>
  onset Size
  {
    // The value doesn't change - nothing to do.
    if ( pure Size == value )
      return;

    // Remember the property's new value.
    pure Size = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <370,160,570,200>
  onget Size
  {
    return pure Size;
  }

  $rect <370,220,570,260>
  property bool Empty;

  $rect <370,260,570,300>
  onset Empty
  {
    // The value doesn't change - nothing to do.
    if ( pure Empty == value )
      return;

    // Remember the property's new value.
    pure Empty = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <370,300,570,340>
  onget Empty
  {
    return pure Empty;
  }

  // Properties
  note group Note
  {
    attr Bounds = <100,40,590,360>;
  }

  // Methods
  note group Note1
  {
    attr Bounds = <620,40,1110,360>;
  }

  // Directives to adapt the order of members belonging to this class so they appear 
  // correctly arranged relative to the members inherited from the ancestor (super) 
  // classes. The numbers indicate the order-displacement to apply on the respective 
  // member once all members have been loaded and combined with members from the 
  // ancestor classes.
  $reorder Push 3
  $reorder Pop 3
  $reorder GetFront 1
  $reorder GetBack 1
  $reorder IsEmpty 1
  $reorder Clear 1
}

$rect <-30,130,170,170>
$output false
class StrStack
{
  $rect <600,90,800,130>
  inherited method Init()
  {
    Top = null;
    Size = 0;
    Empty = true;
  }

  $rect <60,70,260,110>
  property Application::SimpleStringElement Top;

  $rect <60,110,260,150>
  onset Top
  {
    // The value doesn't change - nothing to do.
    if ( pure Top == value )
      return;

    // Remember the property's new value.
    pure Top = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <60,150,260,190>
  onget Top
  {
    return pure Top;
  }

  $rect <60,200,260,240>
  property int32 Size;

  $rect <60,240,260,280>
  onset Size
  {
    // The value doesn't change - nothing to do.
    if ( pure Size == value )
      return;

    // Remember the property's new value.
    pure Size = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <60,280,260,320>
  onget Size
  {
    return pure Size;
  }

  $rect <290,70,490,110>
  property bool Empty;

  $rect <290,110,490,150>
  onset Empty
  {
    // The value doesn't change - nothing to do.
    if ( pure Empty == value )
      return;

    // Remember the property's new value.
    pure Empty = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <290,150,490,190>
  onget Empty
  {
    return pure Empty;
  }

  $rect <600,140,800,180>
  method void Push( arg string aValue )
  {
    var Application::SimpleStringElement strElement = new Application::SimpleStringElement;
    strElement.DataStr = aValue;
    strElement.Next = Top;
    Top = strElement;
  }

  $rect <600,190,800,230>
  method void Pop()
  {
    var Application::SimpleStringElement aux = Top;

    if( aux == null )
    {
      trace "Stack is empty!";
    }
    else 
    {
       aux = Top;
       Top = Top.Next;
       aux = null;
    }
  }

  $rect <830,140,1030,180>
  method string GetTop()
  {
    if( Top != null ) 
    {
      return Top.DataStr;
    }

    return "";
  }

  $rect <830,90,1030,130>
  method bool IsEmpty()
  {
    if( Top == null )
    {
      return true; // Stack is empty
    }

    return false;
  }

  $rect <830,190,1030,230>
  method int32 GetSize()
  {
    while( Top != null )
    {
      Size++;
      Top = Top.Next;
    }

    return Size;
  }

  $rect <600,240,800,280>
  method void Clear()
  {
    while( Top != null )
    {
      Pop();
    }

    Size = 0;
  }

  $rect <830,240,1030,280>
  method void Print()
  {
    var Application::SimpleStringElement aux = Top;

    while( aux != null )
    {
      trace aux.DataStr;
      aux = aux.Next;
    }

    aux = null;
  }

  // Properties
  note group Note
  {
    attr Bounds = <30,20,520,340>;
  }

  // Methods
  note group Note1
  {
    attr Bounds = <560,20,1050,340>;
  }
}

$rect <200,180,400,220>
$output false
class SimpleFloatElement
{
  $rect <141,53,341,93>
  property float DataFloat;

  $rect <141,93,341,133>
  onset DataFloat
  {
    // The value doesn't change - nothing to do.
    if ( pure DataFloat == value )
      return;

    // Remember the property's new value.
    pure DataFloat = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <141,133,341,173>
  onget DataFloat
  {
    return pure DataFloat;
  }

  $rect <380,50,580,90>
  property Application::SimpleFloatElement Next;

  $rect <380,90,580,130>
  onset Next
  {
    // The value doesn't change - nothing to do.
    if ( pure Next == value )
      return;

    // Remember the property's new value.
    pure Next = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <380,130,580,170>
  onget Next
  {
    return pure Next;
  }
}

$rect <-30,180,170,220>
$output false
class FloatStack
{
  $rect <590,90,790,130>
  inherited method Init()
  {
    Top = null;
    Size = 0;
    Empty = true;
  }

  $rect <70,60,270,100>
  property Application::SimpleFloatElement Top;

  $rect <70,100,270,140>
  onset Top
  {
    // The value doesn't change - nothing to do.
    if ( pure Top == value )
      return;

    // Remember the property's new value.
    pure Top = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <70,140,270,180>
  onget Top
  {
    return pure Top;
  }

  $rect <70,200,270,240>
  property int32 Size;

  $rect <70,240,270,280>
  onset Size
  {
    // The value doesn't change - nothing to do.
    if ( pure Size == value )
      return;

    // Remember the property's new value.
    pure Size = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <70,280,270,320>
  onget Size
  {
    return pure Size;
  }

  $rect <310,60,510,100>
  property bool Empty;

  $rect <310,100,510,140>
  onset Empty
  {
    // The value doesn't change - nothing to do.
    if ( pure Empty == value )
      return;

    // Remember the property's new value.
    pure Empty = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <310,140,510,180>
  onget Empty
  {
    return pure Empty;
  }

  $rect <590,140,790,180>
  method void Push( arg float aValue )
  {
    var Application::SimpleFloatElement floatElement = new Application::SimpleFloatElement;
    floatElement.DataFloat = aValue;
    floatElement.Next = Top;
    Top = floatElement;
  }

  $rect <590,190,790,230>
  method void Pop()
  {
    var Application::SimpleFloatElement aux = Top;

    if( aux == null )
    {
      trace "Stack is empty!";
    }
    else 
    {
       aux = Top;
       Top = Top.Next;
       aux = null;
    }
  }

  $rect <830,190,1030,230>
  method float GetTop()
  {
    if( Top != null ) 
    {
      return Top.DataFloat;
    }

    return 0;
  }

  $rect <830,90,1030,130>
  method bool IsEmpty()
  {
    if( Top == null )
    {
      return true; // Stack is empty
    }

    return false;
  }

  $rect <830,140,1030,180>
  method int32 GetSize()
  {
    while( Top != null )
    {
      Size++;
      Top = Top.Next;
    }

    return Size;
  }

  $rect <590,240,790,280>
  method void Clear()
  {
    while( Top != null )
    {
      Pop();
    }

    Size = 0;
  }

  $rect <830,240,1030,280>
  method void Print()
  {
    var Application::SimpleFloatElement aux = Top;

    while( aux != null )
    {
      trace aux.DataFloat;
      aux = aux.Next;
    }

    aux = null;
  }

  // Properties
  note group Note
  {
    attr Bounds = <40,20,530,340>;
  }

  // Methods
  note group Note1
  {
    attr Bounds = <560,20,1050,340>;
  }
}

$rect <200,30,400,70>
$output false
class StringElement
{
  $rect <130,114,330,154>
  property string DataStr;

  $rect <130,154,330,194>
  onset DataStr
  {
    // The value doesn't change - nothing to do.
    if ( pure DataStr == value )
      return;

    // Remember the property's new value.
    pure DataStr = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <130,194,330,234>
  onget DataStr
  {
    return pure DataStr;
  }

  $rect <380,110,580,150>
  property Application::StringElement Next;

  $rect <380,150,580,190>
  onset Next
  {
    // The value doesn't change - nothing to do.
    if ( pure Next == value )
      return;

    // Remember the property's new value.
    pure Next = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <380,190,580,230>
  onget Next
  {
    return pure Next;
  }

  $rect <630,110,830,150>
  property Application::StringElement Prev;

  $rect <630,150,830,190>
  onset Prev
  {
    // The value doesn't change - nothing to do.
    if ( pure Prev == value )
      return;

    // Remember the property's new value.
    pure Prev = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <630,190,830,230>
  onget Prev
  {
    return pure Prev;
  }
}

$rect <-30,30,170,70>
$output false
class StrVector
{
  $rect <640,30,840,70>
  inherited method Init()
  {
    Front = null;
    Back = null;
    Size = 0;
    Empty = true;
  }

  $rect <130,20,330,60>
  property Application::StringElement Front;

  $rect <130,60,330,100>
  onset Front
  {
    // The value doesn't change - nothing to do.
    if ( pure Front == value )
      return;

    // Remember the property's new value.
    pure Front = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <130,100,330,140>
  onget Front
  {
    return pure Front;
  }

  $rect <130,160,330,200>
  property Application::StringElement Back;

  $rect <130,200,330,240>
  onset Back
  {
    // The value doesn't change - nothing to do.
    if ( pure Back == value )
      return;

    // Remember the property's new value.
    pure Back = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <130,240,330,280>
  onget Back
  {
    return pure Back;
  }

  $rect <360,20,560,60>
  property int32 Size;

  $rect <360,60,560,100>
  onset Size
  {
    // The value doesn't change - nothing to do.
    if ( pure Size == value )
      return;

    // Remember the property's new value.
    pure Size = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <360,100,560,140>
  onget Size
  {
    return pure Size;
  }

  $rect <360,160,560,200>
  property bool Empty;

  $rect <360,200,560,240>
  onset Empty
  {
    // The value doesn't change - nothing to do.
    if ( pure Empty == value )
      return;

    // Remember the property's new value.
    pure Empty = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <360,240,560,280>
  onget Empty
  {
    return pure Empty;
  }

  $rect <640,80,840,120>
  method void PushBack( arg string aValue )
  {
    var Application::StringElement strElement = new Application::StringElement;
    strElement.DataStr = aValue;
    strElement.Next = null;
    strElement.Prev = Back;

    if( Back != null )
    {
      Back.Next = strElement;
    }
    else
    {
      Front = strElement;
    }
    Back = strElement;
  }

  $rect <640,130,840,170>
  method void Pop()
  {
    if( Back != null ) 
    {
      Back = Back.Prev;
      Back.Next = null;
    }
    else
    {
      Back = null;
    }
  }

  $rect <640,180,840,220>
  method string At( arg int32 pos )
  {
    var int32 index = 0;
    var Application::StringElement aux = Front;

    while( aux != null && index != pos)
    {
      aux = aux.Next;
      index++;
    }

    return aux.DataStr;
  }

  $rect <880,30,1080,70>
  method bool IsEmpty()
  {
    if( Front == null || Back == null )
    {
      return true; // vectir is empty
    }

    return false;
  }

  $rect <880,180,1080,220>
  method int32 GetSize()
  {
    var Application::StringElement aux = Front;

    while( aux != null )
    {
      Size++;
      aux = aux.Next;
    }

    return Size;

  }

  $rect <640,230,840,270>
  method void Clear()
  {
    while( Front != Back )
    {
      Pop();
    }
    Front = null;
  }

  $rect <880,230,1080,270>
  method void Print()
  {
    var Application::StringElement aux = Front;

    while( aux != null )
    {
      trace aux.DataStr;
      aux = aux.Next;
    }

    aux = null;
  }

  $rect <880,80,1080,120>
  method string GetFront()
  {
    if( Front != null )
    {
      return Front.DataStr;
    }

    return "";
  }

  $rect <880,130,1080,170>
  method string GetBack()
  {
    if( Back != null )
    {
      return Back.DataStr;
    }

    return "";
  }

  // Properties
  note group Note
  {
    attr Bounds = <110,-20,580,300>;
  }

  // Methods
  note group Note1
  {
    attr Bounds = <610,-20,1100,300>;
  }
}

$rect <-30,230,170,270>
$output false
class CharStack
{
  $rect <590,100,790,140>
  inherited method Init()
  {
    Top = null;
    Size = 0;
    Empty = true;
  }

  $rect <60,60,260,100>
  property Application::SimpleCharElement Top;

  $rect <60,100,260,140>
  onset Top
  {
    // The value doesn't change - nothing to do.
    if ( pure Top == value )
      return;

    // Remember the property's new value.
    pure Top = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <60,140,260,180>
  onget Top
  {
    return pure Top;
  }

  $rect <60,200,260,240>
  property int32 Size;

  $rect <60,240,260,280>
  onset Size
  {
    // The value doesn't change - nothing to do.
    if ( pure Size == value )
      return;

    // Remember the property's new value.
    pure Size = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <60,280,260,320>
  onget Size
  {
    return pure Size;
  }

  $rect <300,60,500,100>
  property bool Empty;

  $rect <300,100,500,140>
  onset Empty
  {
    // The value doesn't change - nothing to do.
    if ( pure Empty == value )
      return;

    // Remember the property's new value.
    pure Empty = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <300,140,500,180>
  onget Empty
  {
    return pure Empty;
  }

  $rect <590,150,790,190>
  method void Push( arg char aValue )
  {
    var Application::SimpleCharElement charElement = new Application::SimpleCharElement;
    charElement.DataChar = aValue;
    charElement.Next = Top;
    Top = charElement;
  }

  $rect <590,200,790,240>
  method void Pop()
  {
    var Application::SimpleCharElement aux = Top;

    if( aux == null )
    {
      trace "Stack is empty!";
    }
    else 
    {
       aux = Top;
       Top = Top.Next;
       aux = null;
    }
  }

  $rect <830,150,1030,190>
  method char GetTop()
  {
    if( Top != null ) 
    {
      return Top.DataChar;
    }

    return 0;
  }

  $rect <830,100,1030,140>
  method bool IsEmpty()
  {
    if( Top == null )
    {
      return true; // Stack is empty
    }

    return false;
  }

  $rect <830,200,1030,240>
  method int32 GetSize()
  {
    while( Top != null )
    {
      Size++;
      Top = Top.Next;
    }

    return Size;
  }

  $rect <590,250,790,290>
  method void Clear()
  {
    while( Top != null )
    {
      Pop();
    }

    Size = 0;
  }

  $rect <830,250,1030,290>
  method void Print()
  {
    var Application::SimpleCharElement aux = Top;

    while( aux != null )
    {
      trace aux.DataChar;
      aux = aux.Next;
    }

    aux = null;
  }

  // Methods
  note group Note1
  {
    attr Bounds = <560,20,1050,340>;
  }

  // Properties
  note group Note
  {
    attr Bounds = <30,20,520,340>;
  }
}

$rect <200,80,400,120>
$output false
class SimpleCharElement
{
  $rect <141,53,341,93>
  property char DataChar;

  $rect <141,93,341,133>
  onset DataChar
  {
    // The value doesn't change - nothing to do.
    if ( pure DataChar == value )
      return;

    // Remember the property's new value.
    pure DataChar = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <141,133,341,173>
  onget DataChar
  {
    return pure DataChar;
  }

  $rect <380,50,580,90>
  property Application::SimpleCharElement Next;

  $rect <380,90,580,130>
  onset Next
  {
    // The value doesn't change - nothing to do.
    if ( pure Next == value )
      return;

    // Remember the property's new value.
    pure Next = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <380,130,580,170>
  onget Next
  {
    return pure Next;
  }
}

// Data Structures
note group Note4
{
  attr Bounds = <-60,-20,420,290>;
}

$rect <460,220,660,260>
$output false
resource Resources::Font BatteryFont
{
  attr fontname FontName = Digital-7;
  attr fontheight Height = 42;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <193,490,393,530>
$output false
resource Resources::Bitmap LowBattery
{
  attr bitmapfile FileName = .\resources\low-battery.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <5,46>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <-300,390,-100,430>
$output false
class ChangeBattery : Core::Group
{
  $rect <160,0,360,40>
  inherited property Bounds = <0,0,130,65>;

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,130,65>;
    preset Radius = 3;
    preset Color = #476984FF;
  }

  $rect <190,90,390,130>
  property int32 NewBatteryLvl;

  $rect <190,140,390,180>
  onget NewBatteryLvl
  {
    // Per default return the value stored already in the property.
    return pure NewBatteryLvl;

    /*

      TO DO:

      If the property should return the value stored in the underlying device
      or in the middleware, remove the above 'return' statement and instead do
      following:

      Declare a local variable to receive the value from the underlying device.
      The type of the variable has to correspond to the data type of the property.
      For example in case of an 'int32' property:
      
        var int32 result;

      Implement a native statement to access the value and to store it in the
      variable 'result'. Then return the value. For example:

        $if !$prototyper
          native ( result )
          {
            result = YourDevice_GetSomeValue();
          }
        $endif

        return result;

    */
  }

  $rect <-10,140,190,180>
  onset NewBatteryLvl
  {
    // The property doesn't change -> nothing to do.
    if ( pure NewBatteryLvl == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure NewBatteryLvl = value;

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^NewBatteryLvl;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <-10,90,190,130>
  $output true
  method void UpdateProperty( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure NewBatteryLvl )
    {
      // Remember the new value in the internal memory of the property.
      pure NewBatteryLvl = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^NewBatteryLvl;
    }
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalSlider HorizontalSlider
  {
    preset Bounds = <6,29,126,64>;
    preset OnChange = onChangeSlider;
    preset OnEnd = onEndSlider;
    preset Outlet = ^NewBatteryLvl;
    preset MinValue = 20;
    preset Appearance = HorizontalSliderConfig;
  }

  $rect <440,30,680,70>
  object WidgetSet::HorizontalSliderConfig HorizontalSliderConfig
  {
    preset ThumbFrameActive = 0;
    preset ThumbFrameFocused = 0;
    preset ThumbFrameDisabled = 0;
    preset ThumbFrameDefault = 1;
    preset ThumbBitmapActive = Application::EnergySymbol;
    preset ThumbBitmapFocused = Application::EnergySymbol;
    preset ThumbBitmapDisabled = Application::EnergySymbol;
    preset ThumbBitmapDefault = Application::EnergySymbol;
    preset TrackRightBitmapActive = Application::SliderBack;
    preset TrackRightBitmapFocused = Application::SliderBack;
    preset TrackRightBitmapDefault = Application::SliderBack;
    preset TrackLeftBitmapActive = Application::SliderFront;
    preset TrackLeftBitmapFocused = Application::SliderFront;
    preset TrackLeftBitmapDefault = Application::SliderFront;
  }

  $rect <460,130,660,170>
  slot onEndSlider
  {
    this.Enabled = false;
    this.Bounds.x = -270;
    this.Visible = true;

  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <10,2,120,32>;
    preset String = "add new battery..";
    preset Font = Application::ChangeFont;
  }

  $rect <460,80,660,120>
  slot onChangeSlider
  {
    this.Text.String = NewBatteryLvl;
  }

  // Slider Config
  note group Note
  {
    attr Bounds = <430,-10,690,190>;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Bounds = <0,0,130,65>;
    preset Radius = 3;
    preset Width = 2;
    preset Color = #050B25FF;
  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Bounds
  $member Rectangle
  $member Border
  $member NewBatteryLvl
  $member OnGetNewBatteryLvl
  $member OnSetNewBatteryLvl
  $member UpdateProperty
  $member HorizontalSlider
  $member HorizontalSliderConfig
  $member onEndSlider
  $member Text
  $member onChangeSlider
  $member Note
}

$rect <460,420,660,460>
$output false
resource Resources::Font ChangeFont
{
  attr fontname FontName = Bahnschrift SemiCondensed;
  attr fontheight Height = 16;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <190,540,390,580>
$output false
resource Resources::Bitmap EnergySymbol
{
  attr bitmapfile FileName = .\resources\battery-symbol.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <30,30>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <190,590,390,630>
$output false
resource Resources::Bitmap SliderFront
{
  attr bitmapfile FileName = .\resources\slider-front.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <120,20>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <190,640,390,680>
$output false
resource Resources::Bitmap SliderBack
{
  attr bitmapfile FileName = .\resources\slider-back.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <120,20>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <-300,20,-100,60>
$output false
class Home : Core::Root
{
  $rect <650,120,850,160>
  inherited property Bounds = <0,0,340,600>;

  $rect <20,20,160,60>
  object Views::Rectangle Bgk
  {
    preset Bounds = <0,0,340,600>;
    preset Color = #E2E6E9FF;
  }

  $rect <20,20,160,60>
  object Application::Application StandardPg
  {
    preset Bounds = <0,0,340,600>;
  }

  $rect <20,20,160,60>
  object Application::ConverterPage ConverterPg
  {
    preset Bounds = <0,0,340,600>;
    preset Enabled = true;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Application::SelectionMenu MenuView
  {
    preset StackingPriority = 2;
    preset Bounds = <0,0,340,600>;
    preset Enabled = false;
    preset Visible = false;
  }

  $rect <410,70,610,110>
  slot OpenConverter
  {
    GetRoot().DismissDialog( MenuView, Effects::SlideLeftCentered, null, null, null, null, null );
    this.PushButton.IconFrame = 1;
    if( CurrentPage == "Standard" )
      GetRoot().DismissDialog( StandardPg, null, null, null, null, null, null );
    GetRoot().PresentDialog( ConverterPg, null, null, null, null, null, null, null, null, null );
    CurrentPage = "Converter";
  }

  $rect <650,70,850,110>
  inherited method Init()
  {
    GetRoot().PresentDialog( StandardPg, null, null, null, null, null, null, null, null, null );
    MenuView.ConverterBtn.OnActivate = this.OpenConverter;
    MenuView.StandardBtn.OnActivate = this.OpenStandardPage;
    this.PushButton.StackingPriority = 3;
    this.PushButton.IconFrame = 1;
  }

  $rect <650,170,890,210>
  object WidgetSet::PushButtonConfig PushButtonConfig
  {
    preset FaceFrameActive = 0;
    preset FaceFrameFocused = 0;
    preset FaceFrameDisabled = 1;
    preset FaceFrameDefault = 1;
    preset FaceBitmapActive = Application::ToggleMenu;
    preset FaceBitmapFocused = Application::ToggleMenu;
    preset FaceBitmapDisabled = Application::ToggleMenu;
    preset FaceBitmapDefault = Application::ToggleMenu;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset StackingPriority = 0;
    preset Bounds = <8,10,38,44>;
    preset OnPress = null;
    preset OnActivate = TogglePages;
    preset Label = "Caption";
    preset Appearance = PushButtonConfig;
  }

  $rect <410,120,610,160>
  slot OpenStandardPage
  {
    GetRoot().DismissDialog( MenuView, Effects::SlideLeftCentered, null, null, null, null, null );
    this.PushButton.IconFrame = 1;
    if( CurrentPage == "Converter" )
      GetRoot().DismissDialog( ConverterPg, null, null, null, null, null, null );
    GetRoot().PresentDialog( StandardPg, null, null, null, null, null, null, null, null, null );
    CurrentPage = "Standard";
  }

  $rect <410,170,610,210>
  slot TogglePages
  {
    GetRoot().PresentDialog( MenuView, Effects::SlideRightCentered, null, null, null, null, null, null, null, null );
    this.PushButton.IconFrame = 0;
  }

  // Handle Pages
  note group Note
  {
    attr Bounds = <390,20,630,280>;
  }

  $rect <410,220,610,260>
  var string CurrentPage = "Standard";

  $rect <20,20,160,60>
  object Application::ErrorDialog ErrorDialog
  {
    preset StackingPriority = 3;
    preset Bounds = <-270,238,-20,338>;
  }

  $rect <410,350,610,390>
  object Core::PropertyObserver ObserveCalcError
  {
    preset OnEvent = onIncorrectExpr;
    preset Outlet = ^StandardPg.CorrectInput;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver' \
  // is notified.
  $rect <610,350,810,390>
  slot onIncorrectExpr
  {
    if( StandardPg.CorrectInput == false )
    {
      signal onOpenErrorDialog;
      ErrorDialog.ErrorText.String = StandardPg.ErrorTxt;
    }
  }

  $rect <410,400,610,440>
  object Core::PropertyObserver ObserveConverterErr
  {
    preset OnEvent = onErrorSignaled;
    preset Outlet = ^ConverterPg.CorrectInput;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver1' \
  // is notified.
  $rect <610,400,810,440>
  slot onErrorSignaled
  {
    if( ConverterPg.CorrectInput == false )
    {
      signal onOpenErrorDialog;
      ErrorDialog.ErrorText.String = "Expression contains characters that are not allowed.";
    }
  }

  $rect <410,450,610,490>
  slot onOpenErrorDialog
  {
    Int32Effect.Enabled = true;
    ErrorDialog.Visible = true;
    ErrorDialog.Bounds.x = 45;
    ErrorDialog.OnCloseDialog = onDialogHandled;
  }

  $rect <650,220,850,260>
  object Effects::Int32Effect Int32Effect
  {
    preset NoOfCycles = 3;
    preset CycleDuration = 400;
    preset InterCycleDelay = 0;
    preset Enabled = true;
    preset Value1 = 155;
    preset Outlet = ^ErrorDialog.Opacity;
  }

  $rect <620,450,820,490>
  slot onDialogHandled
  {
    ErrorDialog.Bounds.x = -270;
    ErrorDialog.Visible = false;
  }

  $rect <410,500,610,540>
  object Core::PropertyObserver ObserveBatteryLevel
  {
    preset OnEvent = onBatteryChanged;
    preset Outlet = ^StandardPg.BatteryLvl;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver' \
  // is notified.
  $rect <610,500,810,540>
  slot onBatteryChanged
  {
    if( StandardPg.BatteryLvl == 0 )
    {
      this.ConverterPg.KeyHandler.Enabled = false;
      this.ConverterPg.ComboBoxOne.Enabled = false;
      this.ConverterPg.ComboBoxTwo.Enabled = false;
    }
    else
    {
      this.ConverterPg.KeyHandler.Enabled = true;
      this.ConverterPg.ComboBoxOne.Enabled = true;
      this.ConverterPg.ComboBoxTwo.Enabled = true;
    }
  }

  // Handle Error & Battery Dialog
  note group Note1
  {
    attr Bounds = <390,300,840,560>;
  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Init
  $member Bounds
  $member Bgk
  $member StandardPg
  $member ConverterPg
  $member MenuView
  $member OpenConverter
  $member PushButtonConfig
  $member PushButton
  $member OpenStandardPage
  $member TogglePages
  $member Note
  $member CurrentPage
  $member ErrorDialog
  $member ObserveCalcError
  $member onIncorrectExpr
  $member ObserveConverterErr
  $member onErrorSignaled
  $member onOpenErrorDialog
  $member Int32Effect
  $member onDialogHandled
  $member ObserveBatteryLevel
  $member onBatteryChanged
  $member Note1
}

$rect <-300,190,-100,230>
$output false
class ConverterPage : Core::Group
{
  $rect <660,470,860,510>
  inherited property Bounds = <0,0,340,600>;

  $rect <410,30,610,70>
  inherited method Init()
  {
    this.Keypad.Border.Visible = false;
    this.Keypad.OpenParanthesis.Enabled = false;
    this.Keypad.OpenParanthesis.Visible = false;
    this.Keypad.ClosedParanthesis.Enabled = false;
    this.Keypad.ClosedParanthesis.Visible = false;
    this.Keypad.Divide.Enabled = false;
    this.Keypad.Divide.Visible = false;
    this.Keypad.Multiply.Enabled = false;
    this.Keypad.Multiply.Visible = false;
    this.Keypad.Plus.Enabled = false;
    this.Keypad.Plus.Visible = false;
    this.Keypad.Minus.Enabled = false;
    this.Keypad.Minus.Visible = false;
    this.Keypad.Percentage.Enabled = false;
    this.Keypad.Percentage.Visible = false;
    this.Keypad.Minus.Enabled = false;
    this.Keypad.Minus.Visible = false;
    this.Keypad.Power.Enabled = false;
    this.Keypad.Power.Visible = false;
    this.Keypad.Equals.Bounds.w = 72;
    this.Keypad.BackBtn.Bounds.x = 221;
    this.Keypad.BackBtn.Bounds.y = 150;
    this.Keypad.Clear.Bounds.x = 221;
    this.Keypad.Clear.Bounds.y = 220;
    this.Keypad.Enabled = true;
  }

  $rect <20,20,160,60>
  object Application::ComboBox ComboBoxOne
  {
    preset Bounds = <40,104,290,144>;
    preset OnSelect = OnSelectFirstMetric;
    preset OnLoadItem = OnLoadItemsOne;
    preset NoOfItems = 4;
  }

  $rect <410,80,610,120>
  slot OnLoadItemsOne
  {
    var string name;

    // Which item should be loaded?
    switch ( ComboBoxOne.View.Item )
    {
      case  0 : name = "Milimeters";
      case  1 : name = "Centimeters";
      case  2 : name = "Meters";
      case  3 : name = "Kilometers";
      default : name = "Meters";
    }

    // Initialize the item
    ComboBoxOne.View.String = name;
  }

  $rect <20,20,160,60>
  object Application::ComboBox ComboBoxTwo
  {
    preset Bounds = <42,215,292,255>;
    preset OnSelect = OnSelectSecondMetric;
    preset OnLoadItem = OnLoadItemsTwo;
    preset NoOfItems = 4;
  }

  $rect <410,130,610,170>
  slot OnLoadItemsTwo
  {
    var string name;

    // Which item should be loaded?
    switch ( ComboBoxTwo.View.Item )
    {
      case  0 : name = "Milimeters";
      case  1 : name = "Centimeters";
      case  2 : name = "Meters";
      case  3 : name = "Kilometers";
      default : name = "Meters";
    }

    // Initialize the item
    ComboBoxTwo.View.String = name;
  }

  $rect <20,20,160,60>
  object Views::Text ValueOne
  {
    preset Bounds = <44,48,284,98>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "0";
    preset Font = Application::DigitalResFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text ValueTwo
  {
    preset Bounds = <49,159,284,209>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "0";
    preset Font = Application::DigitalResFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Application::NumKeyBtns Keypad
  {
    preset StackingPriority = 0;
    preset Bounds = <19,148,319,588>;
  }

  $rect <410,240,610,280>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onConvertValue;
    preset OnHold = null;
  }

  $rect <410,290,610,330>
  slot onConvertValue
  {
    var string str = "";
    var string temp = "";
    var int32 cursorPosition = ValueOne.String.length - 1; 

    if( KeyHandler.CharCode != '\0' )
    {  
      str = KeyHandler.CharCode;
    }
    else
    {
      str = Keypad.keyString;
    }

    if( str == "C" || str == "c" || ( ValueOne.String == "0" && str != ".") )
    {
      ValueOne.String = "";
      ValueTwo.String = "";
    }

    if(KeyHandler.Code == Core::KeyCode.Left)
    {
      if (cursorPosition > 0)
      {    
        cursorPosition--; 
      }
    }

    if( KeyHandler.Code == Core::KeyCode.Right )
    {
      if (cursorPosition < ValueOne.String.length)
      {
        
        cursorPosition++; 
      }
    }

    if ( str != "=" &&  str != "C" && str != "c")
    {
        if( str == "B" || str == "b" || KeyHandler.Code == Core::KeyCode.Delete )
        {
            temp = ValueOne.String.remove(ValueOne.String.length - 1, 1);
        }
        else
        {
            temp = ValueOne.String + str;
        }
        ValueOne.String = temp;
        cursorPosition++;
    }

    if (str == "=" )
    {
      if( CharactersAllowed(ValueOne.String) )
      {
        ValueTwo.String = ConvertValue(ValueOne.String, FirstMetric, SecondMetric);  
        CorrectInput = true;
      }
      else
      {
        CorrectInput = false;
      }
    }


  }

  $rect <410,340,610,380>
  method string ConvertValue( arg string val, arg string initialMetric, arg string newMetric )
  {
    var string newVal = "";

    if( initialMetric == "0" )
    {
        newVal = ConvertMilimeters(val, newMetric);
    }
    else if( initialMetric == "1" )
    {
        newVal = ConvertCentimeters(val, newMetric);
    }
    else if( initialMetric == "2" )
    {
        newVal = ConvertMeters(val, newMetric);
    }
    else if( initialMetric == "3" )
    {
        newVal = ConvertKilometers(val, newMetric);
    }

    return newVal;
  }

  $rect <680,30,880,70>
  slot OnSelectFirstMetric
  {
    FirstMetric = string( ComboBoxOne.SelectedItem );
  }

  $rect <680,80,880,120>
  slot OnSelectSecondMetric
  {
    SecondMetric = string( ComboBoxTwo.SelectedItem );
  }

  // Initialization
  note group Note
  {
    attr Bounds = <390,-10,630,190>;
  }

  // Converter
  note group Note1
  {
    attr Bounds = <390,200,630,640>;
  }

  // Metrics
  note group Note2
  {
    attr Bounds = <660,-10,900,450>;
  }

  $rect <410,390,610,430>
  method string ConvertMilimeters( arg string initialValue, arg string newMetric )
  {
    var string newVal = "";
    var float initialVal = initialValue.parse_float( -1.0 );
    var float newValue = 0.0;

    if( newMetric == "0" )
    {
       newVal = initialValue;
    }
    else if( newMetric == "1")
    {
       newValue = initialVal / 10;
       newVal = newValue;
    }
    else if( newMetric == "2")
    {
       newValue = initialVal / 1000;
       newVal = newValue;
    }
    else if( newMetric == "3")
    {
       newValue = initialVal /  1000000;
       newVal = newValue;
    }

    return newVal;
  }

  $rect <410,440,610,480>
  method string ConvertCentimeters( arg string initialValue, arg string newMetric )
  {
    var string newVal = "";
    var float initialVal = initialValue.parse_float( -1.0 );
    var float newValue = 0.0;

    if( newMetric == "0" )
    {
       newVal = initialVal * 10;
       newVal = newValue;
    }
    else if( newMetric == "1")
    {
       newVal = initialValue;
    }
    else if( newMetric == "2")
    {
       newValue = initialVal / 100;
       newVal = newValue;
    }
    else if( newMetric == "3")
    {
       newValue = initialVal / 100000;
       newVal = newValue;
    }

    return newVal;
  }

  $rect <410,490,610,530>
  method string ConvertMeters( arg string initialValue, arg string newMetric )
  {
    var string newVal = "";
    var float initialVal = initialValue.parse_float( -1.0 );
    var float newValue = 0.0;
         
    if( newMetric == "0" )
    {
       newValue = initialVal * 1000;
       newVal = newValue;
    }
    else if( newMetric == "1")
    {
       newValue = initialVal * 100;
       newVal = newValue;
    }
    else if( newMetric == "2")
    {
       newVal = initialValue;
    }
    else if( newMetric == "3")
    {
       newValue = initialVal / 1000;
       newVal = newValue;
    }

    return newVal;
  }

  $rect <410,540,610,580>
  method string ConvertKilometers( arg string initialValue, arg string newMetric )
  {
    var string newVal = "";
    var float initialVal = initialValue.parse_float( -1.0 );
    var float newValue = 0.0;

    if( newMetric == "0" )
    {
       newValue = initialVal * 1000000;
       newVal = newValue;
    }
    else if( newMetric == "1")
    {
       newValue = initialVal * 100000;
       newVal = newValue;
    }
    else if( newMetric == "2")
    {
       newValue = initialVal * 1000;
       newVal = newValue;
    }
    else if( newMetric == "3")
    {
       newVal = initialValue;
    }

    return newVal;
  }

  $rect <680,140,880,180>
  property string FirstMetric = "2";

  $rect <680,180,880,220>
  onset FirstMetric
  {
    // The value doesn't change - nothing to do.
    if ( pure FirstMetric == value )
      return;

    // Remember the property's new value.
    pure FirstMetric = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <680,220,880,260>
  onget FirstMetric
  {
    return pure FirstMetric;
  }

  $rect <680,290,880,330>
  property string SecondMetric = "2";

  $rect <680,330,880,370>
  onset SecondMetric
  {
    // The value doesn't change - nothing to do.
    if ( pure SecondMetric == value )
      return;

    // Remember the property's new value.
    pure SecondMetric = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <680,370,880,410>
  onget SecondMetric
  {
    return pure SecondMetric;
  }

  $rect <20,20,160,60>
  object Application::ComboBox Outline
  {
    preset Bounds = <669,522,719,569>;
  }

  $rect <410,590,610,630>
  method bool CharactersAllowed( arg string expression )
  {
    var int32 i = 0;

    for( ; i < expression.length; i++ )
    {
      if ( !((expression[i] >= '0') && (expression[i] <= '9') || expression[i] == '.') )
        return false;
    }

    return true;
  }

  $rect <590,670,790,710>
  property bool CorrectInput = true;

  $rect <990,670,1190,710>
  onget CorrectInput
  {
    // Per default return the value stored already in the property.
    return pure CorrectInput;

    /*

      TO DO:

      If the property should return the value stored in the underlying device
      or in the middleware, remove the above 'return' statement and instead do
      following:

      Declare a local variable to receive the value from the underlying device.
      The type of the variable has to correspond to the data type of the property.
      For example in case of an 'int32' property:
      
        var int32 result;

      Implement a native statement to access the value and to store it in the
      variable 'result'. Then return the value. For example:

        $if !$prototyper
          native ( result )
          {
            result = YourDevice_GetSomeValue();
          }
        $endif

        return result;

    */
  }

  $rect <790,670,990,710>
  onset CorrectInput
  {
    // The property doesn't change -> nothing to do.
    if ( pure CorrectInput == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure CorrectInput = value;

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^CorrectInput;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <390,670,590,710>
  $output true
  method void UpdateProperty( arg bool aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure CorrectInput )
    {
      // Remember the new value in the internal memory of the property.
      pure CorrectInput = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^CorrectInput;
    }
  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Init
  $member Bounds
  $member Outline
  $member ComboBoxOne
  $member OnLoadItemsOne
  $member ComboBoxTwo
  $member OnLoadItemsTwo
  $member ValueOne
  $member ValueTwo
  $member Keypad
  $member KeyHandler
  $member onConvertValue
  $member ConvertValue
  $member OnSelectFirstMetric
  $member OnSelectSecondMetric
  $member Note
  $member Note1
  $member Note2
  $member ConvertMilimeters
  $member ConvertCentimeters
  $member ConvertMeters
  $member ConvertKilometers
  $member FirstMetric
  $member OnSetFirstMetric
  $member OnGetFirstMetric
  $member SecondMetric
  $member OnSetSecondMetric
  $member OnGetSecondMetric
  $member CharactersAllowed
  $member CorrectInput
  $member OnGetCorrectInput
  $member OnSetCorrectInput
  $member UpdateProperty
}

$rect <-40,690,160,730>
$output false
resource Resources::Bitmap ToggleMenu
{
  attr bitmapfile FileName = .\resources\toggle-menu.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <30,34>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <-300,440,-100,480>
$output false
class SelectionMenu : Core::Group
{
  $rect <410,10,610,50>
  inherited property Bounds = <0,0,340,600>;

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,160,600>;
    preset Color = #A6B0BCFF;
  }

  $rect <410,60,650,100>
  object WidgetSet::PushButtonConfig PushButtonConfig
  {
    preset FaceFrameActive = 1;
    preset FaceFrameFocused = 1;
    preset FaceFrameDisabled = 0;
    preset FaceFrameDefault = 0;
    preset FaceBitmapActive = Application::ConverterBtn;
    preset FaceBitmapFocused = Application::ConverterBtn;
    preset FaceBitmapDisabled = Application::ConverterBtn;
    preset FaceBitmapDefault = Application::ConverterBtn;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Separator
  {
    preset Bounds = <16,60,146,62>;
    preset Color = #444444FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton ConverterBtn
  {
    preset Bounds = <15,85,145,125>;
    preset Label = "Caption";
    preset Appearance = PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton ConverterBtn1
  {
    preset Bounds = <723,11,853,51>;
    preset Label = "Caption";
    preset Appearance = PushButtonConfig;
  }

  $rect <410,110,650,150>
  object WidgetSet::PushButtonConfig StandardBtnConfig
  {
    preset LabelFont = Application::BtnFont;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton StandardBtn
  {
    preset Bounds = <43,10,143,40>;
    preset Label = "Standard";
    preset Appearance = StandardBtnConfig;
  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Bounds
  $member ConverterBtn1
  $member Background
  $member PushButtonConfig
  $member Separator
  $member ConverterBtn
  $member StandardBtnConfig
  $member StandardBtn
}

$rect <190,690,390,730>
$output false
resource Resources::Bitmap ConverterBtn
{
  attr bitmapfile FileName = .\resources\converter-btn.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <130,40>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// This class implements the item component for the Application::ComboBox widget. \
// This class is used internally within Application::ComboBox widget and the associated \
// Application::ComboBoxList component. You will probably never need to directly \
// instantiate and control this item component.
$rect <460,640,660,680>
$output false
class ComboBoxItem : Templates::ListItem
{
  $rect <250,270,450,310>
  inherited property Bounds = <0,0,180,40>;

  $rect <710,160,910,200>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the Item
    //
    // isMarked  --> the item is selected within the corresponding list.
    // isFocused --> the user has navigated to the item. The item can
    //               receive keyboard events.
    // isPressed --> the user presses the item actively.
    //
    //
    var bool isMarked  = Marked;
    var bool isFocused = aState.contains( Core::ViewState[ Focused ]);
    var bool isPressed = TouchHandler.Down || FlashTimer.Enabled;

    /*

      TO DO:

      Depending on your Item design, you have surely added some new views
      to your component. In the below code you should update the properties
      of these views. For example, when your Item has two images to appear
      exclusively for pressed and not pressed state, following can be done:

        imagePressed.Visible  =  isPressed;
        imageReleased.Visible = !isPressed;

      Depending on the state of the Item, you can alternate any property 
      of your views. You can change their visibility, colors, opacity,
      bitmaps shown in image views, fonts used to render text, the position
      and the size of the view, ...
       
      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the Item
      (e.g. 'isPressed') with its preceding state (e.g. variable 'pressed').

      Assuming you have already added to your Item component a new effect
      member, named it 'pressedEffect' and configured it to animate e.g. the
      opacity of an image within the Item. Then following is sufficient to
      trigger the animation:

        if ( isPressed && !pressed )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isPressed && pressed )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */

    if ( isPressed )
    {
      Background.Color = #E2E6E9FF;
      Text.Color       = #FFFFFFFF;
    }

    else if ( isFocused && isMarked )
    {
      Background.Color = #E2E6E9FF;
      Text.Color       = #FFFFFFFF;
    }

    else if ( isFocused )
    {
      Background.Color = #E2E6E9FF;
      Text.Color       = #000000FF;
    }

    else if ( isMarked )
    {
      Background.Color = #E2E6E9FF;
      Text.Color       = #FFFFFFFF;
    }

    // Not marked nor selected.
    else
    {
      Background.Color = #FFFFFFFF;
      Text.Color       = #000000FF;
    }

    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.
    focused = isFocused;
    marked  = isMarked;
    pressed = isPressed;
  }

  // State management
  note group Note4
  {
    attr Bounds = <700,120,920,330>;
  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <470,120,690,250>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <240,120,460,250>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,120,230,250>;
  }

  // This variable stores the current state of the item.
  $rect <710,280,910,320>
  var bool pressed;

  // This variable stores the current state of the item.
  $rect <710,240,910,280>
  var bool focused;

  // This variable stores the current state of the item.
  $rect <710,200,910,240>
  var bool marked;

  // This timer object is used to flash the item when the user has tapped it very \
  // quickly or the item has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <480,160,680,200>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <250,160,450,200>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <480,200,680,240>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the item to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the item is activated.
    postsignal OnSelect;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <250,200,450,240>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the item via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Ignore repetitions of key events (e.g. when the user holds the key pressed)
    if ( KeyHandler.Repetition )
      return;

    // Pressing the key flashes the item for a short period. This is a kind of 
    // feedback effect. Request the item to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the item. This only updates the item to appear pressed or released.
  $rect <20,200,220,240>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the item or drags the finger inside/outside
    // the item's area request the item update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the item's area. This activates the item.
  $rect <20,160,220,200>
  slot onReleaseTouch
  {
    // Every time the user releases the item, request an update. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();

    // The user interaction has been passed over to the another touch handler
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the item for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The item can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal OnSelect;

    // The user has tapped the item very quickly. Defer the item activation
    // to give the user first a short visual feedback that the item has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  $rect <240,50,440,90>
  onset String
  {
    // The value doesn't change - nothing to do.
    if ( pure String == value )
      return;

    // Remember the property's new value.
    pure String = value;

    // ... and update the Text view.
    Text.String = value;
  }

  $rect <440,50,640,90>
  onset Marked
  {
    // The value doesn't change - nothing to do.
    if ( pure Marked == value )
      return;

    // Remember the property's new value.
    pure Marked = value;

    // Request the view to update its state
    InvalidateViewState();
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <6,6,171,36>;
    preset Radius = 7;
    preset Color = #E2E6E9FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <15,8,164,33>;
    preset Ellipsis = true;
    preset Alignment = Views::TextAlignment[AlignHorzAuto, AlignVertCenter];
    preset String = "Text";
    preset Font = Application::BtnFont;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,40>;
    preset Point3 = <180,40>;
    preset Point2 = <180,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  // The property 'OnSelect' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the item (selected the item). Thereupon the \
  // method's logic will be executed.
  $rect <640,50,840,90>
  property slot OnSelect = null;

  // The property 'Item' stores the number of the item within the ComboBox. The first \
  // item has the number 0. The second 1, and so far.
  $rect <640,10,840,50>
  property int32 Item = -1;

  // The property 'Marked' stores the state of the item. If this property is 'true', \
  // the item appears as selected.
  $rect <440,10,640,50>
  property bool Marked = false;

  // The property 'String' stores the text to display in the item.
  $rect <240,10,440,50>
  property string String = "Text";
}

// This class implements the list component for the Application::ComboBox widget. \
// When the user activates the ComboBox, the list component is shown displaying all \
// available options and permitting the user to select the desired option.
// The class Application::ComboBoxList is used internally within Application::ComboBox \
// widget. You will probably never need to directly instantiate and control this \
// list component.
$rect <460,590,660,630>
$output false
class ComboBoxList : Templates::List
{
  $rect <700,220,900,260>
  inherited method CursorHitTest()
  {
    // First perform the cursor-hit test as usual.
    var Core::CursorHit hit = super( aArea, aFinger, aStrikeCount, aDedicatedView, aStartView,
                                     aRetargetReason );

    // Now, has the user tapped outside the list component? This can cause the list to disappear.
    // Inform the ComboBox in such case.
    if ( !hit && !aDedicatedView && ( aArea & Bounds ).isempty )
      postsignal onCloseList;

    return hit;
  }

  $rect <10,270,210,310>
  inherited property Bounds = <0,0,200,200>;

  $rect <240,280,440,320>
  inherited method UpdateLayout()
  {
    super( aSize );

    // Just in the moment when the List appears or its size changes, 
    // ensure that there is no empty space in the list.
    VerticalList.AdjustList( null, null );

    // Then eventually scroll the list so the actually selected item
    // is fully visible.
    VerticalList.EnsureVisible( selectedItem, true, null, null );

    // The following operation additionally adjusts the scrolling so
    // the list snaps at the edge of the first visible item.
    var int32 firstVisibleItem = VerticalList.GetItemAtPosition( VerticalList.Bounds.origin );
    VerticalList.EnsureVisible( firstVisibleItem, true, null, null );
  }

  // Touch Handling
  note group Note4
  {
    attr Bounds = <690,170,910,280>;
  }

  // List functionality
  note group Note3
  {
    attr Bounds = <460,170,680,280>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <460,20,1080,160>;
  }

  // Initialization
  note group Note1
  {
    attr Bounds = <230,20,450,330>;
  }

  // This variable refers to a slot method in the ComboBox to invoke when the user \
  // has decided to close the List without making any selection.
  $rect <240,230,440,270>
  var slot onCloseList;

  // This variable refers to a slot method in the ComboBox to invoke when the user \
  // has made a selection within the List.
  $rect <240,190,440,230>
  var slot onSelectItem;

  // This variable refers to a slot method in the ComboBox the List component will \
  // invoke in order to load an item with its appropriate content. In such case the \
  // sender of the signal will refer the item in question.
  $rect <240,150,440,190>
  var slot onLoadItem;

  // This variable stores which item was selected just in the moment when the user \
  // has activated the ComboBox List. This item will consequently appear as selected \
  // within the List.
  $rect <240,110,440,150>
  var int32 selectedItem;

  // This internal slot method is called by the embedded 'VerticalList' in order \
  // to load a list item with its appropriate content. The invocation is relayed \
  // to the ComboBox.
  $rect <470,220,670,260>
  slot onLoadItemSlot
  {
    // Access the item view intended to be loaded now.
    var Application::ComboBoxItem view = (Application::ComboBoxItem)VerticalList.View;

    // Ensure, the item view is correctly connected with the ComboBox.
    view.OnSelect = onSelectItem;

    // Which number has the item and is the item the originally 'selected' one?
    view.Item   = VerticalList.Item;
    view.Marked = view.Item == selectedItem;

    // Also ensure that the item fills the list horizontally.
    view.Bounds.size = VerticalList.ViewSize;

    // Forward the signal to the ComboBox's OnLoadItem slot method. This method is then
    // responsible for the proper initialization of the item's content. Use the item 
    // view as 'sender' of the signal.
    signal onLoadItem, view;
  }

  // This internal slot method is called when the '@KeyEscapeHandler' is activated \
  // (when the user has pressed the key specified in the property 'Filter' of the \
  // key handler).
  $rect <870,100,1070,140>
  slot onKeyEscape
  {
    // The user has pressed the ESCAPE key. Inform the ComboBox about the close operation.
    postsignal onCloseList;
  }

  // This internal slot method is called when the '@KeyDownHandler' is activated \
  // (when the user has pressed the key specified in the property 'Filter' of the \
  // key handler).
  $rect <670,100,870,140>
  slot onKeyDown
  {
    // No more following items?
    if ( VerticalList.SelectedItem >= ( VerticalList.NoOfItems - 1 ))
      return;

    // Select the next following item and ensure it is visible.
    VerticalList.SelectedItem++;
    VerticalList.EnsureVisible( VerticalList.SelectedItem, true, null, null );
  }

  // This internal slot method is called when the '@KeyUpHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <470,100,670,140>
  slot onKeyUp
  {
    // No more preceding items
    if ( VerticalList.SelectedItem <= 0 )
      return;

    // Select the preceding item and ensure it is visible.
    VerticalList.SelectedItem--;
    VerticalList.EnsureVisible( VerticalList.SelectedItem, true, null, null );
  }

  // This key handler reacts to key ESCAPE events. When the user presses the key \
  // ESCAPE (specified in the property 'Filter' of the key handler), the handler \
  // is activated and the method '@onKeyEscape' is called.
  $rect <870,60,1070,100>
  object Core::KeyPressHandler KeyEscapeHandler
  {
    preset OnPress = onKeyEscape;
    preset Filter = Core::KeyCode.Escape;
  }

  // This key handler reacts to key DOWN events. When the user presses the key DOWN \
  // (specified in the property 'Filter' of the key handler), the handler is activated \
  // and the method '@onKeyDown' is called.
  $rect <670,60,870,100>
  object Core::KeyPressHandler KeyDownHandler
  {
    preset OnPress = onKeyDown;
    preset Filter = Core::KeyCode.Down;
    preset OnHold = onKeyDown;
  }

  // This key handler reacts to key UP events. When the user presses the key UP (specified \
  // in the property 'Filter' of the key handler), the handler is activated and the \
  // method '@onKeyUp' is called.
  $rect <470,60,670,100>
  object Core::KeyPressHandler KeyUpHandler
  {
    preset OnPress = onKeyUp;
    preset Filter = Core::KeyCode.Up;
    preset OnHold = onKeyUp;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,200,200>;
    preset Radius = 7;
    preset Color = #E2E6E9FF;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <5,5,195,195>;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <5,5,195,195>;
    preset OnLoadItem = onLoadItemSlot;
    preset SlideHandler = SlideTouchHandler;
    preset ItemClass = Application::ComboBoxItem;
  }

  // This method is called just in the moment when the user activates the ComboBox. \
  // Its task is to initialize the List component according to the parameters found \
  // in the ComboBox. It also calculates the optimal size/position for the list and \
  // connects the List to the ComboBox.
  $rect <240,60,440,100>
  method void Initialize( arg rect aComboBoxArea, arg point aScreenSize, arg int32 aNoOfItems, arg int32 aSelectedItem, arg slot aOnLoadItem, arg slot aOnSelectItem, arg slot aOnCloseList )
  {
    // Remember 'callbacks' the list should use to communicate with the ComboBox.
    onLoadItem   = aOnLoadItem;
    onSelectItem = aOnSelectItem;
    onCloseList  = aOnCloseList;

    // Initialize the list according to the passed parameters.
    VerticalList.NoOfItems    = aNoOfItems;
    VerticalList.SelectedItem = aSelectedItem;

    // Also remember which item was originally selected.
    selectedItem = aSelectedItem;

    // To get the item height, create temporarily a new instance of the associated 
    // item class and query its default size.
    VerticalList.ItemHeight = ((Core::RectView)new VerticalList.ItemClass ).Bounds.h;

    // Also the Slide Touch Handler should be configure to snap at item edges.
    SlideTouchHandler.SnapNext.y = VerticalList.ItemHeight;

    // Now estimate the width of the list. Usually, the width of the list should 
    // correspond to the width of the ComboBox. The list should also be aligned at
    // the left edge of the ComboBox.
    var int32 w = aComboBoxArea.w;
    var int32 x = aComboBoxArea.x1;

    // Now estimate the height of the list. Let's assume, the list is large enough
    // to display all items at once. The list should also appear just below the
    // ComboBox.
    var int32 h = VerticalList.NoOfItems * VerticalList.ItemHeight;
    var int32 y = aComboBoxArea.y2;

    // Ensure the list is not too large. Here, we limit the list to 1/3 of the entire
    // screen height.
    h = math_min( h, aScreenSize.y / 3 );

    // Adjust the height so that it is a multiple of the height of a single item.
    h -= h % VerticalList.ItemHeight;

    // Take in account the evtl. existing decorations or borders around the list, etc.
    h += Bounds.h - VerticalList.Bounds.h;

    // Now verify, whether there is sufficient space below the ComboBox to display
    // the list. If not, the list will appear above the ComboBox.
    if (( aScreenSize.y - aComboBoxArea.y2 ) < h )
      y = aComboBoxArea.y1 - h;

    // Adjust the size and position of the list.
    Bounds = rect( x, y, x + w, y + h );
  }
}

// This class implements a 'combo box' widget. When the user activates the box, an \
// associated Application::ComboBoxList component is shown displaying all available \
// options and permitting the user to select the desired option. Selecting the option \
// sends a signal to the slot method stored in the property @OnSelect.
// Alternatively the property @Outlet can refer to any other 'int32' property the \
// widget should remain synchronized with. When the user selects an option, the affected \
// property is automatically updated to reflect the number of the selected option. \
// On the other hand, when the referred property is modified by another one, the \
// ComboBox is automatically notified to remain in sync with the property.
// The total number of available ComboBox items (the number of options) is determined \
// by the property @NoOfItems. Which option is actually selected is controlled by \
// the property @SelectedItem.
// The items are loaded dynamically at the runtime. For this purpose a slot method \
// has to be implemented and assigned to the @OnLoadItem property. The ComboBox will \
// invoke the slot method automatically each time it needs an item to be loaded. \
// Within the slot method the implementation can access and initialize the affected \
// item by using the variable @View.
// In order to trigger the combo box to reload one or more items, invoke the method \
// @InvalidateItems(). The box will thereupon schedule the necessary loading steps \
// automatically.
$rect <460,540,660,580>
$output false
class ComboBox : Templates::ComboBox
{
  $rect <20,370,220,410>
  inherited property Bounds = <0,0,250,40>;

  $rect <710,230,910,270>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // If not yet existing - create and initialize the view representing
    // the actually selected item in the ComboBox. It is a single item view
    // similarly to the used within the associated list.
    if ( !previewItem )
    {
      // Create a new item view
      previewItem = new Application::ComboBoxItem;

      previewItem.Enabled = false;
      previewItem.Item    = SelectedItem;
      previewItem.Layout  = Core::Layout[ AlignToLeft, AlignToRight, AlignToTop,
                                          AlignToBottom, ResizeHorz ]; 

      // Load the item view with data corresponding to the actually selected
      // item.
      View = previewItem;
      signal OnLoadItem;
      View = null;

      // Query the default size of an item
      var point size = previewItem.Bounds.size;

      // Arrange the item view so that it fills the ComboBox area excepting
      // the arrow image on the right of the ComboBox. The height of the item
      // should not change.
      previewItem.Bounds = rect( 3, Bounds.h / 2 - size.y / 2, Image.Bounds.x1,
                                 Bounds.h / 2 + size.y / 2 );

      // Finally adding the view to the ComboBox makes it visible
      Add( previewItem, 0 );

      // Avoid that the view appears selected as selected views do within the
      // list.
      Focus = null;
    }

    // isEnabled  --> the box can react to user inputs.
    // isSelected --> the box can receive keyboard events.
    // isPressed  --> the box should appear pressed.
    // isOpened   --> the associated list is visible actually.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;
    var bool isOpened   = list != null;

    if ( !isEnabled )
    {
      Background1.Color   = #8493B1FF;
      Background2.Visible = false;
      Image.FrameNumber   = 1;
      Image.Color         = #AAAAAAFF;
      previewItem.Opacity = 128;
    }

    else if ( isOpened )
    {
      Background1.Color   = #8493B1FF;
      Background2.Visible = false;
      Image.FrameNumber   = 0;
      Image.Color         = #000000FF;
      previewItem.Opacity = 255;
    }

    else if ( isPressed )
    {
      Background1.Color   = #8493B1FF;
      Background2.Visible = true;
      Image.FrameNumber   = 1;
      Image.Color         = #FFFFFFFF;
      previewItem.Opacity = 255;
    }

    else if ( isSelected )
    {
      Background1.Color   = #8493B1FF;
      Background2.Visible = false;
      Image.FrameNumber   = 1;
      Image.Color         = #000000FF;
      previewItem.Opacity = 255;
    }

    // Enabled but not pressed nor selected.
    else
    {
      Background1.Color   = #8493B1FF;
      Background2.Visible = false;
      Image.FrameNumber   = 1;
      Image.Color         = #000000FF;
      previewItem.Opacity = 255;
    }

    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;
    opened   = isOpened;
  }

  // List Functionality
  note group Note6
  {
    attr Bounds = <930,190,1150,560>;
  }

  // Controller events
  note group Note5
  {
    attr Bounds = <240,330,460,420>;
  }

  // State management
  note group Note4
  {
    attr Bounds = <700,190,920,480>;
  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <470,190,690,320>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <240,190,460,320>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,190,230,320>;
  }

  // This variable stores an animation effect used to show/hide the list.
  $rect <940,510,1140,550>
  var Effects::Effect effect;

  // This variable stores the List component if its is visible actually.
  $rect <940,470,1140,510>
  var Application::ComboBoxList list;

  // This variable stores an item instance used in the ComboBox to show the actual \
  // selection.
  $rect <710,430,910,470>
  var Application::ComboBoxItem previewItem;

  // This variable stores the current state of the ComboBox.
  $rect <710,390,910,430>
  var bool opened;

  // This variable stores the current state of the ComboBox.
  $rect <710,350,910,390>
  var bool pressed;

  // This variable stores the current state of the ComboBox.
  $rect <710,310,910,350>
  var bool selected;

  // This variable stores the current state of the ComboBox.
  $rect <710,270,910,310>
  var bool enabled;

  // This timer object is used to flash the ComboBox when the user has tapped it \
  // very quickly or the ComboBox has been activated with the keyboard. This is just \
  // a visual feedback effect.
  $rect <480,230,680,270>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <250,230,450,270>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the list has finished its fade-in/out \
  // animation.
  $rect <940,430,1140,470>
  slot onEndFadeOutEffect
  {
    var Core::Root root = (Core::Root)list.Owner;

    // End the modal state of the list and remove it from the application.
    root.Remove( list );
    root.EndModal( list );
    list = null;

    // Release the effect object
    effect = null;

    // Trigger an update in the ComboBox to reflect the new state.
    InvalidateViewState();
  }

  // This internal slot method is called when the list has finished its fade-in/out \
  // animation.
  $rect <940,390,1140,430>
  slot onEndFadeInEffect
  {
    // Release the effect object
    effect = null;
  }

  // This internal slot method is called when the user has made a selection in the \
  // List or decided to close the list without any selection. Thereupon the list \
  // disappears.
  $rect <940,350,1140,390>
  slot onCloseList
  {
    // The list is already closed.
    if ( !list )
      return;

    // If there is already an effect running, stop it first.
    if ( effect )
      effect.Enabled = false;

    // Create a new effect object to animate the list when it is hidden. In this
    // template the animation modulates the opacity of the list.
    var Effects::Int32Effect int32Effect = new Effects::Int32Effect;

    // Configure the animation and start it
    int32Effect.Value1        = list.Opacity;
    int32Effect.Value2        = 0;
    int32Effect.CycleDuration = 150;
    int32Effect.NoOfCycles    = 1;
    int32Effect.Outlet        = ^list.Opacity;
    int32Effect.OnFinished    = onEndFadeOutEffect;
    int32Effect.Enabled       = true;
    effect                    = int32Effect;
  }

  // This internal slot method is called when the user has made a selection within \
  // the List component. Thereupon the ComboBox is updated and the List is hidden.
  $rect <940,310,1140,350>
  slot onSelectItem
  {
    // The list is already closed.
    if ( !list )
      return;

    // Making a selection within the ComboBox closes the list.
    postsignal onCloseList;

    // Obtain access to the just selected item
    var Application::ComboBoxItem item = (Application::ComboBoxItem)sender;

    // If the selection did not change?
    if ( SelectedItem == item.Item )
      return;

    // Update the ComboBox to reflect the new selection
    SelectedItem = item.Item;

    // Inform the owner of the ComboBox about the made selection.
    postsignal OnSelect;

    // ... and if there is an associated Outlet, update it too
    if ( Outlet )
      Outlet^ = item.Item;
  }

  // This internal slot method is called when the actually displayed List component \
  // needs to update an item. The invocation is relayed to the slot method stored \
  // in the property @OnLoadItem.
  $rect <940,270,1140,310>
  slot onLoadItem
  {
    // Obtain access to the item for which the load operation is performed
    var Application::ComboBoxItem item = (Application::ComboBoxItem)sender;

    // ...and forward the signal to the OnLoadItem slot method. This method is then
    // responsible for the proper initialization of the item.
    View = item;
    signal OnLoadItem;
    View = null;
  }

  // This internal slot method is called when the user has activated the ComboBox. \
  // It creates a new instance of the respective List component and displays it.
  $rect <940,230,1140,270>
  slot onShowList
  {
    // Avoid race conditions caused by the delay of 'FlashTimer'. Due to the delay
    // the method 'onShowList' may become invoked twice. Thus ignore the second
    // invocation if there is already a list visible.
    if ( list )
      return;

    var Core::Root root   = GetRoot();
    var rect       bounds = Bounds;

    // Calculate the screen global position of the ComboBox
    bounds.origin = Owner.GlobalPosition( bounds.origin );

    // Create a new instance of the ComboBox List component and ...
    list = new Application::ComboBoxList;

    // ... initialize it, calculate its optimal size and position, etc.
    list.Initialize( bounds, root.Bounds.size, NoOfItems, SelectedItem, onLoadItem, 
                     onSelectItem, onCloseList );

    // If there is already an effect running, stop it first.
    if ( effect )
      effect.Enabled = false;

    // Create a new effect object to animate the list when it is shown. In this
    // template the animation changes the size of the list.
    var Effects::RectEffect rectEffect = new Effects::RectEffect;

    // Configure the animation. 
    rectEffect.Value1        = list.Bounds;
    rectEffect.Value2        = list.Bounds;
    rectEffect.CycleDuration = 150;
    rectEffect.Timing        = Effects::Timing.FastIn_EaseOut;
    rectEffect.NoOfCycles    = 1;
    rectEffect.Outlet        = ^list.Bounds;
    rectEffect.OnFinished    = onEndFadeInEffect;

    // Adjust the animation for the case, when the list should appear below the
    // combo box
    if ( list.Bounds.y1 > bounds.y1 )
      rectEffect.Value1.y2 = rectEffect.Value1.y1;

    // ... or above the combo box
    else
      rectEffect.Value1.y1 = rectEffect.Value1.y2;

    // ... and start the animation
    rectEffect.Enabled = true;
    effect             = rectEffect;

    // Make the list visible and modal
    root.Add( list, 0 );
    root.BeginModal( list );

    // Trigger the ComboBox to eventually adapt its appearance after the list is shown.
    InvalidateViewState();
  }

  // This slot method will receive a signal, if the value of the property assigned \
  // to @Outlet has been changed by another widget or by the application logic. In \
  // response to this notification, the widget will update itself.
  $rect <250,370,450,410>
  slot onOutlet
  {
    // Read the current value of the associated property and update accordingly
    // the state of the ComboBox.
    if ( Outlet != null )
      SelectedItem = Outlet^;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <480,270,680,310>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the ComboBox to update
    // its appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the associated list is shown
    postsignal onShowList;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <250,270,450,310>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the ComboBox via
    // the touch screen.
    if ( TouchHandler.Down )
      return;

    // Ignore repetitions of key events (e.g. when the user holds the key pressed)
    if ( KeyHandler.Repetition )
      return;

    // Pressing the key flashes the ComboBox for a short period. This is a kind
    // of feedback effect. Request the ComboBox to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The ComboBox is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the box or presses the key in
    // a very rapid succession. Thus ignore this new interaction.
    if ( FlashTimer.Enabled )
      return;

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the ComboBox. This only updates the box to appear pressed or released.
  $rect <20,270,220,310>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the ComboBox or drags the finger inside/outside
    // the box's area request the ComboBox update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the ComboBox's area. This activates the ComboBox.
  $rect <20,230,220,270>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the ComboBox area? In such case
    // the ComboBox is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user interaction has been passed over to the another touch handler
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the ComboBox for longer time. This was 
    // enough long to give a visual 'press' feedback to the user. The box can
    // be activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal onShowList;

    // The user has tapped the ComboBox very quickly. Defer the box activation
    // to give the user first a short visual feedback that the ComboBox has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background1
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,250,40>;
    preset Radius = 7;
    preset Color = #6E7B94FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background2
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeVert];
    preset Bounds = <212,0,252,40>;
    preset Radius = 7;
    preset Color = #8493B1FF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,43>;
    preset Point3 = <250,43>;
    preset Point2 = <250,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeVert];
    preset Bounds = <212,-1,253,36>;
    preset Color = #000000FF;
    preset FrameNumber = 1;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  $rect <690,50,890,90>
  onset Outlet
  {
    // Check if the new outlet differs from the currently used outlet
    if ( pure Outlet == value )
      return;

    // Detach from the previous outlet
    if ( pure Outlet != null )
      detachobserver onOutlet, pure Outlet;

    // Store the new outlet ...
    pure Outlet = value;

    // ... and attach to the new one
    if ( value != null )
      attachobserver onOutlet, value;

    // Finally, retrieve the current state of the property associated via 'Outlet'.
    if ( value != null )
      postsignal onOutlet;
  }

  $rect <490,50,690,90>
  onset SelectedItem
  {
    // Ensure the index of the selected item is valid
    if ( value < 0 )
      value = -1;

    // No changes - nothing to do
    if ( value == pure SelectedItem )
      return;

    // Remember the new item
    pure SelectedItem = value;

    // Changing the selection at the runtime forces the ComboBox to recreate
    // its preview item.
    if ( previewItem )
    {
      Remove( previewItem );
      previewItem = null;
    }

    // Request an update
    InvalidateViewState();
  }

  $rect <290,50,490,90>
  onset NoOfItems
  {
    // Ensure the given number of items is valid
    if ( value < 0 )
      value = 0;

    // No changes - nothing to do
    if ( value == pure NoOfItems )
      return;

    // Remember the new number of items
    pure NoOfItems = value;

    // Changing the number of items may affect the actually selected item.
    // Therefore recreate the preview item of the ComboBox.
    if ( previewItem )
    {
      Remove( previewItem );
      previewItem = null;
    }

    // Request an update
    InvalidateViewState();
  }

  // The method InvalidateItems() forces the combo box to reload one or more items. \
  // The index of the item to start the reload operation is specified in the parameter \
  // aFirstItem. The parameter aLastItem specifies the index of the last affected \
  // item. The first item has the index 0, the second 1, and so far. The operation \
  // can cause the combo box to invoke the external @OnLoadItem slot method for each \
  // affected item.
  $rect <490,100,690,140>
  method void InvalidateItems( arg int32 aFirstItem, arg int32 aLastItem )
  {
    // If there is actually a list box displayed, forward the request to its
    // embedded vertical list.
    if ( list )
      list.VerticalList.InvalidateItems( aFirstItem, aLastItem );

    // The request also forces the ComboBox to recreate its preview item if the
    // invalidated items affect the actually selected item.
    if ( previewItem && ( SelectedItem >= aFirstItem ) && ( SelectedItem <= aLastItem ))
    {
      Remove( previewItem );
      previewItem = null;

      // Request an update
      InvalidateViewState();
    }
  }

  // The variable 'View' refers to the item which is about to be loaded by the external \
  // slot method @OnLoadItem. In this manner the slot method can directly access \
  // and modify the item's properties.
  $rect <290,140,490,180>
  var Application::ComboBoxItem View;

  // The property 'OnSelect' can refer to a slot method, which will receive a signal \
  // each time the user has selected an item within the ComboBox. Thereupon the method's \
  // logic will be executed. In the associated slot method you can evaluate @SelectedItem \
  // to process the selection.
  $rect <690,100,890,140>
  property slot OnSelect = null;

  // The property 'OnLoadItem' should refer to a slot method, which will be invoked \
  // by the ComboBox in order to load an item with its corresponding content. Within \
  // the slot method the affected item can be accessed via variable @View.
  $rect <290,100,490,140>
  property slot OnLoadItem = null;

  // The property 'Outlet' can refer to any other 'int32' property the widget should \
  // remain synchronized with. When the user selects an item, the affected property \
  // is automatically updated to reflect the item's number. On the other hand, when \
  // the referred property is modified by another one, the ComboBox is automatically \
  // notified to remain in sync with the property.
  // This approach follows the Model-View-Controller (MVC) programming paradigm. \
  // Here the ComboBox represents the 'View' and 'Controller' and the property referred \
  // via 'Outlet' can be seen as a part of the 'Model'.
  $rect <690,10,890,50>
  property ^int32 Outlet = null;

  // The property 'SelectedItem' stores the index of the currently selected item \
  // or -1 if no item is selected. The first item has the index 0, the second 1, \
  // and so far.
  $rect <490,10,690,50>
  property int32 SelectedItem = -1;

  // The property 'NoOfItems' stores how many items are currently managed within \
  // the ComboBox. This value should correspond to the number of options the ComboBox \
  // offers to the user.
  $rect <290,10,490,50>
  property int32 NoOfItems = 0;
}

// ComboBox
note group Note5
{
  attr Bounds = <440,500,680,700>;
}
