$version 13.04

// This is the root component of the entire GUI application.
$rect <-300,20,-100,60>
$output false
class Application : Core::Root
{
  $rect <380,500,580,540>
  inherited property Bounds = <0,0,340,590>;

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset StackingPriority = 3;
    preset Bounds = <25,35,315,100>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "result here";
    preset Font = Application::DigitalResFont;
    preset Color = #0D1A38FF;
  }

  $rect <20,20,160,60>
  object Application::NumKeyBtns Keypad
  {
    preset StackingPriority = 2;
    preset Bounds = <20,129,320,569>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle OutputBgk
  {
    preset StackingPriority = 2;
    preset Bounds = <20,30,320,105>;
    preset ColorBL = ScreenOnB;
    preset ColorBR = ScreenOnB;
    preset ColorTR = ScreenT;
    preset ColorTL = ScreenT;
    preset Radius = 5;
    preset Color = ScreenOn;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset StackingPriority = 2;
    preset Bounds = <20,30,320,105>;
    preset Radius = 5;
    preset Width = 2;
    preset Color = #030324FF;
  }

  $rect <430,40,630,80>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = CalculateExpression;
    preset OnHold = null;
  }

  $rect <430,90,630,130>
  slot CalculateExpression
  {
    var string str = "";
    var string temp = "";
    var int32 cursorPosition = Text.String.length - 1; 

    if( KeyHandler.CharCode != '\0' )
    {  
      str = KeyHandler.CharCode;
    }
    else
    {
      str = Keypad.keyString;
    }

    if( Text.String == "result here" || str == "C" )
    {
      ResetVariables();
    }

    if(KeyHandler.Code == Core::KeyCode.Left)
    {
      if (cursorPosition > 0)
      {    
        cursorPosition--; 
      }
    }

    if( KeyHandler.Code == Core::KeyCode.Right )
    {
      if (cursorPosition < Text.String.length)
      {
        
        cursorPosition++; 
      }
    }

    if ( str != "=" &&  str != "C" && str != "c" && OutputBgk.Color != ScreenOff)
    {
        var char lastChar = Text.String[Text.String.length - 1];
        if ( str == "(" )
        {               
            if ( Text.String.length > 0 )
            {
                if ( IsDigit(lastChar) || lastChar == ')' )
                {
                    temp = Text.String + "x" + str;
                }
                else
                {
                    temp = Text.String + str;
                }
            }
            else
            {
                temp = Text.String + str;
            }
        }
        else if( str == "B" || KeyHandler.Code == Core::KeyCode.Backspace )
        {
            temp = Text.String.remove(Text.String.length - 1, 1);
        }
        else if( IsDigit(str[0]) )
        {
           if( lastChar == ')' )
           {
               temp = Text.String + "x" + str;
           }
           else
           {
               temp = Text.String + str;
           }
        }
        else
        {
            temp = Text.String + str;
        }
        Text.String = temp;
        cursorPosition++;
    }

    if (str == "=")
    {
      if(IsExpressionValid(Text.String))
      {
        Text.String = EvaluateRPN(Text.String);
        cursorPosition = Text.String.length; // Reset cursor to end after operation
      }
    }


  }

  // Key Event Handler
  note group KeyHandlerNote
  {
    attr Bounds = <380,0,670,160>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Bgk
  {
    preset Bounds = <0,0,340,590>;
    preset Color = #E2E6E9FF;
  }

  $rect <420,370,630,410>
  method float ExecTwoOp( arg float first, arg float second, arg string op )
  {
    var float res = 0.0;

    switch ( op[0] )
          {
            case '+':
              res = first + second;
            case '-':
              res = first - second;
            case 'x':
              res = first * second;
            case '/':
              if (second != 0.0)
                res = first / second;
              else
              { 
                if(first < 0.0)
                  {res = float_infn();}
                if(first > 0.0)
                  {res = float_infp();}
                if(first == 0.0)
                  {res = float_nan();}
              }
            case '%':
              { 
                var float temp = first * second;
                res = temp / 100;     
              }
            case '^': 
              res =  math_pow( first, second );
            default:
              res = 0.0;
          }

    return res;
  }

  $rect <420,420,630,460>
  method void ResetVariables()
  {
    Text.String = "";
  }

  $rect <730,50,930,90>
  method bool IsOperator( arg char op )
  {
    return ( op == '+' || op == '-' || op == 'x' || op == '/' ||  op == '%' || op == '^');
  }

  // Operation Handler
  note group Note
  {
    attr Bounds = <380,180,670,480>;
  }

  $rect <1050,50,1250,90>
  method int32 GetPriorityOfOperator( arg char op )
  {
    var int32 priority = 0;

    switch ( op )
          {
            case '+':
              priority = 1;
            case '-':
              priority = 1;
            case 'x':
              priority = 2;
            case '/':
              priority = 2;
            case '%':
             priority = 3;
            case '^': 
              priority = 3;
            default:
              priority = 1;
          }

    return priority;
  }

  $rect <1035,100,1260,140>
  method Application::Tuple GetNumberFromPosition( arg int32 startPos, arg string expression )
  {
    var int32 endPos;
    var Application::Tuple res = new Application::Tuple;
    var string nrStr = "";
    var int32 i = startPos;

    if( expression != "" )
    {
      if ( expression[i] == '-' )  
      {
        nrStr += expression[i];
        i++;
      }
      for( ; i < expression.length; i++ )
      {
        if( !IsOperator( expression[i] ) && IsDigit( expression[i] ) )
        {  
          nrStr += expression[i];
          endPos = i;
        }
        else
        {  
          break;    
        }
      }
    } 

    res.EndPosition = endPos;
    res.Subexpression = "none";
    res.IdentifiedNumber = nrStr.parse_float( -1.0 );
    return res; 
  }

  $rect <730,350,930,390>
  method bool IsExpressionValid( arg string expression )
  {
    // check for valid operators
    // check that operators are used correctly
    // correct paranthesis

    if ( expression == "" )
    {
         signal onOpenDialog;
         ErrorDialog.ErrorText.String = "Expression is null.";
         return false;
    }
    else
    {
        if( !CorrectParentheses(expression) )
        {
           signal onOpenDialog;
           ErrorDialog.ErrorText.String = "Parantheses used incorrectly.";
           return false;
        }
        else if ( !CharactersAllowed(expression) )
        {
           signal onOpenDialog;
           ErrorDialog.ErrorText.String = "Expression contains characters that are not allowed.";
           return false;
        }
        else if( !OperatorsCorrectlyUsed(expression) )
        {
           signal onOpenDialog;
           ErrorDialog.ErrorText.String = "Operators used incorrectly.";
           return false;
        }    
    }

    return true;
  }

  $rect <730,300,930,340>
  method bool IsDigit( arg char op )
  {
    return ( (op >= '0') && (op <= '9') || op == '.');
  }

  $rect <730,200,930,240>
  method bool CorrectParentheses( arg string expression )
  {
    var Application::CharStack stk = new Application::CharStack;
    var int32 i = 0;

    for( ; i < expression.length ; i++ )
    {
      if( expression[i] == '(' )
      {
        stk.Push(expression[i]);
      }
      else if( expression[i] == ')' ) 
      {
        if( stk.IsEmpty() )
        {
          return false;
        }
        stk.Pop();
      }
    }

    return stk.IsEmpty();
  }

  $rect <730,250,940,290>
  method bool OperatorsCorrectlyUsed( arg string expression )
  {
    var int32 i = 0;

    if( expression != "" )
    {  
      for ( ; i < expression.length; i++ )
      {
       if (i == 0)
        {
          if ( !((expression[i] >= '0' && expression[i] <= '9') || expression[i] == '-' || expression[i] == '(') )
          {
            return false; 
          }
        }
        else
        {
          if ( expression[i] == '-' && IsOperator(expression[i - 1]) && !IsDigit(expression[i + 1]) )
          {
              return false;
          }
          if ( IsOperator(expression[i]) && IsOperator(expression[i - 1]) && expression[i - 1] == '-' && expression[i] == '-' )
          {
            return false; 
          }
          if ( expression[i] == '.' && expression[i - 1] == '.' )
          {
            return false; 
          }
          
          if ( i == expression.length - 1 && IsOperator(expression[i]) )
          {
            return false;  
          }
        }
      }
    }

    return true;
  }

  $rect <730,100,930,140>
  method bool IsParenthesis( arg char op )
  {
    if( op == '(' || op == ')')
      return true;

    return false;
  }

  $rect <730,150,930,190>
  method bool CharactersAllowed( arg string expression )
  {
    var int32 i = 0;

    for( ; i < expression.length; i++ )
    {
      if ( IsOperator(expression[i]) == false && IsParenthesis(expression[i]) == false && IsDigit(expression[i]) == false )
        return false;
    }

    return true;
  }

  $rect <730,450,930,490>
  method bool IsWhiteSpace( arg char op )
  {
    return ( op == ' ' || op == '\t' );
  }

  $rect <20,20,160,60>
  object Application::ErrorDialog ErrorDialog
  {
    preset StackingPriority = 3;
    preset Bounds = <-270,207,-20,307>;
    preset Visible = false;
    preset OnCloseDialog = onDialogHandled;
  }

  $rect <1050,280,1250,320>
  slot onOpenDialog
  {
    Int32Effect.Enabled = true;
    ErrorDialog.Visible = true;
    ErrorDialog.Bounds.x = 45;
    ErrorDialog.OnCloseDialog = onDialogHandled;
  }

  $rect <1050,330,1250,370>
  slot onDialogHandled
  {
    ErrorDialog.Bounds.x = -270;
    ErrorDialog.Visible = false;
  }

  $rect <1050,230,1250,270>
  inherited method Init()
  {
    signal BatteryDialog.onUseBattery;
  }

  $rect <20,20,160,60>
  object Application::Battery BatteryDialog
  {
    preset Bounds = <110,144,230,199>;
    preset Visible = true;
  }

  $rect <1050,380,1250,420>
  object Effects::Int32Effect Int32Effect
  {
    preset NoOfCycles = 3;
    preset CycleDuration = 400;
    preset InterCycleDelay = 0;
    preset Enabled = true;
    preset Value1 = 155;
    preset Outlet = ^ErrorDialog.Opacity;
  }

  // Validations
  note group Note1
  {
    attr Bounds = <690,0,980,670>;
  }

  // Error Dialog
  note group Note2
  {
    attr Bounds = <1000,180,1290,450>;
  }

  // Get Methods
  note group Note3
  {
    attr Bounds = <1000,0,1290,160>;
  }

  $rect <730,550,930,590>
  method bool IsNumber( arg string expression )
  {
    var int32 i = 0;

    for( ; i < expression.length ; i++ )
    {
      if( !IsDigit(expression[i]) && !IsDot(expression[i]) )
      {
        return false;
      }
    }

    return true;
  }

  $rect <730,500,930,540>
  method bool IsDot( arg char op )
  {
    return op == '.';
  }

  $rect <420,320,630,360>
  method Application::StrVector TokenizeExpression( arg string expression )
  {
    var Application::StrVector tokens = new Application::StrVector;
    var int32 i = 0;

    for ( ; i < expression.length; i++ )  
    {
        if ( IsSpace(expression[i]) )
        {
            continue;
        }
        else if ( IsDigit(expression[i]) || (expression[i] == '.' && IsDigit(expression[i + 1])) ||
                 (expression[i] == '-' && (i == 0 || IsOperator(expression[i - 1]) || expression[i - 1] == '(') && (IsDigit(expression[i + 1]) || expression[i + 1] == '.')) )
        {
            var Application::Tuple gr = GetNumberFromPosition(i, expression);
            var string number = gr.IdentifiedNumber;
            i = gr.EndPosition;
            tokens.PushBack(number);
            continue;    
        }
        else if ( IsOperator(expression[i]) || IsParenthesis(expression[i]) )
        {
            var string c = "";
            c = expression[i];
            tokens.PushBack(c);
            continue;
        }
        else
        {
            continue;
        }
    }

    return tokens;



  }

  $rect <730,400,930,440>
  method bool IsSpace( arg char op )
  {
    return op == '\0' || op == '\t' || op =='\n';
  }

  $rect <420,270,640,310>
  method Application::StrVector ShuntingYardAlgorithm( arg string expression )
  {
    var Application::StrVector tokens  = new Application::StrVector;
    var Application::StrQueue output = new Application::StrQueue;
    var Application::StrStack operators = new Application::StrStack;

    tokens = TokenizeExpression( expression );
    var Application::StringElement token = tokens.Front;

    while( token != null )
    {
      if( token.DataStr.length == 1 )
      {
        var char t = token.DataStr[0];
        if( IsDigit(t) )
        {
          output.Push(token.DataStr);
          output.Print();
        }
        else if( IsParenthesis(t) )
        {
          if( t == '(')
          {
            operators.Push("(");
          }
          else if( t == ')')
          {
            while ( !operators.IsEmpty() && operators.GetTop() != "(" )
            {
              output.Push(operators.GetTop());
              operators.Pop();
            }
            if( !operators.IsEmpty() )
            {
              operators.Pop();
            }
          }
        }
        else if ( IsOperator(t) )
        {
          if( !operators.IsEmpty() )
          {
            var char top = operators.GetTop()[0];
            if( IsOperator(top) )
            {
              if( GetPriorityOfOperator(top) < GetPriorityOfOperator(t) )
              {
                operators.Push(token.DataStr);
              }
              else if( GetPriorityOfOperator(top) == GetPriorityOfOperator(t) || GetPriorityOfOperator(top) > GetPriorityOfOperator(t) )
              {
                output.Push(operators.GetTop());
                operators.Pop();
                operators.Push(token.DataStr);
              }
            }
            if( top == '(' )
            {
              operators.Push(token.DataStr);
            }
          }
          else
          {
            operators.Push(token.DataStr);
          }
        }   
      }
      else if( IsNumber(token.DataStr) || IsNegativeNumber(token.DataStr) )
      {
        output.Push(token.DataStr);
      }

      token = token.Next;
    }

    while( !operators.IsEmpty() )
    {
      output.Push(operators.GetTop());
      operators.Pop();
    }

    var Application::StrVector expr  = new Application::StrVector;
    var Application::SimpleStringElement aux = output.Front;

    while( aux != null )
    {
      expr.PushBack(aux.DataStr);
      aux = aux.Next;
    }
    aux = null;

    return expr;

  }

  $rect <420,220,640,260>
  method string EvaluateRPN( arg string expression )
  {
    var Application::StrVector RPN  = new Application::StrVector;
    var Application::FloatStack stk = new Application::FloatStack;
    var float firstOp;
    var float secondOp;

    RPN = ShuntingYardAlgorithm( expression );
    var Application::StringElement token = RPN.Front;

    while( token != null )
    {
      if( IsOperator(token.DataStr[0]) && !IsNegativeNumber(token.DataStr) )
      {
        secondOp = stk.GetTop();
        stk.Pop();
        firstOp = stk.GetTop();
        stk.Pop();
        stk.Push(ExecTwoOp(firstOp, secondOp, token.DataStr[0]));
      }
      else 
      {
        stk.Push(token.DataStr.parse_float( -1.0 ));
      }
      token = token.Next;
    }

    var string result = "";
    result = stk.GetTop();

    return result;
  }

  $rect <730,600,930,640>
  method bool IsNegativeNumber( arg string expression )
  {
    var string subexpr = expression.right(expression.length - 1);

    if( expression[0] == '-' && IsNumber(subexpr) && expression.length > 1)
    {
      return true;
    }

    return false;
  }

  $rect <1010,610,1210,650>
  method void PowerOff()
  {
    BatteryDialog.Int32Effect.Enabled = true;
    TurnScreenOff();
    ResetVariables();
  }

  $rect <1010,510,1210,550>
  object Core::PropertyObserver BatteryLevelObserver
  {
    preset OnEvent = onBatteryOut;
    preset Outlet = ^BatteryDialog.BatteryPercentage;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver' \
  // is notified.
  $rect <1010,560,1210,600>
  slot onBatteryOut
  {
    if( BatteryDialog.BatteryPercentage == 0 )
    {
      PowerOff();
    }
  }

  $rect <20,20,160,60>
  object Application::TextEditor TextEd
  {
    preset StackingPriority = 3;
    preset Bounds = <-323,7,-23,72>;
    preset String = "result here";
    preset Color = #0D1A38FF;
    preset Font = Application::DigitalResFont;
  }

  $rect <1380,40,1580,80>
  var color ScreenOn = #CFE4F8FF;

  $rect <1380,90,1580,130>
  var color ScreenOnB = #99A8B7FF;

  $rect <1380,140,1580,180>
  var color ScreenT = #FFFFFFFF;

  $rect <1380,190,1580,230>
  var color ScreenOff = #4E555CFF;

  $rect <1380,240,1580,280>
  var color ScreenOffBL = #948F64FF;

  $rect <1380,290,1580,330>
  var color ScreenOffBR = #9E986AFF;

  // Screen Colors & Methods
  note group Note4
  {
    attr Bounds = <1330,0,1620,450>;
  }

  $rect <20,20,160,60>
  object Application::ChangeBattery ReplaceBatteryDialog
  {
    preset Bounds = <-151,138,-21,203>;
    preset Visible = false;
  }

  $rect <1220,510,1410,550>
  object Core::PropertyObserver StateObserver
  {
    preset OnEvent = onStateTrue;
    preset Outlet = ^BatteryDialog.State;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver' \
  // is notified.
  $rect <1210,560,1410,600>
  slot onStateTrue
  {
    if ( BatteryDialog.State == true )
    {
      BatteryDialog.Visible = false;
      ReplaceBatteryDialog.Visible = true;
      ReplaceBatteryDialog.Bounds.x = 105;
      ReplaceBatteryDialog.Text.String = "add new battery..";
      ReplaceBatteryDialog.Enabled = true; 
    }
  }

  $rect <1380,340,1580,380>
  method void TurnScreenOn()
  {
    OutputBgk.Color = ScreenOn;
    OutputBgk.ColorBL = ScreenOnB;
    OutputBgk.ColorBR = ScreenOnB;
  }

  $rect <1380,390,1580,430>
  method void TurnScreenOff()
  {
    OutputBgk.Color = ScreenOff;
    OutputBgk.ColorBL = ScreenOffBL;
    OutputBgk.ColorBR = ScreenOffBR;
  }

  // Battery Dialog
  note group Note5
  {
    attr Bounds = <1000,470,1630,660>;
  }

  $rect <1420,510,1620,550>
  object Core::PropertyObserver NewBatteryObserver
  {
    preset OnEvent = onValidBattery;
    preset Outlet = ^ReplaceBatteryDialog.NewBatteryLvl;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver' \
  // is notified.
  $rect <1420,560,1620,600>
  slot onValidBattery
  {
    if( ReplaceBatteryDialog.NewBatteryLvl >= 20 || ReplaceBatteryDialog.Enabled == false)
    {
      PowerOn();
    }
    else if ( ReplaceBatteryDialog.NewBatteryLvl < 20)
    {
      signal onOpenDialog;
      ErrorDialog.ErrorText.String = "Battery not charged.";
    }
  }

  $rect <1210,610,1410,650>
  method void PowerOn()
  {
    KeyHandler.Enabled = true;
    TurnScreenOn();
    ResetVariables();
    BatteryDialog.State = false;
    BatteryDialog.BatteryPercentage = ReplaceBatteryDialog.NewBatteryLvl;
    BatteryDialog.Text.Color = BatteryDialog.Green;
    BatteryDialog.Visible = true; 
    BatteryDialog.Enabled = true;
    Keypad.StackingPriority = 3;
  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Init
  $member Bounds
  $member KeyHandlerNote
  $member ScreenOn
  $member ScreenOnB
  $member ScreenT
  $member ScreenOff
  $member ScreenOffBL
  $member ScreenOffBR
  $member Bgk
  $member OutputBgk
  $member Border
  $member Text
  $member Keypad
  $member KeyHandler
  $member CalculateExpression
  $member ExecTwoOp
  $member ResetVariables
  $member IsOperator
  $member Note
  $member GetPriorityOfOperator
  $member GetNumberFromPosition
  $member IsExpressionValid
  $member IsDigit
  $member CorrectParentheses
  $member OperatorsCorrectlyUsed
  $member IsParenthesis
  $member CharactersAllowed
  $member IsWhiteSpace
  $member IsNumber
  $member IsDot
  $member IsNegativeNumber
  $member IsSpace
  $member TokenizeExpression
  $member ShuntingYardAlgorithm
  $member EvaluateRPN
  $member ErrorDialog
  $member onOpenDialog
  $member onDialogHandled
  $member BatteryDialog
  $member Int32Effect
  $member Note1
  $member Note2
  $member Note3
  $member Note4
  $member PowerOff
  $member BatteryLevelObserver
  $member onBatteryOut
  $member ReplaceBatteryDialog
  $member TextEd
  $member StateObserver
  $member onStateTrue
  $member TurnScreenOn
  $member TurnScreenOff
  $member Note5
  $member NewBatteryObserver
  $member onValidBattery
  $member PowerOn
}

$rect <-40,340,160,380>
$output false
resource Resources::Font NumFont
{
  attr fontname FontName = Book Antiqua;
  attr fontheight Height = 50;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <-40,440,160,480>
$output false
resource Resources::Font DigitalResFont
{
  attr fontname FontName = Digital-7;
  attr fontheight Height = 60;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <-300,130,-100,170>
$output false
class NumKeyBtns : Core::Group
{
  $rect <340,380,540,420>
  inherited property Bounds = <0,0,300,440>;

  $rect <360,100,560,140>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <360,50,560,90>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );
  }

  $rect <880,40,1120,80>
  object WidgetSet::PushButtonConfig DigitOpConfig
  {
    preset KeyCode = Core::KeyCode.NoKey;
    preset AccentColorFocused = #03040000;
    preset AccentColorDefault = #00000000;
    preset AccentLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset LabelColorActive = #8E6B74FF;
    preset LabelColorFocused = #8E6B74FF;
    preset LabelColorDisabled = #8E6B74FF;
    preset LabelColorDefault = #000000FF;
    preset LabelFont = Application::NumFont;
    preset FaceLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset FaceFrameActive = 1;
    preset FaceFrameFocused = 1;
    preset FaceFrameDisabled = 0;
    preset FaceFrameDefault = 0;
    preset FaceBitmapActive = Application::CustomBtn;
    preset FaceBitmapFocused = Application::CustomBtn;
    preset FaceBitmapDisabled = Application::CustomBtn;
    preset FaceBitmapDefault = Application::CustomBtn;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Two
  {
    preset Bounds = <80,150,150,220>;
    preset OnActivate = onActivateKey;
    preset Label = "2";
    preset Appearance = DigitOpConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Three
  {
    preset Bounds = <151,150,221,220>;
    preset OnActivate = onActivateKey;
    preset Label = "3";
    preset Appearance = DigitOpConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Four
  {
    preset Bounds = <10,220,80,290>;
    preset OnActivate = onActivateKey;
    preset Label = "4";
    preset Appearance = DigitOpConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Five
  {
    preset Bounds = <80,220,150,290>;
    preset OnActivate = onActivateKey;
    preset Label = "5";
    preset Appearance = DigitOpConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Six
  {
    preset Bounds = <150,220,220,290>;
    preset OnActivate = onActivateKey;
    preset Label = "6";
    preset Appearance = DigitOpConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Seven
  {
    preset Bounds = <10,290,80,360>;
    preset OnActivate = onActivateKey;
    preset Label = "7";
    preset Appearance = DigitOpConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Eight
  {
    preset Bounds = <80,290,150,360>;
    preset OnActivate = onActivateKey;
    preset Label = "8";
    preset Appearance = DigitOpConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Nine
  {
    preset Bounds = <150,290,220,360>;
    preset OnActivate = onActivateKey;
    preset Label = "9";
    preset Appearance = DigitOpConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Zero
  {
    preset Bounds = <80,360,150,430>;
    preset OnActivate = onActivateKey;
    preset Label = "0";
    preset Appearance = DigitOpConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Clear
  {
    preset Bounds = <10,7,80,77>;
    preset OnActivate = onActivateKey;
    preset Label = "C";
    preset Appearance = MultiplyConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Equals
  {
    preset Bounds = <149,360,293,428>;
    preset OnActivate = onActivateKey;
    preset Label = "=";
    preset Appearance = EqualsConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Plus
  {
    preset Bounds = <222,290,292,360>;
    preset OnActivate = onActivateKey;
    preset Label = "+";
    preset Appearance = DigitOpBoldConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Minus
  {
    preset Bounds = <223,220,293,290>;
    preset OnActivate = onActivateKey;
    preset Label = "-";
    preset Appearance = MultiplyConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Multiply
  {
    preset Bounds = <221,150,291,220>;
    preset OnActivate = onActivateKey;
    preset Label = "x";
    preset Appearance = MultiplyConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Divide
  {
    preset Bounds = <222,80,292,150>;
    preset OnActivate = onActivateKey;
    preset Label = "/";
    preset Appearance = DivideConfig;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset StackingPriority = -1;
    preset Bounds = <0,1,300,440>;
    preset Radius = 5;
    preset Width = 2;
    preset Color = #030324FF;
  }

  $rect <880,290,1120,330>
  object WidgetSet::PushButtonConfig EqualsConfig
  {
    preset OnUpdate = null;
    preset KeyCode = Core::KeyCode.Equals;
    preset LabelColorActive = #FFFCFEFF;
    preset LabelColorFocused = #FFFCFEFF;
    preset LabelColorDisabled = #FFFCFEFF;
    preset LabelColorDefault = #990002FF;
    preset LabelFont = Application::EqFont;
    preset FaceFrameActive = 1;
    preset FaceFrameFocused = 1;
    preset FaceFrameDisabled = 0;
    preset FaceFrameDefault = 0;
    preset FaceBitmapActive = Application::EqualsBtn;
    preset FaceBitmapFocused = Application::EqualsBtn;
    preset FaceBitmapDisabled = Application::EqualsBtn;
    preset FaceBitmapDefault = Application::EqualsBtn;
  }

  $rect <360,150,560,190>
  slot onActivateKey
  {
    sender; /* the method is called from the sender object */
    var WidgetSet::PushButton currentSender = ( WidgetSet::PushButton )sender;

    if ( currentSender != null ) 
    {
      keyString = currentSender.Label;
      var char charCode = '\0';
      var Core::KeyCode keyCode = Core::KeyCode.NoKey;

      if ( keyString != "" ) 
      {   
        charCode = keyString[0];
        if ( charCode != '\0' && keyCode == Core::KeyCode.NoKey ) 
        {
          GetRoot().DriveKeyboardHitting(Core::KeyCode.NoKey, charCode, true);
          GetRoot().DriveKeyboardHitting(Core::KeyCode.NoKey, charCode, false);
        }

        if ( keyCode != Core::KeyCode.NoKey ) 
        {
          GetRoot().DriveKeyboardHitting(keyCode, '\0', true);
          GetRoot().DriveKeyboardHitting(keyCode, '\0', false);
        }

      } 
      else
        trace "textKeyView is null";
    } 
    else 
        trace "focusedView is null";
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Dot
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <9,360,79,430>;
    preset OnActivate = onActivateKey;
    preset Label = ".";
    preset Appearance = DigitOpConfig;
  }

  $rect <360,300,560,340>
  object Core::Timer FlashKeyTimer
  {
    preset OnTrigger = triggerTimer;
    preset Period = 0;
    preset Begin = 100;
    preset Enabled = false;
  }

  $rect <600,300,800,340>
  slot triggerTimer
  {
    sender; /* the method is called from the sender object */
    InvalidateViewState();
  }

  // Flash effect
  note group Note
  {
    attr Bounds = <340,250,820,370>;
  }

  // Handling pressed key
  note group Note1
  {
    attr Bounds = <340,0,820,220>;
  }

  // Push Button Configurations
  note group Note2
  {
    attr Bounds = <850,0,1150,550>;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton empty00
  {
    preset Bounds = <1189,145,1254,195>;
    preset Label = "Caption";
    preset Appearance = DigitOpConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton One
  {
    preset Bounds = <10,150,80,220>;
    preset OnActivate = onActivateKey;
    preset Label = "1";
    preset Appearance = DigitOpConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Power
  {
    preset Bounds = <80,80,150,150>;
    preset OnActivate = onActivateKey;
    preset IconFrameActive = 1;
    preset IconFrameFocused = 1;
    preset IconFrameDefault = 0;
    preset IconFrame = 0;
    preset Icon = null;
    preset Label = "^";
    preset Appearance = PowConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Percentage
  {
    preset Bounds = <150,79,220,149>;
    preset OnActivate = onActivateKey;
    preset Label = "%";
    preset Appearance = PercentConfig;
  }

  $rect <880,140,1120,180>
  object WidgetSet::PushButtonConfig PowConfig
  {
    preset KeyCode = Core::KeyCode.Power;
    preset IconMarginBottom = 2;
    preset IconMarginTop = 2;
    preset IconMarginRight = 2;
    preset IconMarginLeft = 2;
    preset IconAlignment = Views::ImageAlignment[AlignHorzCenter, AlignVertCenter];
    preset FaceFrameActive = 1;
    preset FaceFrameFocused = 1;
    preset FaceFrameDisabled = 0;
    preset FaceFrameDefault = 0;
    preset FaceBitmapActive = Application::PowBtn;
    preset FaceBitmapFocused = Application::PowBtn;
    preset FaceBitmapDisabled = Application::PowBtn;
    preset FaceBitmapDefault = Application::PowBtn;
  }

  $rect <880,190,1120,230>
  object WidgetSet::PushButtonConfig PercentConfig
  {
    preset KeyCode = Core::KeyCode.NoKey;
    preset FaceFrameActive = 1;
    preset FaceFrameFocused = 1;
    preset FaceFrameDisabled = 0;
    preset FaceFrameDefault = 0;
    preset FaceBitmapActive = Application::PercentBtn;
    preset FaceBitmapFocused = Application::PercentBtn;
    preset FaceBitmapDisabled = Application::PercentBtn;
    preset FaceBitmapDefault = Application::PercentBtn;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton empty01
  {
    preset Bounds = <1189,5,1254,55>;
    preset Label = "Caption";
    preset Appearance = PowConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton empty02
  {
    preset Bounds = <1189,75,1254,125>;
    preset Label = "Caption";
    preset Appearance = PercentConfig;
  }

  $rect <880,90,1120,130>
  object WidgetSet::PushButtonConfig DigitOpBoldConfig
  {
    preset KeyCode = Core::KeyCode.NoKey;
    preset AccentColorFocused = #03040000;
    preset AccentColorDefault = #00000000;
    preset AccentLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset LabelColorActive = #8E6B74FF;
    preset LabelColorFocused = #8E6B74FF;
    preset LabelColorDisabled = #8E6B74FF;
    preset LabelColorDefault = #000000FF;
    preset LabelFont = Application::NumBoldFont;
    preset FaceLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset FaceFrameActive = 1;
    preset FaceFrameFocused = 1;
    preset FaceFrameDisabled = 0;
    preset FaceFrameDefault = 0;
    preset FaceBitmapActive = Application::CustomBtn;
    preset FaceBitmapFocused = Application::CustomBtn;
    preset FaceBitmapDisabled = Application::CustomBtn;
    preset FaceBitmapDefault = Application::CustomBtn;
  }

  $rect <880,240,1120,280>
  object WidgetSet::PushButtonConfig DivideConfig
  {
    preset KeyCode = Core::KeyCode.Divide;
    preset FaceFrameActive = 1;
    preset FaceFrameFocused = 1;
    preset FaceFrameDisabled = 0;
    preset FaceFrameDefault = 0;
    preset FaceBitmapActive = Application::DivideBtn;
    preset FaceBitmapFocused = Application::DivideBtn;
    preset FaceBitmapDisabled = Application::DivideBtn;
    preset FaceBitmapDefault = Application::DivideBtn;
  }

  $rect <880,340,1120,380>
  object WidgetSet::PushButtonConfig MultiplyConfig
  {
    preset KeyCode = Core::KeyCode.Multiply;
    preset AccentColorFocused = #03040000;
    preset AccentColorDefault = #00000000;
    preset AccentLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset LabelColorActive = #8E6B74FF;
    preset LabelColorFocused = #8E6B74FF;
    preset LabelColorDisabled = #8E6B74FF;
    preset LabelColorDefault = #000000FF;
    preset LabelFont = Application::MultiplyFont;
    preset FaceLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset FaceFrameActive = 1;
    preset FaceFrameFocused = 1;
    preset FaceFrameDisabled = 0;
    preset FaceFrameDefault = 0;
    preset FaceBitmapActive = Application::CustomBtn;
    preset FaceBitmapFocused = Application::CustomBtn;
    preset FaceBitmapDisabled = Application::CustomBtn;
    preset FaceBitmapDefault = Application::CustomBtn;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton OpenParanthesis
  {
    preset Bounds = <10,80,45,150>;
    preset OnActivate = onActivateKey;
    preset Label = "(";
    preset Appearance = ParanthesisConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton ClosedParanthesis
  {
    preset Bounds = <45,80,80,150>;
    preset OnActivate = onActivateKey;
    preset Label = ")";
    preset Appearance = ParanthesisConfig;
  }

  $rect <880,390,1120,430>
  object WidgetSet::PushButtonConfig ParanthesisConfig
  {
    preset KeyCode = Core::KeyCode.NoKey;
    preset AccentColorFocused = #03040000;
    preset AccentColorDefault = #00000000;
    preset AccentLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset LabelColorActive = #FFFCFEFF;
    preset LabelColorFocused = #FFFCFEFF;
    preset LabelColorDisabled = #FFFCFEFF;
    preset LabelColorDefault = #000000FF;
    preset LabelFont = Application::NumFont;
    preset FaceLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset FaceFrameActive = 1;
    preset FaceFrameFocused = 1;
    preset FaceFrameDisabled = 0;
    preset FaceFrameDefault = 0;
    preset FaceBitmapActive = Application::ParenthesisBtn;
    preset FaceBitmapFocused = Application::ParenthesisBtn;
    preset FaceBitmapDisabled = Application::ParenthesisBtn;
    preset FaceBitmapDefault = Application::ParenthesisBtn;
  }

  $rect <880,440,1120,480>
  object WidgetSet::PushButtonConfig NegateNumbers
  {
    preset KeyCode = Core::KeyCode.NoKey;
    preset AccentColorFocused = #03040000;
    preset AccentColorDefault = #00000000;
    preset AccentLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset LabelColorActive = #8E6B74FF;
    preset LabelColorFocused = #8E6B74FF;
    preset LabelColorDisabled = #8E6B74FF;
    preset LabelColorDefault = #000000FF;
    preset LabelFont = Application::NumFont1;
    preset FaceLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset FaceFrameActive = 1;
    preset FaceFrameFocused = 1;
    preset FaceFrameDisabled = 0;
    preset FaceFrameDefault = 0;
    preset FaceBitmapActive = Application::CustomBtn;
    preset FaceBitmapFocused = Application::CustomBtn;
    preset FaceBitmapDisabled = Application::CustomBtn;
    preset FaceBitmapDefault = Application::CustomBtn;
  }

  $rect <880,490,1120,530>
  object WidgetSet::PushButtonConfig BackConfig
  {
    preset KeyCode = Core::KeyCode.Backspace;
    preset FaceFrameActive = 1;
    preset FaceFrameFocused = 1;
    preset FaceFrameDisabled = 0;
    preset FaceFrameDefault = 0;
    preset FaceBitmapActive = Application::BackBtn;
    preset FaceBitmapFocused = Application::BackBtn;
    preset FaceBitmapDisabled = Application::BackBtn;
    preset FaceBitmapDefault = Application::BackBtn;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton BackBtn
  {
    preset Bounds = <222,7,292,77>;
    preset OnActivate = onActivateKey;
    preset Label = "B";
    preset Appearance = BackConfig;
  }

  $rect <590,50,790,90>
  property string keyString;

  $rect <590,90,790,130>
  onset keyString
  {
    // The value doesn't change - nothing to do.
    if ( pure keyString == value )
      return;

    // Remember the property's new value.
    pure keyString = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <590,130,790,170>
  onget keyString
  {
    return pure keyString;
  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Bounds
  $member UpdateLayout
  $member UpdateViewState
  $member Border
  $member DigitOpConfig
  $member EqualsConfig
  $member onActivateKey
  $member FlashKeyTimer
  $member triggerTimer
  $member Note
  $member Note1
  $member Note2
  $member empty00
  $member empty01
  $member empty02
  $member One
  $member Two
  $member Three
  $member Four
  $member Five
  $member Six
  $member Seven
  $member Eight
  $member Nine
  $member Zero
  $member Clear
  $member Plus
  $member Minus
  $member Multiply
  $member Divide
  $member Dot
  $member Power
  $member Percentage
  $member OpenParanthesis
  $member ClosedParanthesis
  $member Equals
  $member PowConfig
  $member PercentConfig
  $member DigitOpBoldConfig
  $member DivideConfig
  $member MultiplyConfig
  $member ParanthesisConfig
  $member NegateNumbers
  $member BackConfig
  $member BackBtn
  $member keyString
  $member OnSetkeyString
  $member OnGetkeyString
}

$rect <463,30,663,70>
$output false
resource Resources::Bitmap CustomBtn
{
  attr bitmapfile FileName = .\resources\buttons.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <70,70>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <463,80,663,120>
$output false
resource Resources::Bitmap EqualsBtn
{
  attr bitmapfile FileName = .\resources\equals.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <140,70>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <-40,490,160,530>
$output false
resource Resources::Font EqFont
{
  attr fontname FontName = Book Antiqua;
  attr fontheight Height = 90;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <463,130,663,170>
$output false
resource Resources::Bitmap PercentBtn
{
  attr bitmapfile FileName = .\resources\percent.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <70,70>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <463,180,663,220>
$output false
resource Resources::Bitmap PowBtn
{
  attr bitmapfile FileName = .\resources\pow.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <70,70>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// Components
note group Note
{
  attr Bounds = <-330,90,-80,440>;
}

// Bitmaps
note group Note1
{
  attr Bounds = <440,-20,680,840>;
}

// Fonts
note group Note2
{
  attr Bounds = <-60,300,420,650>;
}

// Application
note group Note3
{
  attr Bounds = <-330,-20,-80,80>;
}

$rect <-40,390,160,430>
$output false
resource Resources::Font NumBoldFont
{
  attr fontname FontName = Book Antiqua;
  attr fontheight Height = 50;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <460,229,660,269>
$output false
resource Resources::Bitmap DivideBtn
{
  attr bitmapfile FileName = .\resources\divide.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <70,70>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <200,340,400,380>
$output false
resource Resources::Font MultiplyFont
{
  attr fontname FontName = Consolas;
  attr fontheight Height = 50;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <-300,330,-100,370>
$output false
class Tuple
{
  $rect <239,-10,439,30>
  property float IdentifiedNumber;

  $rect <239,30,439,70>
  onset IdentifiedNumber
  {
    // The value doesn't change - nothing to do.
    if ( pure IdentifiedNumber == value )
      return;

    // Remember the property's new value.
    pure IdentifiedNumber = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <239,70,439,110>
  onget IdentifiedNumber
  {
    return pure IdentifiedNumber;
  }

  $rect <240,120,440,160>
  property int32 EndPosition = -1;

  $rect <240,160,440,200>
  onset EndPosition
  {
    // The value doesn't change - nothing to do.
    if ( pure EndPosition == value )
      return;

    // Remember the property's new value.
    pure EndPosition = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <240,200,440,240>
  onget EndPosition
  {
    return pure EndPosition;
  }

  $rect <480,-10,680,30>
  property string Subexpression = "none";

  $rect <480,30,680,70>
  onset Subexpression
  {
    // The value doesn't change - nothing to do.
    if ( pure Subexpression == value )
      return;

    // Remember the property's new value.
    pure Subexpression = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <480,70,680,110>
  onget Subexpression
  {
    return pure Subexpression;
  }

  $rect <10,10,160,50>
  inherited method Init()
  {
    aArg;
    IdentifiedNumber = float_infp();
    EndPosition = -1;
    Subexpression = "none";
  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Init
  $member IdentifiedNumber
  $member OnSetIdentifiedNumber
  $member OnGetIdentifiedNumber
  $member EndPosition
  $member OnSetEndPosition
  $member OnGetEndPosition
  $member Subexpression
  $member OnSetSubexpression
  $member OnGetSubexpression
}

$rect <-300,180,-100,220>
$output false
class ErrorDialog : Core::Group
{
  $rect <20,130,220,170>
  inherited property Bounds = <0,0,250,100>;

  $rect <20,20,160,60>
  object Views::Rectangle Bgk
  {
    preset Bounds = <0,0,250,100>;
    preset Radius = 3;
    preset Color = #E2E6E9FF;
  }

  $rect <20,20,160,60>
  object Views::Border BgkBorder
  {
    preset Bounds = <0,-1,250,100>;
    preset Radius = 3;
    preset Width = 2;
    preset Color = #470400FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle TopBar
  {
    preset Bounds = <0,0,250,30>;
    preset RadiusTR = 3;
    preset RadiusTL = 3;
    preset Radius = 3;
    preset Color = #990002FF;
  }

  $rect <20,20,160,60>
  object Views::Border TopBarBgk
  {
    preset Bounds = <0,0,250,30>;
    preset Width = 2;
    preset Color = #460400FF;
  }

  $rect <630,40,870,80>
  object WidgetSet::PushButtonConfig ExitBtnConfig
  {
    preset KeyCode = Core::KeyCode.Enter;
    preset LabelColorActive = #FFFFFFFF;
    preset LabelColorDisabled = #FFFFFFFF;
    preset LabelColorDefault = #000000FF;
    preset LabelMarginBottom = 3;
    preset LabelAlignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset LabelFont = Application::BtnFont;
  }

  $rect <20,20,160,60>
  object Views::Text ErrorText
  {
    preset Bounds = <5,38,235,78>;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertTop];
    preset String = "no errors";
    preset Font = Application::ErrorFont;
    preset Color = #2D0200FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <213,3,243,28>;
    preset OnActivate = onClose;
    preset Label = "X";
    preset Appearance = ExitBtnConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <159,61,243,91>;
    preset OnActivate = onClose;
    preset Label = "OK";
    preset Appearance = OkBtnConfig;
  }

  $rect <630,90,870,130>
  object WidgetSet::PushButtonConfig OkBtnConfig
  {
    preset KeyCode = Core::KeyCode.Enter;
    preset ThumbBorderColorActive = #20943100;
    preset ThumbBorderColorDefault = #3A842A00;
    preset ThumbBorderWidthActive = 0;
    preset ThumbBorderWidthDefault = 0;
    preset ThumbColorActive = #CC7E5100;
    preset ThumbColorDefault = #B7321F00;
    preset ThumbLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset LabelColorActive = #FFFFFFFF;
    preset LabelColorDisabled = #FFFFFFFF;
    preset LabelColorDefault = #000000FF;
    preset LabelMarginBottom = 3;
    preset LabelAlignment = Views::TextAlignment[AlignHorzAuto, AlignHorzCenter, AlignVertCenter];
    preset LabelFont = Application::BtnFont;
    preset FaceFrameActive = 1;
    preset FaceFrameFocused = 1;
    preset FaceFrameDisabled = 0;
    preset FaceFrameDefault = 0;
    preset FaceBitmapActive = Application::OKBtn;
    preset FaceBitmapFocused = Application::OKBtn;
    preset FaceBitmapDisabled = Application::OKBtn;
    preset FaceBitmapDefault = Application::OKBtn;
  }

  $rect <330,90,530,130>
  slot onClose
  {
    idlesignal OnCloseDialog;
  }

  $rect <330,40,530,80>
  property slot OnCloseDialog = null;

  $rect <20,20,160,60>
  object Views::Text Title
  {
    preset Bounds = <5,0,145,30>;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter, AlignVertTop];
    preset String = "CALCULATOR ERROR";
    preset Font = Application::ErrorFont;
    preset Color = #F2E6DDFF;
  }

  // Button Configs
  note group Note
  {
    attr Bounds = <600,0,900,150>;
  }

  // Close Dialog
  note group Note1
  {
    attr Bounds = <280,0,580,150>;
  }
}

$rect <200,390,400,430>
$output false
resource Resources::Font ErrorFont
{
  attr fontname FontName = Asap Condensed Medium;
  attr fontheight Height = 15;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <200,440,400,480>
$output false
resource Resources::Font BtnFont
{
  attr fontname FontName = Microsoft Yi Baiti;
  attr fontheight Height = 27;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <463,330,663,370>
$output false
resource Resources::Bitmap OKBtn
{
  attr bitmapfile FileName = .\resources\ok.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <70,30>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <463,280,663,320>
$output false
resource Resources::Bitmap ParenthesisBtn
{
  attr bitmapfile FileName = .\resources\paranthesis.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <35,70>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <200,490,400,530>
$output false
resource Resources::Font NumFont1
{
  attr fontname FontName = Book Antiqua;
  attr fontheight Height = 30;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <463,380,663,420>
$output false
resource Resources::Bitmap BackBtn
{
  attr bitmapfile FileName = .\resources\back.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <70,70>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <463,430,663,470>
$output false
resource Resources::Bitmap BatteryBgk
{
  attr bitmapfile FileName = .\resources\battery-filled.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <110,50>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <463,480,663,520>
$output false
resource Resources::Bitmap BatteryLine
{
  attr bitmapfile FileName = .\resources\battery-line.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <5,46>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <-300,230,-100,270>
$output false
class Battery : Core::Group
{
  $rect <140,0,340,40>
  inherited property Bounds = <0,0,120,54>;

  $rect <20,20,160,60>
  object Views::Image Bgk
  {
    preset Bounds = <5,2,115,52>;
    preset Bitmap = Application::BatteryBgk;
  }

  $rect <20,20,160,60>
  object Views::Image line1
  {
    preset Bounds = <7,4,12,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <0,350,200,390>
  slot onUseBattery
  {
    BatteryPercentage -= 0.05;
    var string str = "100";

    str = BatteryPercentage;

    if( BatteryPercentage < 50 )
    {
      Text.Color = Orange;
    }
    if ( BatteryPercentage < 20 )
    {
      Text.Color = Red;
    }

    Text.String = str;

    if( BatteryPercentage < 0 )
      BatteryPercentage = 0;

    if( BatteryPercentage < 20 )
      UpdateLowBatteryLines(BatteryPercentage);
    else
      UpdateBatteryLines(BatteryPercentage);
  }

  $rect <20,20,160,60>
  object Views::Image line2
  {
    preset Bounds = <12,4,17,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line3
  {
    preset Bounds = <17,4,22,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line4
  {
    preset Bounds = <22,4,27,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line5
  {
    preset Bounds = <27,4,32,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line6
  {
    preset Bounds = <32,4,37,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line7
  {
    preset Bounds = <37,4,42,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line8
  {
    preset Bounds = <42,4,47,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line9
  {
    preset Bounds = <47,4,52,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line10
  {
    preset Bounds = <52,4,57,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line11
  {
    preset Bounds = <57,4,62,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line12
  {
    preset Bounds = <62,4,67,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line13
  {
    preset Bounds = <67,4,72,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line14
  {
    preset Bounds = <72,4,77,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line15
  {
    preset Bounds = <77,4,82,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line16
  {
    preset Bounds = <82,4,87,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line17
  {
    preset Bounds = <87,4,92,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line18
  {
    preset Bounds = <92,4,97,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line19
  {
    preset Bounds = <97,4,102,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line20
  {
    preset Bounds = <102,4,107,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <0,300,200,340>
  object Core::Timer Timer
  {
    preset OnTrigger = onUseBattery;
    preset Period = 7000;
    preset Enabled = true;
  }

  $rect <200,300,400,340>
  method void UpdateBatteryLines( arg int32 percentage )
  {
    var int32 linesToShow = percentage / 5;

    var int32 i = 0;
      
    for( ; i < 20; i++ )
    {
      if( i < linesToShow )
      {
        batteryLines[i].Visible = true;
      }
      else
      {
        batteryLines[i].Visible = false;
      }     
    }
  }

  $rect <560,0,760,40>
  array Views::Image batteryLines[ 20 ] =
  (
    Default[0] = line1;
    Default[1] = line2;
    Default[2] = line3;
    Default[3] = line4;
    Default[4] = line5;
    Default[5] = line6;
    Default[6] = line7;
    Default[7] = line8;
    Default[8] = line9;
    Default[9] = line10;
    Default[10] = line11;
    Default[11] = line12;
    Default[12] = line13;
    Default[13] = line14;
    Default[14] = line15;
    Default[15] = line16;
    Default[16] = line17;
    Default[17] = line18;
    Default[18] = line19;
    Default[19] = line20;
  );

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <13,6,97,46>;
    preset String = "";
    preset Font = Application::BatteryFont;
    preset Color = #004606FF;
  }

  $rect <20,20,160,60>
  object Views::Image low1
  {
    preset Bounds = <7,4,12,50>;
    preset Bitmap = Application::LowBattery;
    preset Visible = true;
  }

  $rect <20,20,160,60>
  object Views::Image low2
  {
    preset Bounds = <12,4,17,50>;
    preset Bitmap = Application::LowBattery;
    preset Visible = true;
  }

  $rect <20,20,160,60>
  object Views::Image low3
  {
    preset Bounds = <17,4,22,50>;
    preset Bitmap = Application::LowBattery;
    preset Visible = true;
  }

  $rect <20,20,160,60>
  object Views::Image low4
  {
    preset Bounds = <22,4,27,50>;
    preset Bitmap = Application::LowBattery;
    preset Visible = true;
  }

  $rect <350,0,550,40>
  array Views::Image lowBatteryLines[ 20 ] =
  (
    Default[0] = low1;
    Default[1] = low2;
    Default[2] = low3;
    Default[3] = low4;
    Default[4] = line5;
    Default[5] = line6;
    Default[6] = line7;
    Default[7] = line8;
    Default[8] = line9;
    Default[9] = line10;
    Default[10] = line11;
    Default[11] = line12;
    Default[12] = line13;
    Default[13] = line14;
    Default[14] = line15;
    Default[15] = line16;
    Default[16] = line17;
    Default[17] = line18;
    Default[18] = line19;
    Default[19] = line20;
  );

  $rect <200,350,420,390>
  method void UpdateLowBatteryLines( arg int32 percentage )
  {
    HideInitialLines();

    var int32 linesToShow = percentage / 5;

    var int32 i = 0;
      
    for( ; i < 20; i++ )
    {
      if( i < linesToShow )
      {
        lowBatteryLines[i].Visible = true;
      }
      else
      {
        lowBatteryLines[i].Visible = false;
      }     
    }
  }

  $rect <400,300,600,340>
  method void HideInitialLines()
  {
    batteryLines[0].Visible = false;
    batteryLines[1].Visible = false;
    batteryLines[2].Visible = false;
    batteryLines[3].Visible = false;
    batteryLines[4].Visible = false;
    batteryLines[5].Visible = false;
    batteryLines[6].Visible = false;
    batteryLines[7].Visible = false;
    batteryLines[8].Visible = false;
    batteryLines[9].Visible = false;
    batteryLines[10].Visible = false;
    batteryLines[11].Visible = false;
    batteryLines[12].Visible = false;
    batteryLines[13].Visible = false;
    batteryLines[14].Visible = false;
    batteryLines[15].Visible = false;
    batteryLines[16].Visible = false;
    batteryLines[17].Visible = false;
    batteryLines[18].Visible = false;
    batteryLines[19].Visible = false;

  }

  $rect <200,120,400,160>
  property int32 BatteryPercentage = 101;

  $rect <600,120,800,160>
  onget BatteryPercentage
  {
    // Per default return the value stored already in the property.
    return pure BatteryPercentage;

    /*

      TO DO:

      If the property should return the value stored in the underlying device
      or in the middleware, remove the above 'return' statement and instead do
      following:

      Declare a local variable to receive the value from the underlying device.
      The type of the variable has to correspond to the data type of the property.
      For example in case of an 'int32' property:
      
        var int32 result;

      Implement a native statement to access the value and to store it in the
      variable 'result'. Then return the value. For example:

        $if !$prototyper
          native ( result )
          {
            result = YourDevice_GetSomeValue();
          }
        $endif

        return result;

    */
  }

  $rect <400,120,600,160>
  onset BatteryPercentage
  {
    // The property doesn't change -> nothing to do.
    if ( pure BatteryPercentage == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure BatteryPercentage = value;

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^BatteryPercentage;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <0,120,200,160>
  $output true
  method void UpdateBatteryPercentage( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure BatteryPercentage )
    {
      // Remember the new value in the internal memory of the property.
      pure BatteryPercentage = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^BatteryPercentage;
    }
  }

  $rect <600,300,800,340>
  object Effects::Int32Effect Int32Effect
  {
    preset OnFinished = onEffectFinished;
    preset NoOfCycles = 7;
    preset CycleDuration = 500;
    preset Outlet = ^Text.Opacity;
  }

  $rect <600,350,800,390>
  slot onEffectFinished
  {
    State = true; 
  }

  $rect <200,170,400,210>
  property bool State = false;

  $rect <600,170,800,210>
  onget State
  {
    // Per default return the value stored already in the property.
    return pure State;

    /*

      TO DO:

      If the property should return the value stored in the underlying device
      or in the middleware, remove the above 'return' statement and instead do
      following:

      Declare a local variable to receive the value from the underlying device.
      The type of the variable has to correspond to the data type of the property.
      For example in case of an 'int32' property:
      
        var int32 result;

      Implement a native statement to access the value and to store it in the
      variable 'result'. Then return the value. For example:

        $if !$prototyper
          native ( result )
          {
            result = YourDevice_GetSomeValue();
          }
        $endif

        return result;

    */
  }

  $rect <400,170,600,210>
  onset State
  {
    // The property doesn't change -> nothing to do.
    if ( pure State == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure State = value;

    notifyobservers ^State;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <0,170,200,210>
  $output true
  method void UpdateState( arg bool aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure State )
    {
      // Remember the new value in the internal memory of the property.
      pure State = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^State;
    }
  }

  $rect <860,70,1060,110>
  var color Green = #004606FF;

  $rect <860,120,1060,160>
  var color Orange = #BC5F00FF;

  $rect <860,170,1060,210>
  var color Red = #CB0014FF;

  // Text Colors
  note group Note
  {
    attr Bounds = <840,30,1080,230>;
  }

  // Properties
  note group Note1
  {
    attr Bounds = <-10,80,810,230>;
  }

  // Timer, battery update & effects
  note group Note2
  {
    attr Bounds = <-10,250,810,410>;
  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Bounds
  $member Bgk
  $member low1
  $member low2
  $member low3
  $member low4
  $member line1
  $member line2
  $member line3
  $member line4
  $member line5
  $member line6
  $member line7
  $member line8
  $member line9
  $member line10
  $member line11
  $member line12
  $member line13
  $member line14
  $member line15
  $member line16
  $member line17
  $member line18
  $member line19
  $member line20
  $member onUseBattery
  $member Timer
  $member UpdateBatteryLines
  $member batteryLines
  $member Text
  $member lowBatteryLines
  $member UpdateLowBatteryLines
  $member HideInitialLines
  $member BatteryPercentage
  $member OnGetBatteryPercentage
  $member OnSetBatteryPercentage
  $member UpdateBatteryPercentage
  $member Int32Effect
  $member onEffectFinished
  $member State
  $member OnGetState
  $member OnSetState
  $member UpdateState
  $member Green
  $member Orange
  $member Red
  $member Note
  $member Note1
  $member Note2
}

$rect <200,130,400,170>
$output false
class SimpleStringElement
{
  $rect <112,67,312,107>
  property string DataStr;

  $rect <112,107,312,147>
  onset DataStr
  {
    // The value doesn't change - nothing to do.
    if ( pure DataStr == value )
      return;

    // Remember the property's new value.
    pure DataStr = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <112,147,312,187>
  onget DataStr
  {
    return pure DataStr;
  }

  $rect <350,70,550,110>
  property Application::SimpleStringElement Next;

  $rect <350,110,550,150>
  onset Next
  {
    // The value doesn't change - nothing to do.
    if ( pure Next == value )
      return;

    // Remember the property's new value.
    pure Next = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <350,150,550,190>
  onget Next
  {
    return pure Next;
  }

  // Directives to adapt the order of members belonging to this class so they appear 
  // correctly arranged relative to the members inherited from the ancestor (super) 
  // classes. The numbers indicate the order-displacement to apply on the respective 
  // member once all members have been loaded and combined with members from the 
  // ancestor classes.
  $reorder DataStr 1
  $reorder OnSetDataStr 1
  $reorder OnGetDataStr 1
}

$rect <-30,80,170,120>
$output false
class StrQueue
{
  $rect <640,150,840,190>
  method void Push( arg string aValue )
  {
    var Application::SimpleStringElement strElement = new Application::SimpleStringElement;
    strElement.DataStr = aValue;
    strElement.Next = null;

    if( Front == null )
    {
      Front = strElement;
      Back = strElement;
    }
    else
    {
      Back.Next = strElement;
      Back = strElement;
    }
  }

  $rect <640,200,840,240>
  method void Pop()
  {
    var Application::SimpleStringElement aux = Front;

    if( aux == null )
    {
      trace "Queue is empty!";
    }
    else 
    {
       Front = Front.Next;
       aux = null;
    }
  }

  $rect <880,150,1080,190>
  method string GetFront()
  {
    if( Front != null )
    {
      return Front.DataStr;
    }

    return "";
  }

  $rect <880,200,1080,240>
  method string GetBack()
  {
    if( Back != null )
    {
      return Back.DataStr;
    }

    return "";
  }

  $rect <640,300,840,340>
  method bool IsEmpty()
  {
    if( Front == null || Back == null )
    {
      return true; // queue is empty
    }

    return false;
  }

  $rect <640,250,840,290>
  method void Clear()
  {
    while( Front != null )
    {
      Pop();
    }

    Size = 0;
  }

  $rect <640,100,840,140>
  inherited method Init()
  {
    Front = null;
    Back = null;
    Size = 0;
    Empty = true;
  }

  $rect <880,100,1080,140>
  method int32 GetSize()
  {
    while( Front != null )
    {
      Size++;
      Front = Front.Next;
    }

    return Size;
  }

  $rect <880,250,1080,290>
  method void Print()
  {
    var Application::SimpleStringElement aux = Front;

    while( aux != null )
    {
      trace aux.DataStr;
      aux = aux.Next;
    }

    aux = null;
  }

  $rect <124,80,324,120>
  property Application::SimpleStringElement Front;

  $rect <124,120,324,160>
  onset Front
  {
    // The value doesn't change - nothing to do.
    if ( pure Front == value )
      return;

    // Remember the property's new value.
    pure Front = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <124,160,324,200>
  onget Front
  {
    return pure Front;
  }

  $rect <120,220,320,260>
  property Application::SimpleStringElement Back;

  $rect <120,260,320,300>
  onset Back
  {
    // The value doesn't change - nothing to do.
    if ( pure Back == value )
      return;

    // Remember the property's new value.
    pure Back = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <120,300,320,340>
  onget Back
  {
    return pure Back;
  }

  $rect <370,80,570,120>
  property int32 Size;

  $rect <370,120,570,160>
  onset Size
  {
    // The value doesn't change - nothing to do.
    if ( pure Size == value )
      return;

    // Remember the property's new value.
    pure Size = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <370,160,570,200>
  onget Size
  {
    return pure Size;
  }

  $rect <370,220,570,260>
  property bool Empty;

  $rect <370,260,570,300>
  onset Empty
  {
    // The value doesn't change - nothing to do.
    if ( pure Empty == value )
      return;

    // Remember the property's new value.
    pure Empty = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <370,300,570,340>
  onget Empty
  {
    return pure Empty;
  }

  // Properties
  note group Note
  {
    attr Bounds = <100,40,590,360>;
  }

  // Methods
  note group Note1
  {
    attr Bounds = <620,40,1110,360>;
  }

  // Directives to adapt the order of members belonging to this class so they appear 
  // correctly arranged relative to the members inherited from the ancestor (super) 
  // classes. The numbers indicate the order-displacement to apply on the respective 
  // member once all members have been loaded and combined with members from the 
  // ancestor classes.
  $reorder Push 3
  $reorder Pop 3
  $reorder GetFront 1
  $reorder GetBack 1
  $reorder IsEmpty 1
  $reorder Clear 1
}

$rect <-30,130,170,170>
$output false
class StrStack
{
  $rect <600,90,800,130>
  inherited method Init()
  {
    Top = null;
    Size = 0;
    Empty = true;
  }

  $rect <60,70,260,110>
  property Application::SimpleStringElement Top;

  $rect <60,110,260,150>
  onset Top
  {
    // The value doesn't change - nothing to do.
    if ( pure Top == value )
      return;

    // Remember the property's new value.
    pure Top = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <60,150,260,190>
  onget Top
  {
    return pure Top;
  }

  $rect <60,200,260,240>
  property int32 Size;

  $rect <60,240,260,280>
  onset Size
  {
    // The value doesn't change - nothing to do.
    if ( pure Size == value )
      return;

    // Remember the property's new value.
    pure Size = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <60,280,260,320>
  onget Size
  {
    return pure Size;
  }

  $rect <290,70,490,110>
  property bool Empty;

  $rect <290,110,490,150>
  onset Empty
  {
    // The value doesn't change - nothing to do.
    if ( pure Empty == value )
      return;

    // Remember the property's new value.
    pure Empty = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <290,150,490,190>
  onget Empty
  {
    return pure Empty;
  }

  $rect <600,140,800,180>
  method void Push( arg string aValue )
  {
    var Application::SimpleStringElement strElement = new Application::SimpleStringElement;
    strElement.DataStr = aValue;
    strElement.Next = Top;
    Top = strElement;
  }

  $rect <600,190,800,230>
  method void Pop()
  {
    var Application::SimpleStringElement aux = Top;

    if( aux == null )
    {
      trace "Stack is empty!";
    }
    else 
    {
       aux = Top;
       Top = Top.Next;
       aux = null;
    }
  }

  $rect <830,140,1030,180>
  method string GetTop()
  {
    if( Top != null ) 
    {
      return Top.DataStr;
    }

    return "";
  }

  $rect <830,90,1030,130>
  method bool IsEmpty()
  {
    if( Top == null )
    {
      return true; // Stack is empty
    }

    return false;
  }

  $rect <830,190,1030,230>
  method int32 GetSize()
  {
    while( Top != null )
    {
      Size++;
      Top = Top.Next;
    }

    return Size;
  }

  $rect <600,240,800,280>
  method void Clear()
  {
    while( Top != null )
    {
      Pop();
    }

    Size = 0;
  }

  $rect <830,240,1030,280>
  method void Print()
  {
    var Application::SimpleStringElement aux = Top;

    while( aux != null )
    {
      trace aux.DataStr;
      aux = aux.Next;
    }

    aux = null;
  }

  // Properties
  note group Note
  {
    attr Bounds = <30,20,520,340>;
  }

  // Methods
  note group Note1
  {
    attr Bounds = <560,20,1050,340>;
  }
}

$rect <200,180,400,220>
$output false
class SimpleFloatElement
{
  $rect <141,53,341,93>
  property float DataFloat;

  $rect <141,93,341,133>
  onset DataFloat
  {
    // The value doesn't change - nothing to do.
    if ( pure DataFloat == value )
      return;

    // Remember the property's new value.
    pure DataFloat = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <141,133,341,173>
  onget DataFloat
  {
    return pure DataFloat;
  }

  $rect <380,50,580,90>
  property Application::SimpleFloatElement Next;

  $rect <380,90,580,130>
  onset Next
  {
    // The value doesn't change - nothing to do.
    if ( pure Next == value )
      return;

    // Remember the property's new value.
    pure Next = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <380,130,580,170>
  onget Next
  {
    return pure Next;
  }
}

$rect <-30,180,170,220>
$output false
class FloatStack
{
  $rect <590,90,790,130>
  inherited method Init()
  {
    Top = null;
    Size = 0;
    Empty = true;
  }

  $rect <70,60,270,100>
  property Application::SimpleFloatElement Top;

  $rect <70,100,270,140>
  onset Top
  {
    // The value doesn't change - nothing to do.
    if ( pure Top == value )
      return;

    // Remember the property's new value.
    pure Top = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <70,140,270,180>
  onget Top
  {
    return pure Top;
  }

  $rect <70,200,270,240>
  property int32 Size;

  $rect <70,240,270,280>
  onset Size
  {
    // The value doesn't change - nothing to do.
    if ( pure Size == value )
      return;

    // Remember the property's new value.
    pure Size = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <70,280,270,320>
  onget Size
  {
    return pure Size;
  }

  $rect <310,60,510,100>
  property bool Empty;

  $rect <310,100,510,140>
  onset Empty
  {
    // The value doesn't change - nothing to do.
    if ( pure Empty == value )
      return;

    // Remember the property's new value.
    pure Empty = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <310,140,510,180>
  onget Empty
  {
    return pure Empty;
  }

  $rect <590,140,790,180>
  method void Push( arg float aValue )
  {
    var Application::SimpleFloatElement floatElement = new Application::SimpleFloatElement;
    floatElement.DataFloat = aValue;
    floatElement.Next = Top;
    Top = floatElement;
  }

  $rect <590,190,790,230>
  method void Pop()
  {
    var Application::SimpleFloatElement aux = Top;

    if( aux == null )
    {
      trace "Stack is empty!";
    }
    else 
    {
       aux = Top;
       Top = Top.Next;
       aux = null;
    }
  }

  $rect <830,190,1030,230>
  method float GetTop()
  {
    if( Top != null ) 
    {
      return Top.DataFloat;
    }

    return 0;
  }

  $rect <830,90,1030,130>
  method bool IsEmpty()
  {
    if( Top == null )
    {
      return true; // Stack is empty
    }

    return false;
  }

  $rect <830,140,1030,180>
  method int32 GetSize()
  {
    while( Top != null )
    {
      Size++;
      Top = Top.Next;
    }

    return Size;
  }

  $rect <590,240,790,280>
  method void Clear()
  {
    while( Top != null )
    {
      Pop();
    }

    Size = 0;
  }

  $rect <830,240,1030,280>
  method void Print()
  {
    var Application::SimpleFloatElement aux = Top;

    while( aux != null )
    {
      trace aux.DataFloat;
      aux = aux.Next;
    }

    aux = null;
  }

  // Properties
  note group Note
  {
    attr Bounds = <40,20,530,340>;
  }

  // Methods
  note group Note1
  {
    attr Bounds = <560,20,1050,340>;
  }
}

$rect <200,30,400,70>
$output false
class StringElement
{
  $rect <130,114,330,154>
  property string DataStr;

  $rect <130,154,330,194>
  onset DataStr
  {
    // The value doesn't change - nothing to do.
    if ( pure DataStr == value )
      return;

    // Remember the property's new value.
    pure DataStr = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <130,194,330,234>
  onget DataStr
  {
    return pure DataStr;
  }

  $rect <380,110,580,150>
  property Application::StringElement Next;

  $rect <380,150,580,190>
  onset Next
  {
    // The value doesn't change - nothing to do.
    if ( pure Next == value )
      return;

    // Remember the property's new value.
    pure Next = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <380,190,580,230>
  onget Next
  {
    return pure Next;
  }

  $rect <630,110,830,150>
  property Application::StringElement Prev;

  $rect <630,150,830,190>
  onset Prev
  {
    // The value doesn't change - nothing to do.
    if ( pure Prev == value )
      return;

    // Remember the property's new value.
    pure Prev = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <630,190,830,230>
  onget Prev
  {
    return pure Prev;
  }
}

$rect <-30,30,170,70>
$output false
class StrVector
{
  $rect <640,30,840,70>
  inherited method Init()
  {
    Front = null;
    Back = null;
    Size = 0;
    Empty = true;
  }

  $rect <130,20,330,60>
  property Application::StringElement Front;

  $rect <130,60,330,100>
  onset Front
  {
    // The value doesn't change - nothing to do.
    if ( pure Front == value )
      return;

    // Remember the property's new value.
    pure Front = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <130,100,330,140>
  onget Front
  {
    return pure Front;
  }

  $rect <130,160,330,200>
  property Application::StringElement Back;

  $rect <130,200,330,240>
  onset Back
  {
    // The value doesn't change - nothing to do.
    if ( pure Back == value )
      return;

    // Remember the property's new value.
    pure Back = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <130,240,330,280>
  onget Back
  {
    return pure Back;
  }

  $rect <360,20,560,60>
  property int32 Size;

  $rect <360,60,560,100>
  onset Size
  {
    // The value doesn't change - nothing to do.
    if ( pure Size == value )
      return;

    // Remember the property's new value.
    pure Size = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <360,100,560,140>
  onget Size
  {
    return pure Size;
  }

  $rect <360,160,560,200>
  property bool Empty;

  $rect <360,200,560,240>
  onset Empty
  {
    // The value doesn't change - nothing to do.
    if ( pure Empty == value )
      return;

    // Remember the property's new value.
    pure Empty = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <360,240,560,280>
  onget Empty
  {
    return pure Empty;
  }

  $rect <640,80,840,120>
  method void PushBack( arg string aValue )
  {
    var Application::StringElement strElement = new Application::StringElement;
    strElement.DataStr = aValue;
    strElement.Next = null;
    strElement.Prev = Back;

    if( Back != null )
    {
      Back.Next = strElement;
    }
    else
    {
      Front = strElement;
    }
    Back = strElement;
  }

  $rect <640,130,840,170>
  method void Pop()
  {
    if( Back != null ) 
    {
      Back = Back.Prev;
      Back.Next = null;
    }
    else
    {
      Back = null;
    }
  }

  $rect <640,180,840,220>
  method string At( arg int32 pos )
  {
    var int32 index = 0;
    var Application::StringElement aux = Front;

    while( aux != null && index != pos)
    {
      aux = aux.Next;
      index++;
    }

    return aux.DataStr;
  }

  $rect <880,30,1080,70>
  method bool IsEmpty()
  {
    if( Front == null || Back == null )
    {
      return true; // vectir is empty
    }

    return false;
  }

  $rect <880,180,1080,220>
  method int32 GetSize()
  {
    var Application::StringElement aux = Front;

    while( aux != null )
    {
      Size++;
      aux = aux.Next;
    }

    return Size;

  }

  $rect <640,230,840,270>
  method void Clear()
  {
    while( Front != Back )
    {
      Pop();
    }
    Front = null;
  }

  $rect <880,230,1080,270>
  method void Print()
  {
    var Application::StringElement aux = Front;

    while( aux != null )
    {
      trace aux.DataStr;
      aux = aux.Next;
    }

    aux = null;
  }

  $rect <880,80,1080,120>
  method string GetFront()
  {
    if( Front != null )
    {
      return Front.DataStr;
    }

    return "";
  }

  $rect <880,130,1080,170>
  method string GetBack()
  {
    if( Back != null )
    {
      return Back.DataStr;
    }

    return "";
  }

  // Properties
  note group Note
  {
    attr Bounds = <110,-20,580,300>;
  }

  // Methods
  note group Note1
  {
    attr Bounds = <610,-20,1100,300>;
  }
}

$rect <-30,230,170,270>
$output false
class CharStack
{
  $rect <590,100,790,140>
  inherited method Init()
  {
    Top = null;
    Size = 0;
    Empty = true;
  }

  $rect <60,60,260,100>
  property Application::SimpleCharElement Top;

  $rect <60,100,260,140>
  onset Top
  {
    // The value doesn't change - nothing to do.
    if ( pure Top == value )
      return;

    // Remember the property's new value.
    pure Top = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <60,140,260,180>
  onget Top
  {
    return pure Top;
  }

  $rect <60,200,260,240>
  property int32 Size;

  $rect <60,240,260,280>
  onset Size
  {
    // The value doesn't change - nothing to do.
    if ( pure Size == value )
      return;

    // Remember the property's new value.
    pure Size = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <60,280,260,320>
  onget Size
  {
    return pure Size;
  }

  $rect <300,60,500,100>
  property bool Empty;

  $rect <300,100,500,140>
  onset Empty
  {
    // The value doesn't change - nothing to do.
    if ( pure Empty == value )
      return;

    // Remember the property's new value.
    pure Empty = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <300,140,500,180>
  onget Empty
  {
    return pure Empty;
  }

  $rect <590,150,790,190>
  method void Push( arg char aValue )
  {
    var Application::SimpleCharElement charElement = new Application::SimpleCharElement;
    charElement.DataChar = aValue;
    charElement.Next = Top;
    Top = charElement;
  }

  $rect <590,200,790,240>
  method void Pop()
  {
    var Application::SimpleCharElement aux = Top;

    if( aux == null )
    {
      trace "Stack is empty!";
    }
    else 
    {
       aux = Top;
       Top = Top.Next;
       aux = null;
    }
  }

  $rect <830,150,1030,190>
  method char GetTop()
  {
    if( Top != null ) 
    {
      return Top.DataChar;
    }

    return 0;
  }

  $rect <830,100,1030,140>
  method bool IsEmpty()
  {
    if( Top == null )
    {
      return true; // Stack is empty
    }

    return false;
  }

  $rect <830,200,1030,240>
  method int32 GetSize()
  {
    while( Top != null )
    {
      Size++;
      Top = Top.Next;
    }

    return Size;
  }

  $rect <590,250,790,290>
  method void Clear()
  {
    while( Top != null )
    {
      Pop();
    }

    Size = 0;
  }

  $rect <830,250,1030,290>
  method void Print()
  {
    var Application::SimpleCharElement aux = Top;

    while( aux != null )
    {
      trace aux.DataChar;
      aux = aux.Next;
    }

    aux = null;
  }

  // Methods
  note group Note1
  {
    attr Bounds = <560,20,1050,340>;
  }

  // Properties
  note group Note
  {
    attr Bounds = <30,20,520,340>;
  }
}

$rect <200,80,400,120>
$output false
class SimpleCharElement
{
  $rect <141,53,341,93>
  property char DataChar;

  $rect <141,93,341,133>
  onset DataChar
  {
    // The value doesn't change - nothing to do.
    if ( pure DataChar == value )
      return;

    // Remember the property's new value.
    pure DataChar = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <141,133,341,173>
  onget DataChar
  {
    return pure DataChar;
  }

  $rect <380,50,580,90>
  property Application::SimpleCharElement Next;

  $rect <380,90,580,130>
  onset Next
  {
    // The value doesn't change - nothing to do.
    if ( pure Next == value )
      return;

    // Remember the property's new value.
    pure Next = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <380,130,580,170>
  onget Next
  {
    return pure Next;
  }
}

// Data Structures
note group Note4
{
  attr Bounds = <-60,-20,420,290>;
}

$rect <-40,540,160,580>
$output false
resource Resources::Font BatteryFont
{
  attr fontname FontName = Digital-7;
  attr fontheight Height = 42;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <463,530,663,570>
$output false
resource Resources::Bitmap LowBattery
{
  attr bitmapfile FileName = .\resources\low-battery.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <5,46>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <-300,280,-100,320>
$output false
class ChangeBattery : Core::Group
{
  $rect <160,0,360,40>
  inherited property Bounds = <0,0,130,65>;

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,130,65>;
    preset Color = #4C5670FF;
  }

  $rect <190,90,390,130>
  property int32 NewBatteryLvl;

  $rect <190,140,390,180>
  onget NewBatteryLvl
  {
    // Per default return the value stored already in the property.
    return pure NewBatteryLvl;

    /*

      TO DO:

      If the property should return the value stored in the underlying device
      or in the middleware, remove the above 'return' statement and instead do
      following:

      Declare a local variable to receive the value from the underlying device.
      The type of the variable has to correspond to the data type of the property.
      For example in case of an 'int32' property:
      
        var int32 result;

      Implement a native statement to access the value and to store it in the
      variable 'result'. Then return the value. For example:

        $if !$prototyper
          native ( result )
          {
            result = YourDevice_GetSomeValue();
          }
        $endif

        return result;

    */
  }

  $rect <-10,140,190,180>
  onset NewBatteryLvl
  {
    // The property doesn't change -> nothing to do.
    if ( pure NewBatteryLvl == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure NewBatteryLvl = value;

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^NewBatteryLvl;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <-10,90,190,130>
  $output true
  method void UpdateProperty( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure NewBatteryLvl )
    {
      // Remember the new value in the internal memory of the property.
      pure NewBatteryLvl = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^NewBatteryLvl;
    }
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalSlider HorizontalSlider
  {
    preset Bounds = <6,29,126,64>;
    preset OnChange = onChangeSlider;
    preset OnEnd = onEndSlider;
    preset Outlet = ^NewBatteryLvl;
    preset MinValue = 20;
    preset Appearance = HorizontalSliderConfig;
  }

  $rect <440,30,680,70>
  object WidgetSet::HorizontalSliderConfig HorizontalSliderConfig
  {
    preset ThumbFrameActive = 0;
    preset ThumbFrameFocused = 0;
    preset ThumbFrameDisabled = 0;
    preset ThumbFrameDefault = 1;
    preset ThumbBitmapActive = Application::EnergySymbol;
    preset ThumbBitmapFocused = Application::EnergySymbol;
    preset ThumbBitmapDisabled = Application::EnergySymbol;
    preset ThumbBitmapDefault = Application::EnergySymbol;
    preset TrackRightBitmapActive = Application::SliderBack;
    preset TrackRightBitmapFocused = Application::SliderBack;
    preset TrackRightBitmapDefault = Application::SliderBack;
    preset TrackLeftBitmapActive = Application::SliderFront;
    preset TrackLeftBitmapFocused = Application::SliderFront;
    preset TrackLeftBitmapDefault = Application::SliderFront;
  }

  $rect <460,130,660,170>
  slot onEndSlider
  {
    this.Enabled = false;
    this.Bounds.x = -270;
    this.Visible = true;

  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <10,2,120,32>;
    preset String = "add new battery..";
    preset Font = Application::ChangeFont;
  }

  $rect <460,80,660,120>
  slot onChangeSlider
  {
    this.Text.String = NewBatteryLvl;
  }

  // Slider Config
  note group Note
  {
    attr Bounds = <430,-10,690,190>;
  }
}

$rect <460,580,660,620>
$output false
resource Resources::Bitmap ChangeBtn
{
  attr bitmapfile FileName = .\resources\change.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <130,36>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <200,540,400,580>
$output false
resource Resources::Font ChangeFont
{
  attr fontname FontName = Bahnschrift SemiCondensed;
  attr fontheight Height = 16;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

// This component implements an editor.
$rect <-300,380,-100,420>
$output false
class TextEditor : Templates::TextEditor
{
  $rect <670,620,870,660>
  inherited property Bounds = <0,0,160,120>;

  $rect <680,280,880,320>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited version of the method
    super( aState );

    // Activate the caret blinking if the editor component has the input focus
    if ( aState.contains( Core::ViewState[ Focused ]))
      blinkEffect.Enabled = true;

    // ... otherwise hide the caret
    else
    {
      blinkEffect.Enabled = false;
      Caret.Visible       = false;
    }
  }

  // To do:
  // 
  // - Adjust the visible size of the text editor (the thick blue border). This will \
  // be the editor's default size.
  // - Resize and arrange the member 'Text' so it covers the area where you intend \
  // to display the text. This is usually the entire area.
  // - Adjust the position and the size of the 'SimpleTouchHandler' and 'SlideTouchHandler', \
  // so they cover the 'Text' view.
  // - If your design it expects, add and configure more views in the component, \
  // e.g. views to display background, borders, etc.
  // - The editor implements several handler to process keyboard inputs. See the \
  // annotation 'Keyboard events'. Feel free to add more handler for other key events \
  // or remove the handler you don't need in your version.
  // - The editor displays a magnifying glass when the user touches and holds the \
  // finger for a while (see the method 'onHoldTouch'). If you don't want it, remove \
  // the contents within the annotation 'Magnifying glass' and the slot method 'onHoldTouch'.
  // - The editor reacts to touch interactions. See the annotation 'Touch screen \
  // events'. If your device is not touch driven, you can remove the both handlers \
  // 'SimpleTouchHandler', 'SlideTouchHandler' and the methods from the annotation \
  // 'Touch screen events'.
  // - Adapt the implementation of the 'UpdateViewState()' method. This method should \
  // update your views so they reflect the editor's current state (e.g. focused editor \
  // may appear with other colors, etc.)
  // - The editor is implemented with various properties allowing the configuration \
  // of the text (e.g. 'Font', 'Color', ...). If your version of the editor doesn't \
  // need such configuration, remove the properties and the associated OnSet methods.
  // - If you need other properties to configure the editor, add from the Gallery \
  // folder 'Chora' new properties. One property for every new setting (e.g. 'BorderWidth', \
  // etc.)
  // - Rename the properties accordingly their usage and remove their 'OnGet...' \
  // methods.
  // - For every newly added property adapt their 'OnSet...' method implementation. \
  // Ensure in the method that the assigned value is correctly passed to the corresponding \
  // view (e.g. a property 'BorderWidth' should update the eventually used 'Border' \
  // view, etc.).
  // - Feel free to modify any other member in this component accordingly your needs. \
  // Please note the member description and inline comments within methods.
  note legend Note6
  {
    attr Bounds = <10,690,990,1150>;
  }

  // Magnifying glass
  note group Note5
  {
    attr Bounds = <440,500,660,670>;
  }

  // Caret
  note group Note4
  {
    attr Bounds = <10,500,430,670>;
  }

  // State management
  note group Note3
  {
    attr Bounds = <670,240,890,330>;
  }

  // Touch screen events
  note group Note2
  {
    attr Bounds = <440,240,660,450>;
  }

  // Keyboard events
  note group Note1
  {
    attr Bounds = <10,240,430,490>;
  }

  // This internal variable refers to a temporary Views::Image object used to show \
  // the background for the augmented text content around the caret. This view appears \
  // during the user is moving this caret by touching the caret with the finger.
  $rect <450,620,650,660>
  var Views::Rectangle magnifyingBack = null;

  // This internal variable refers to a temporary Views::WarpGroup object used to \
  // show the augmented text content around the caret. This view appears during the \
  // user is moving this caret by touching the caret with the finger.
  $rect <450,580,650,620>
  var Views::WarpGroup magnifyingView = null;

  // This flag is set if it is evtl. necessary to scroll the editor content in order \
  // to ensure that the caret is still visible.
  $rect <220,620,420,660>
  var bool autoScroll;

  // This internal variable stores the current caret index. This is the position \
  // within Text.String property where the user can input text or delete signs.
  $rect <20,620,220,660>
  var int32 caretIndex = 0;

  // This slot method is called after the caret has been adjusted. Its job is to \
  // adjust too the position of the magnifying glass view where the augmented text \
  // content around the caret is shown.
  $rect <450,540,650,580>
  slot updateMagnifyingView
  {
    // There is actually no magnifying glass displayed. Nothing to do.
    if ( magnifyingView == null )
      return;

    var rect  srcArea = magnifyingView.SourceArea;
    var rect  extent  = magnifyingView.GetExtent();
    var rect  bounds  = Bounds;
    var point caret   = Caret.Point1;

    // Calculate the start position of the area to show in the magnifying
    // view. Preferably the caret should appear in the center of this area.
    var int32 srcX = caret.x - ( srcArea.w / 2 );

    // However, the part of magnifying glass displaying the caret should 
    // remain arranged horizontally within the editor area.
    if ( srcX < 0 )
      srcX = 0;

    if (( srcX + srcArea.w ) > bounds.w )
      srcX = bounds.w - srcArea.w;

    // The resulting start position of the area to augment
    magnifyingView.SourceArea.origin = point( srcX, caret.y );

    // Now calculate the position for the magnifyingView. Preferably the
    // the view should be arranged so it shows the augmented caret 
    // exactly above the origin caret
    var int32 dstX = ( bounds.x1 + caret.x ) - ( caret.x - srcX ) * 2;

    // From the new magnifyingView position and its current position calculate
    // an offset.
    var point ofs = point( dstX - extent.x1, bounds.y1 + caret.y - extent.y2 );

    // Move the magnifyingView and its background by the just calculated offset
    magnifyingView.MoveView( ofs, false );
    magnifyingBack.MoveView( ofs, false );
  }

  // This slot method is called after a short delay when the user has moved the caret \
  // or modified the text. Its job is to ensure that the caret is still visible. \
  // If necessary, the editor content is scrolled.
  $rect <220,540,420,580>
  slot updateScrollOffset
  {
    // Get the visible area of the text view
    var rect  bounds = Text.Bounds;
    var int32 ofsX   = 0;
    var int32 ofsY   = 0;

    // Calculate an offset to scroll the text content if the caret lies
    // outside the visible area
    if ( Caret.Point1.x < bounds.x1 ) ofsX = bounds.x1 - Caret.Point1.x;
    if ( Caret.Point1.x > bounds.x2 ) ofsX = bounds.x2 - Caret.Point1.x;
    if ( Caret.Point1.y < bounds.y1 ) ofsY = bounds.y1 - Caret.Point1.y;
    if ( Caret.Point2.y > bounds.y2 ) ofsY = bounds.y2 - Caret.Point2.y;

    // Should the cont be scrolled?
    if (( ofsX != 0 ) || ( ofsY != 0 ))
      Text.ScrollOffset = Text.ScrollOffset + point( ofsX, ofsY );

    // The following code takes care of the automatic adjustment of the
    // text scroll position if after modifying the text, its area is small
    // enough to be completely visible.
    ofsX = Text.ScrollOffset.x;
    ofsY = Text.ScrollOffset.y;

    // Get the current text area of the 
    var point size = Text.GetContentArea().size;

    // Does the area fit completely within the text editor?
    if ( size.x <= Text.Bounds.w ) ofsX = 0;
    if ( size.y <= Text.Bounds.h ) ofsY = 0;

    // If possible arrange the text so it fits within the text editor.
    Text.ScrollOffset = point( ofsX, ofsY );
  }

  // This slot method is attached to the Text view. Each time the Text view has rearranged \
  // the text, this method is called. Its job is to adjust the caret to the evtl. \
  // new position.
  $rect <20,540,220,580>
  slot updateCaret
  {
    // Without the font we don't know the height of the caret
    if ( Font == null )
      return;

    // Get the pixel position of the sign right to the caret
    var point rowCol = Text.StringIndex2RowCol( caretIndex );
    var point pos    = Text.RowCol2Position( rowCol );

    // Arrange the caret at the just determined position. The height of 
    // the caret corresponds to the height of a text row drawn with the
    // font
    Caret.Point1 = pos - point( 0, Font.Ascent  );
    Caret.Point2 = pos + point( 0, Font.Descent );

    // Restart the blink effect -> this ensures that the user can see the
    // caret while it is moved or the text is modified
    if ( blinkEffect.Enabled )
    {
      blinkEffect.Enabled = false;
      blinkEffect.Enabled = true;
    }

    // Should adjust the scroll position so that the caret remains in the visible
    // area? Finally clear the 'autoScroll' flag again.
    if ( autoScroll )
    {
      postsignal updateScrollOffset;
      autoScroll = false;
    }

    // If there is a magnifying glass view visible -> arrange it also to the
    // current caret position.
    if ( magnifyingView != null )
      postsignal updateMagnifyingView;
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to hide the magnifying glass view again.
  $rect <450,400,650,440>
  slot onReleaseTouch
  {
    // Hide the views used temporarily to show the augmented editor content
    if ( magnifyingView != null )
    {
      Owner.Remove( magnifyingView );
      Owner.Remove( magnifyingBack );
      magnifyingView = null;
      magnifyingBack = null;

      // Free the temporary used off-screen memory
      Buffered = false;
    }
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to move the caret accordingly to the user's finger movement.
  $rect <450,360,650,400>
  slot onDragTouch
  {
    // Does the user currently drag the caret?
    if ( magnifyingView != null )
    {
      // From the touched screen position estimate the corresponding position
      // within the text string.
      var point  rc            = Text.Position2RowCol( SimpleTouchHandler.CurrentPos );
      var int32  newCaretIndex = Text.RowCol2StringIndex( rc );
      var char   ch            = Text.String[ newCaretIndex ];

      // The caret points to a special control sign? In this case the sign comes
      // together with the preceding '%' escape sign - otherwise the user couldn't
      // see the sign. Adjust the caret position to refer the escape sign.
      if (( ch == '^' ) || ( ch == '~' ) || ( ch == '%' ))
        newCaretIndex = newCaretIndex - 1;

      // Does the caret position change? Force the editor to update the
      // position of the blinking caret
      if ( newCaretIndex != caretIndex )
      {
        caretIndex = newCaretIndex;
        postsignal updateCaret;

        // Ensure the caret is still visible later in the updateText slot method
        autoScroll = true;
      }
    }

    // No, then redirect the touch interaction to the slide touch handler when the
    // user moved the finger a little bit. In this manner the user can scroll the text.
    else
    {
      var point ofs   = SimpleTouchHandler.CurrentPos - SimpleTouchHandler.HittingPos;
      var int32 limit = GetRoot().CursorDragLimit;

      // Start the slide mode if the user has dragged the finger a little bit
      if (( ofs.x < -limit ) || ( ofs.x > limit ) ||
          ( ofs.y < -limit ) || ( ofs.y > limit ))
        GetRoot().DeflectCursor( SlideTouchHandler, <0,0>);
    }
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to activate the caret movement mode if the user has pressed the finger on the \
  // screen for a while. The method also shows a small magnifying glass where the \
  // text around the caret is shown. This should help the user to navigate the caret \
  // with the finger.
  $rect <450,320,650,360>
  slot onHoldTouch
  {
    // When the user presses the finger within the text editor area,
    // the editor enters the caret dragging mode. In this mode the
    // user can move the caret with the finger. For convenience the
    // area below the finger is displayed in a kind of magnifying glass.
    // Does enter the mode?
    if (( SimpleTouchHandler.HoldPeriod >= 300 ) && ( magnifyingView == null ))
    {
      // Calculate the size of the area to augment
      var int32 height = Caret.Point2.y - Caret.Point1.y;
      var int32 width  = height * 3;

      // Limit to the available size of the editor component
      if ( height > Bounds.h ) height = Bounds.h;
      if ( width  > Bounds.w ) width  = Bounds.w;

      // The editor component should store its content in an off-screen bitmap
      // in order to be able to to show it augmented in an overlay 'magnifyingView'
      Buffered = true;

      // Create a temporary view to show the augmented content and to show the
      // 'magnifying glass' background
      magnifyingView = new Views::WarpGroup;
      magnifyingBack = new Views::Rectangle;

      // Prepare a magnifyingView to show an augmented content of the edited text
      // row. The content is augmented by the factor x 2
      magnifyingView.Group       = this;
      magnifyingView.Quality     = true;
      magnifyingView.Opacity     = 200;
      magnifyingView.SourceArea  = rect( 0, 0, width, height );
      magnifyingView.Point2.x    = width  * 2;
      magnifyingView.Point3.x    = width  * 2;
      magnifyingView.Point3.y    = height * 2;
      magnifyingView.Point4.y    = height * 2;

      // Also prepare the magnifying glass background view. It is a semitransparent
      // rectangle.
      magnifyingBack.Bounds.size   = point( width * 2, height * 2 ) + <20,20>;
      magnifyingBack.Bounds.origin = <-10,-10>;
      magnifyingBack.Color         = #EEEEEECC;

      // Make the just created views visible on the screen
      Owner.Add( magnifyingBack, 0 );
      Owner.Add( magnifyingView, 0 );

      // Arrange the 'magnifying glass' views at the correct position
      postsignal updateMagnifyingView;
    }

    // Even if the user is not moving the cursor (finger) continue the scrolling when
    // the user holds the finger near an edge of the text editor.
    if ( magnifyingView != null )
      signal onDragTouch;
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to obtain the focused state for the editor so the user can interact with the \
  // editor content and to place the caret at the touched position.
  $rect <450,280,650,320>
  slot onPressTouch
  {
    // With the first touch focus the text editor
    if ( !HasViewState( Core::ViewState[ Focused ]))
      ObtainFocus();

    // Estimate the position within the text string corresponding to the
    // position touched on the screen.
    var point rc            = Text.Position2RowCol( SimpleTouchHandler.CurrentPos );
    var int32 newCaretIndex = Text.RowCol2StringIndex( rc );
    var char  ch            = Text.String[ newCaretIndex ];

    // The caret points to a special control sign? In this case the sign comes
    // together with the preceding '%' escape sign - otherwise the user couldn't
    // see the sign. Adjust the caret position to refer the escape sign.
    if (( ch == '^' ) || ( ch == '~' ) || ( ch == '%' ))
      newCaretIndex = newCaretIndex - 1;

    // Does the caret position change? Force the text editor to update the
    // position of the blinking caret
    if ( newCaretIndex != caretIndex )
    {
      caretIndex = newCaretIndex;
      postsignal updateCaret;

      // Ensure the caret is still visible later in the updateText slot method
      autoScroll = true;
    }
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // move the caret up/down/left or right in the editor text.
  $rect <220,440,420,480>
  slot onCursorKey
  {
    // No font specified to show the text -> no navigation
    // possible
    if ( Font == null )
      return;

    // Knowing the position of the caret within the string, get the
    // corresponding row/column position in the displayed text.
    var point rc = Text.StringIndex2RowCol( caretIndex );

    // Has the user moved the caret to the left? Get the new resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Left )
    {
      // Navigate to the previous column
      rc.x = rc.x - 1;

      // The begin of the row reached? Skip to the end of the preceding row.
      if ( Text.RowCol2StringIndex( rc ) == caretIndex )
      {
        rc.y = rc.y - 1;
        rc.x = Text.GetRowString( rc.y ).length;
      }
    }

    // Has the user moved the caret to the right? Get the resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Right )
    {
      // Navigate to the next column
      rc.x = rc.x + 1;

      // The end of the current row reached? Skip to the begin of the next
      // following row.
      if ( Text.RowCol2StringIndex( rc ) == caretIndex )
      {
        rc.y = rc.y + 1;
        rc.x = 0;
      }
    }

    // Has the user moved the caret one row up? Get the resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Up )
    {
      // Get the pixel position where the sign at actual caret position
      // is displayed
      var point pos       = Text.RowCol2Position( rc );
      var int32 rowHeight = Font.Ascent + Font.Descent + Font.Leading;

      // Get the row/column corresponding to the sign in the row just above
      rc = Text.Position2RowCol( pos - point( 0, rowHeight ));
    }

    // Has the user moved the caret one row down? Get the resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Down )
    {
      // Get the pixel position where the sign at actual caret position
      // is displayed
      var point pos       = Text.RowCol2Position( rc );
      var int32 rowHeight = Font.Ascent + Font.Descent + Font.Leading;

      // Get the row/column corresponding to the sign in the row just below
      rc = Text.Position2RowCol( pos + point( 0, rowHeight ));
    }

    // From the just determined new row/column position get the corresponding
    // position within the text string
    var int32 newCaretIndex = Text.RowCol2StringIndex( rc );
    var char  ch            = Text.String[ newCaretIndex ];

    // The caret points to a special control sign? In this case the sign comes
    // together with the preceding '%' escape sign - otherwise the user couldn't
    // see the sign. Adjust the caret position to refer the escape sign.
    if (( ch == '^' ) || ( ch == '~' ) || ( ch == '%' ))
      newCaretIndex = newCaretIndex - 1;

    // Does the caret position change? Force the editor to update the
    // position of the blinking caret
    if ( newCaretIndex != caretIndex )
    {
      caretIndex = newCaretIndex;
      postsignal updateCaret;

      // Ensure the caret is still visible later in the updateText slot method
      autoScroll = true;
    }
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // delete the sign preceding the current caret position and to move the caret accordingly.
  $rect <220,400,420,440>
  slot onBackspaceKey
  {
    // No signs preceding the caret -> Nothing to delete
    if ( caretIndex == 0 )
      return;

    // Get the sign which should be deleted from the text.
    var char  ch    = Text.String[ caretIndex - 1 ];
    var int32 count = 1;

    // The sign was a special control sign? In this case the sign comes
    // together with the preceding '%' escape sign - otherwise the user
    // couldn't see the sign
    if (( ch == '^' ) || ( ch == '~' ) || ( ch == '%' ))
      count = 2;

    // Remove the affected text portion and adjust the caret position
    Text.String = Text.String.remove( caretIndex - count, count );
    caretIndex  = caretIndex - count;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal OnChange;
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // delete the sign at the current caret position.
  $rect <220,360,420,400>
  slot onDeleteKey
  {
    // No signs following the caret -> Nothing to delete
    if ( caretIndex >= ( Text.String.length - 1 ))
      return;

    // Get the sign which should be deleted from the text.
    var char  ch    = Text.String[ caretIndex ];
    var int32 count = 1;

    // The sign was a special control sign? In this case the sign comes
    // together with the preceding '%' escape sign - otherwise the user
    // couldn't see the sign
    if ( ch == '%' )
      count = 2;

    // Remove the affected text fragment
    Text.String = Text.String.remove( caretIndex, count );

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal OnChange;
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // insert at the current caret position the <new line> sign and to move the caret \
  // to the next row.
  $rect <220,320,420,360>
  slot onNewlineKey
  {
    // Take over the just input sign and adjust the caret position
    Text.String = Text.String.insert( '\n', caretIndex );
    caretIndex  = caretIndex + 1;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal OnChange;
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // insert at the current caret position the sign which has been input by the user \
  // and to move the caret to the next column.
  $rect <220,280,420,320>
  slot onCharacterKey
  {
    var char   ch  = CharacterKeyHandler.CharCode;
    var string str = ch;

    // Precede all special control signs with the '%' escape sign. Otherwise
    // the user can't input nor see them
    if (( ch == '^' ) || ( ch == '~' ) || ( ch == '\xAD' ) || ( ch == '%' ))
      str = "%" + ch;

    // Take over the just input sign and adjust the caret position
    Text.String = Text.String.insert( str, caretIndex );
    caretIndex  = caretIndex + str.length;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal OnChange;
  }

  $rect <390,180,590,220>
  onset WrapText
  {
    // The value doesn't change - nothing to do.
    if ( pure WrapText == value )
      return;

    // Remember the new value ...
    pure WrapText = value;
    Text.WrapText = value;

    // If the text is warp automatically in rows, there is no need to
    // scroll the text horizontally.
    SlideTouchHandler.SlideHorz = !value;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  $rect <190,180,390,220>
  onset Alignment
  {
    // The value doesn't change - nothing to do.
    if ( pure Alignment == value )
      return;

    // Remember the new value ...
    pure Alignment = value;
    Text.Alignment = value;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  $rect <590,90,790,130>
  onget String
  {
    // Get the current text view content
    var string str = Text.String;

    // In the following steps remove any special text view control signs
    // which are usually used to control the text flow. The resulting string
    // should contain the 'pure' text only.
    var int32 inx = str.find( '%', 0 );

    // The special control/escape signs are not visible until there is a
    // '%' sign in front of them. Remove all superfluous '%' signs
    while ( inx >= 0 )
    {
      str = str.remove( inx, 1 );
      inx = str.find( '%', inx + 1 );
    }

    // Finally remove the <new line> sign at the end of text which was used
    // as workaround for a text flow parser issue
    return str.left( str.length - 1 );
  }

  $rect <590,50,790,90>
  onset String
  {
    // In the following steps disarm in the assigned Unicode string the special
    // control and escape signs, which usually control the text flow in a  text
    // view. Without this conversion step, signs like '%' couldn't be seen in
    // the editor.
    var string str = value;
    var int32  inx = str.find( '%', 0 );

    // The special '%' escape sign is not visible until there is other
    // '%' sign in front of it. Convert all '%' signs into '%%' sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '%', inx + 2 );
    }

    inx = str.find( '^', 0 );

    // The special '^' control sign is not visible until there is a '%'
    // sign in front of it. Convert all '^' signs into '%^' sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '^', inx + 2 );
    }

    inx = str.find( '~', 0 );

    // The special '~' control sign is not visible until there is a '%'
    // sign in front of it. Convert all '~' signs into '%~' sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '~', inx + 2 );
    }

    inx = str.find( '\xAD', 0 );

    // The special '\xAD' hyphen sign is not visible until there is a '%'
    // sign in front of it. Convert all '\xAD' hyphen signs into '%\xAD'
    // sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '\xAD', inx + 2 );
    }

    // Ensure that the caret still refers to a sign within the string
    if ( caretIndex > str.length )
      caretIndex = str.length;

    // Now show the new string in the editor's text view. The additional
    // <new line> is a workaround for a flow text parser issue
    Text.String = str + "\n";

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  $rect <390,50,590,90>
  onset Color
  {
    // The value doesn't change - nothing to do.
    if ( pure Color == value )
      return;

    // Store the new Color
    pure Color  = value;
    Text.Color  = value;
    Caret.Color = value;
  }

  $rect <190,50,390,90>
  onset Font
  {
    // The value doesn't change - nothing to do.
    if ( pure Font == value )
      return;

    // Store the new font...
    pure Font = value;
    Text.Font = value;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  // This bool change effect is used to blink the caret.
  $rect <20,580,220,620>
  object Effects::BoolEffect blinkEffect
  {
    preset Value2 = false;
    preset Value1 = true;
    preset Outlet = ^Caret.Visible;
    preset CycleDuration = 500;
    preset InterCycleDelay = 500;
  }

  // This key handler reacts to user inputs if the user has pressed the 'up', 'down', \
  // 'left' or 'right' key. In this case the associated onCursorKey method is called.
  $rect <20,440,220,480>
  object Core::KeyPressHandler CursorKeyHandler
  {
    preset OnPress = onCursorKey;
    preset Filter = Core::KeyCode.CursorKeys;
    preset OnHold = onCursorKey;
  }

  // This key handler reacts to user inputs if the user has pressed the 'backspace' \
  // key. In this case the associated onBackspaceKey method is called.
  $rect <20,400,220,440>
  object Core::KeyPressHandler BackspaceKeyHandler
  {
    preset OnPress = onBackspaceKey;
    preset Filter = Core::KeyCode.Backspace;
    preset OnHold = onBackspaceKey;
  }

  // This key handler reacts to user inputs if the user has pressed the 'delete' \
  // key. In this case the associated onDeleteKey method is called.
  $rect <20,360,220,400>
  object Core::KeyPressHandler DeleteKeyHandler
  {
    preset OnPress = onDeleteKey;
    preset Filter = Core::KeyCode.Delete;
    preset OnHold = onDeleteKey;
  }

  // This key handler reacts to user inputs if the user has pressed the 'enter' key. \
  // In this case the associated onNewlineKey method is called.
  $rect <20,320,220,360>
  object Core::KeyPressHandler NewlineKeyHandler
  {
    preset OnPress = onNewlineKey;
    preset Filter = Core::KeyCode.Enter;
    preset OnHold = onNewlineKey;
  }

  // This key handler reacts to user inputs if the user has pressed a key corresponding \
  // to character/digit. In this case the associated onCharacterKey method is called.
  $rect <20,280,220,320>
  object Core::KeyPressHandler CharacterKeyHandler
  {
    preset OnPress = onCharacterKey;
    preset Filter = Core::KeyCode.CharacterKeys;
    preset OnHold = onCharacterKey;
  }

  // This slide gesture handler is used to scroll the text content.
  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,160,120>;
    preset SlideHorz = false;
    preset Friction = 0.05;
  }

  // This generic touch handler is used to move the caret.
  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,120>;
    preset Point3 = <160,120>;
    preset Point2 = <160,0>;
    preset Point1 = <0,0>;
    preset OnDrag = onDragTouch;
    preset OnHold = onHoldTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset MaxStrikeCount = 3;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <2,2,157,117>;
    preset OnUpdate = updateCaret;
    preset SlideHandler = SlideTouchHandler;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Text\n";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Line Caret
  {
    preset Point2 = <50,70>;
    preset Point1 = <50,50>;
    preset Width2 = 2;
    preset Width1 = 2;
    preset Color = #000000FF;
    preset Visible = false;
  }

  // The property 'OnChange' can refer to a slot method, which should be invoked \
  // by the text editor when the user modifies the text.
  $rect <590,140,790,180>
  property slot OnChange = null;

  // The property 'WrapText' determines whether long text rows should be wrapped \
  // automatically.
  $rect <390,140,590,180>
  property bool WrapText = true;

  // The property 'Alignment' determines how the editor should display the text rows \
  // if their size differs from the size of the editor. 
  // In this manner the rows can be aligned horizontally. The entire text block can \
  // be aligned vertically.
  $rect <190,140,390,180>
  property Views::TextAlignment Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];

  // The property 'String' stores the text of the editor.
  $rect <590,10,790,50>
  property string String = "Text";

  // The property 'Color' controls the color of the text.
  $rect <390,10,590,50>
  property color Color = #000000FF;

  // The property 'Font' refers to the font object used to display the text. The \
  // text is determined by the property @String.
  $rect <190,10,390,50>
  property Resources::Font Font = Resources::FontMedium;
}

$rect <460,630,660,670>
$output false
resource Resources::Bitmap OkChangeBtn
{
  attr bitmapfile FileName = .\resources\ok-change.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <120,20>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <-40,590,160,630>
$output false
resource Resources::Font NewBatteryFont
{
  attr fontname FontName = Digital-7;
  attr fontheight Height = 27;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <460,680,660,720>
$output false
resource Resources::Bitmap EnergySymbol
{
  attr bitmapfile FileName = .\resources\battery-symbol.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <30,30>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <460,730,660,770>
$output false
resource Resources::Bitmap SliderFront
{
  attr bitmapfile FileName = .\resources\slider-front.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <120,20>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <460,780,660,820>
$output false
resource Resources::Bitmap SliderBack
{
  attr bitmapfile FileName = .\resources\slider-back.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <120,20>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}
