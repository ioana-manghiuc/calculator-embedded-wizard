$version 13.04

// This is the root component of the entire GUI application.
$rect <20,20,220,60>
$output false
class Application : Core::Root
{
  $rect <820,10,1020,50>
  inherited property Bounds = <0,0,300,400>;

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset StackingPriority = 1;
    preset Bounds = <390,0,698,400>;
    preset Bitmap = Application::BgkImg;
    preset AlphaBlended = false;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset StackingPriority = 3;
    preset Bounds = <-228,265,-128,295>;
    preset String = "Text";
    preset Font = Resources::DefaultFont;
  }

  $rect <20,20,160,60>
  object Application::NumPadClass Outline
  {
    preset StackingPriority = 2;
    preset Bounds = <32,145,272,385>;
  }
}

$rect <290,70,490,110>
$output false
resource Resources::Bitmap DigitsBitmap
{
  attr bitmapfile FileName = .\resources\Digits.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <36,52>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <290,20,490,60>
$output false
resource Resources::Bitmap BgkImg
{
  attr bitmapfile FileName = .\resources\bgk02.jpg;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <500,20,700,60>
$output false
resource Resources::Font NumFont
{
  attr fontname FontName = Cascadia Mono SemiBold;
  attr fontheight Height = 38;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <500,70,700,110>
$output false
resource Resources::Font MidNumFont
{
  attr fontname FontName = Cascadia Mono SemiBold;
  attr fontheight Height = 27;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <20,80,220,120>
$output false
class NumPadClass : Core::Group
{
  $rect <0,470,200,510>
  inherited property Bounds = <0,0,240,240>;

  $rect <20,20,160,60>
  object Views::Text One
  {
    preset StackingPriority = 2;
    preset Bounds = <14,16,64,68>;
    preset String = "1";
    preset Font = Application::NumFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset StackingPriority = 1;
    preset Bounds = <-249,-4,-9,236>;
    preset Color = #638691FF;
  }

  $rect <20,20,160,60>
  object Views::Text Zero
  {
    preset StackingPriority = 2;
    preset Bounds = <64,165,114,217>;
    preset String = "0";
    preset Font = Application::NumFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Nine
  {
    preset StackingPriority = 2;
    preset Bounds = <114,113,164,165>;
    preset String = "9";
    preset Font = Application::NumFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Six
  {
    preset StackingPriority = 2;
    preset Bounds = <114,61,164,113>;
    preset String = "6";
    preset Font = Application::NumFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Three
  {
    preset StackingPriority = 2;
    preset Bounds = <114,16,164,68>;
    preset String = "3";
    preset Font = Application::NumFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Eight
  {
    preset StackingPriority = 2;
    preset Bounds = <64,113,114,165>;
    preset String = "8";
    preset Font = Application::NumFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Five
  {
    preset StackingPriority = 2;
    preset Bounds = <64,61,114,113>;
    preset String = "5";
    preset Font = Application::NumFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Seven
  {
    preset StackingPriority = 2;
    preset Bounds = <14,113,64,165>;
    preset String = "7";
    preset Font = Application::NumFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Four
  {
    preset StackingPriority = 2;
    preset Bounds = <14,61,64,113>;
    preset String = "4";
    preset Font = Application::NumFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Two
  {
    preset StackingPriority = 2;
    preset Bounds = <64,16,114,68>;
    preset String = "2";
    preset Font = Application::NumFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Divide
  {
    preset StackingPriority = 2;
    preset Bounds = <175,131,225,183>;
    preset String = "/";
    preset Font = Application::MidNumFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Equals
  {
    preset StackingPriority = 2;
    preset Bounds = <175,183,225,235>;
    preset String = "=";
    preset Font = Application::NumFont;
    preset Color = #4A0604FF;
  }

  $rect <20,20,160,60>
  object Views::Text Clear
  {
    preset StackingPriority = 2;
    preset Bounds = <7,174,57,226>;
    preset String = "C";
    preset Font = Application::MidNumFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Multiply
  {
    preset StackingPriority = 2;
    preset Bounds = <175,87,225,139>;
    preset String = "*";
    preset Font = Application::MidNumFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Subtract
  {
    preset StackingPriority = 2;
    preset Bounds = <175,42,225,94>;
    preset String = "-";
    preset Font = Application::MidNumFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Plus
  {
    preset StackingPriority = 2;
    preset Bounds = <175,4,225,56>;
    preset String = "+";
    preset Font = Application::MidNumFont;
    preset Color = #000000FF;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <-240,320,-20,530>;
  }

  // This internal slot method is called when the user touches the keyboard area.
  $rect <-230,360,-30,400>
  slot onPressTouch
  {
    // Every time the user touches the keyboard or drags the finger inside/outside
    // a key area request the keyboard update its appearance. The update will occur
    // in the UpdateViewState() method.
    InvalidateViewState();

    trace "onPressTouch slot method";                    
    // The keyboard is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the keyboard in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new key interaction.
    if ( FlashTimer.Enabled )
    {
      signal activateKey;
      FlashTimer.Enabled = false;
    }

    // Remember the new position where the user has touched the screen
    recentPosition = TouchHandler.CurrentPos;
    trace recentPosition;
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the keyboard area. This activates the key the user has touched.
  $rect <-230,400,-30,440>
  slot onReleaseTouch
  {
    // Every time the user touches the keyboard or drags the finger inside/outside
    // a key area request the keyboard update its appearance. The update will occur
    // in the UpdateViewState() method.
    InvalidateViewState();

    // Did the user moved the finger outside the keyboard's area? In such case
    // the keyboard is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user has pressed and held a key for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The keyboard can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      signal activateKey;

    // The user has tapped the keyboard very quickly. Defer the key activation
    // to give the user first a short visual feedback that the key has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the keyboard. This updates the keyboard to highlight the key at the new touch \
  // position.
  $rect <-230,440,-30,480>
  slot onDragTouch
  {
    // Every time the user touches the keyboard or drags the finger inside/outside
    // a key area request the keyboard update its appearance. The update will occur
    // in the UpdateViewState() method.
    InvalidateViewState();

    // Remember the new position where the user recently touched the screen
    recentPosition = TouchHandler.CurrentPos;
  }

  // This variable stores the recent position inside the keyboard area where the \
  // user is touching the screen.
  $rect <-230,480,-30,520>
  var point recentPosition;

  // Feedback flash effect
  note group Note2
  {
    attr Bounds = <0,320,220,450>;
  }

  // This timer object is used to flash the pressed key when the user has tapped \
  // it very quickly. This is just a visual feedback effect.
  $rect <10,360,210,400>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <10,400,210,440>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the keyboard to update 
    // its appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the key is activated.
    signal activateKey;
  }

  // State management
  note group Note3
  {
    attr Bounds = <240,320,460,490>;
  }

  // The method UpdateViewState() is invoked automatically after the state of the \
  // component has been changed. This method can be overridden and filled with logic \
  // to ensure the visual aspect of the component does reflect its current state. \
  // For example, the 'enabled' state of the component can affect its colors (disabled \
  // components may appear pale). In this case the logic of the method should modify \
  // the respective color properties accordingly to the current 'enabled' state. 
  // The current state of the component is passed as a set in the parameter aState. \
  // It reflects the very basic component state like its visibility or the ability \
  // to react to user inputs. Beside this common state, the method can also involve \
  // any other variables used in the component as long as they reflect its current \
  // state. For example, the toggle switch component can take in account its toggle \
  // state 'on' or 'off' and change accordingly the location of the slider, etc.
  // Usually, this method will be invoked automatically by the framework. Optionally \
  // you can request its invocation by using the method @InvalidateViewState().
  $rect <250,360,450,400>
  method void UpdateViewState( arg Core::ViewState aState )
  {
    // Always invoke the inherited method.
    super( aState );
    trace "entered UpdateViewState method";

    var Core::View isKeyView = null; // --> the 'text' or 'image' view representing the pressed key.
    var bool       isPressed = ( TouchHandler.Down && TouchHandler.Inside ) || 
                                 FlashTimer.Enabled; // --> the affected key should appear pressed.

    // Search for the view representing the key at the recent touch position.
    // Do this however only when the position is valid - it lies inside the
    // area where keys are found (here the area of the TouchHandler) and the
    // key should appear pressed (isPressed == true)
    if ( isPressed && ( recentPosition == TouchHandler.GetExtent()))
      isKeyView = FindViewAtPosition( null, recentPosition, Core::ViewState[]);

    /*
       In this template, the keys are represented by simple 'text' and 'image'
       views. Any other view is considered as not corresponding to a key. Thus
       ignore every view, which is not an instance of 'text' or 'image'.
     
       TO DO:

       If you are using other views (not image nor text) to represent the keys,
       adapt the object runtime cast operations in the condition below to react
       on your particular views only. After this condition, 'isKeyView' should
       be either 'null' if the user is not pressing a key or it should refer to
       the view which represents the affected key.
    */

    if (((Views::Text)isKeyView == null ) && ((Views::Image)isKeyView == null ))
      isKeyView = null;

    /*

      TO DO:

      Depending on your keyboard design, you have surely added some new views
      to your keyboard. In the below code you should update the properties of
      these views. For example, when the user drags the finger between two keys
      one key should appear pressed while the other released.

      Whether the user has pressed/released a key can be estimated by comparing
      the variable 'isKeyView' with 'keyView'. If they differ, the user has
      pressed/released a key.

        if ( isKeyView != keyView )
          ...

      In practice, the variable 'isKeyView' represents the just pressed key.
      Your implementation should thus ensure, that the affected key appears
      pressed. If the user is not pressing any key, the variable is 'null'.

      The variable 'keyView' represents the key pressed in the preceding
      interaction. This key has thus to appear released. If there was no key
      pressed, the variable is 'null'.

      In the simplest case you modify the properties of the affected views, so
      they reflect their new state. Please note, the variables 'isKeyView' and
      'keyView' are declared with the generic Core::View class. In order to
      modify view specific properties you have to apply an object runtime cast
      operation on them. For example, if you are using 'text' views to represent
      keys, cast the variable to (Views::Text).

        if ( isKeyView != null )
          ((Views::Text)isKeyView).Color = color for a pressed key

        if ( keyView != null )
          ((Views::Text)keyView).Color = color for a released key

      Or you use, as demonstrated below, another views to highlight the area
      occupied by the affected key. For example, arrange some 'border' view
      to appear at the position of the pressed key with additional 5 pixel 
      padding:

        if ( isKeyView != null )
          BorderView.Bounds = isKeyView.GetExtent() * <5,5>;

      HINT:

      Instead of instantly alternate the views properties you can also start
      here effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the keyboard
      (e.g. 'isKeyView') with its preceding state (e.g. variable 'keyView').

      Assuming you have already added to your keyboard component a new effect
      member, named it 'pressedEffect' and configured it to animate e.g. the
      opacity of an image lying behind the pressed key. Then following is 
      sufficient to trigger the animation:

        if (( isKeyView != null ) && ( keyView == null ))
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if (( isKeyView == null ) && ( keyView != null ))
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */

    // Detect a state alternation when the user presses a new or releases a
    // previously pressed key.
    if ( isKeyView != keyView )
    {
      var Views::Text  isTextKeyView  = (Views::Text)isKeyView;
      var Views::Text  textKeyView    = (Views::Text)keyView;

      // If the user is actually pressing a key, arrange the background view
      // just behind the affected key view so it appears selected. If no key
      // is pressed, the background should disappear.
      if ( isKeyView != null )
      {
        Highlight.Bounds  = isKeyView.GetExtent();
        Highlight.Visible = true;
      }
      else
        Highlight.Visible = false;

      // If the user has pressed a key represented by a 'text' view, change the
      // color of the text to appear highlighted.
      if ( isTextKeyView != null )
        isTextKeyView.Color = #FFFFFFFF;

      // If the user has released a key represented by a 'text' view, restore
      // the color of the text.
      if ( textKeyView != null )
        textKeyView.Color = #000000FF;
    }

    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.
    keyView = isKeyView;
  }

  // This internal slot method is called when the recently pressed key should be \
  // activated. This is when the user presses on a key and then releases the finger \
  // again.
  $rect <250,400,450,440>
  slot activateKey
  {
    // Applying the object runtime casting to test whether the user is
    // touching a key with 'text' caption.
    var Views::Text textKeyView = (Views::Text)keyView;

    // Depending on the pressed key, the following variables will be
    // initialized with the corresponding code.
    var char          charCode = '\0';
    var Core::KeyCode keyCode  = Core::KeyCode.NoKey;
    trace "entered activateKey slot method";
    // Has the user touched (activated) one of the keys with text
    // as caption? Use the text as character code to feed the application 
    // with a keyboard event.
    if ( textKeyView != null )
    {
      // NU INTRA AICI INCA  
      charCode = textKeyView.String[0];
      trace "Key Pressed: " + charCode;
    }
    // Has the user touched the 'Enter' key?
    if ( textKeyView != null && textKeyView.String[0] == '=' )
      keyCode = Core::KeyCode.Enter;

    // Has the user touched the 'Clear' key?
    if ( textKeyView != null && textKeyView.String == "C" )
      keyCode = Core::KeyCode.Delete;

    // The user has pressed a regular character/digit key. Feed it as keyboard
    // event to the application.
    if ( charCode != '\0' && keyCode == Core::KeyCode.NoKey )
    {
      GetRoot().DriveKeyboardHitting( Core::KeyCode.NoKey, charCode, true );
      GetRoot().DriveKeyboardHitting( Core::KeyCode.NoKey, charCode, false );
    }

    // The user has pressed a special key (e.g. Enter or Delete). Feed it as keyboard
    // event to the application.
    if ( keyCode != Core::KeyCode.NoKey )
    {
      GetRoot().DriveKeyboardHitting( keyCode, '\0', true );
      GetRoot().DriveKeyboardHitting( keyCode, '\0', false );
    }

  }

  // This variable refers to the view representing the actually pressed key or it \
  // is 'null' if the user is not touching a key.
  $rect <250,440,450,480>
  var Core::View keyView;

  $rect <20,20,160,60>
  object Views::Rectangle Highlight
  {
    preset StackingPriority = 2;
    preset Bounds = <0,0,50,50>;
    preset Color = #123D4AFF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset StackingPriority = 3;
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,235>;
    preset Point3 = <240,236>;
    preset Point2 = <240,0>;
    preset Point1 = <0,0>;
    preset OnDrag = onDragTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset EnableMultiTouch = true;
    preset MaxStrikeCount = 100;
  }

  // This is a border view.
  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,240,240>;
    preset Width = 3;
    preset Color = #000000FF;
  }

  // Directives to adapt the order of members belonging to this class so they appear 
  // correctly arranged relative to the members inherited from the ancestor (super) 
  // classes. The numbers indicate the order-displacement to apply on the respective 
  // member once all members have been loaded and combined with members from the 
  // ancestor classes.
  $reorder InvalidateLayout 1
  $reorder InvalidateViewState 1
  $reorder InvalidateArea 1
  $reorder GetIndexOfView 1
  $reorder GetViewAtIndex 1
  $reorder CountViews 1
  $reorder FindViewWithStackingPriority 1
  $reorder FindViewInDirection 1
  $reorder FindViewWithinArea 1
  $reorder FindViewAtPosition 1
  $reorder FindPrevView 1
  $reorder FindNextView 1
  $reorder FindSiblingView 1
  $reorder GetContentArea 1
  $reorder FadeGroup 1
  $reorder RestackBehind 1
  $reorder RestackBack 1
  $reorder RestackTop 1
  $reorder Restack 1
  $reorder RemoveAll 1
  $reorder Remove 1
  $reorder AddBehind 1
  $reorder Add 1
  $reorder DeriveEnabledState 1
  $reorder Focus 1
  $reorder ClipViews 1
  $reorder Buffered 1
  $reorder Enabled 1
  $reorder Opacity 1
  $reorder Embedded 1
  $reorder AlphaBlended 1
  $reorder Visible 1
  $reorder One 1
  $reorder Rectangle 1
  $reorder Zero 1
  $reorder Nine 1
  $reorder Six 1
  $reorder Three 1
  $reorder Eight 1
  $reorder Five 1
  $reorder Seven 1
  $reorder Four 1
  $reorder Two 1
  $reorder Divide 1
  $reorder Equals 1
  $reorder Clear 1
  $reorder Multiply 1
  $reorder Subtract 1
  $reorder Plus 1
  $reorder Note1 1
  $reorder onPressTouch 1
  $reorder onReleaseTouch 1
  $reorder onDragTouch 1
  $reorder recentPosition 1
  $reorder Note2 1
  $reorder FlashTimer 1
  $reorder onFlashTimer 1
  $reorder Note3 1
}
