$version 13.04

// This is the root component of the entire GUI application.
$rect <-300,20,-100,60>
$output false
class Application : Core::Root
{
  $rect <380,550,580,590>
  inherited property Bounds = <0,0,340,590>;

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset StackingPriority = 3;
    preset Bounds = <25,34,315,99>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "result here";
    preset Font = Application::DigitalResFont;
    preset Color = #0D1A38FF;
  }

  $rect <20,20,160,60>
  object Application::NumKeyBtns Keypad
  {
    preset StackingPriority = 2;
    preset Bounds = <20,129,320,569>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle OutputBgk
  {
    preset StackingPriority = 2;
    preset Bounds = <20,30,320,105>;
    preset ColorBL = ScreenOnB;
    preset ColorBR = ScreenOnB;
    preset ColorTR = ScreenT;
    preset ColorTL = ScreenT;
    preset Radius = 5;
    preset Color = ScreenOn;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset StackingPriority = 2;
    preset Bounds = <20,30,320,105>;
    preset Radius = 5;
    preset Width = 2;
    preset Color = #030324FF;
  }

  $rect <430,40,630,80>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = CalculateExpression;
    preset OnHold = null;
  }

  $rect <430,90,630,130>
  slot CalculateExpression
  {
    var string str = "";
    var string temp = "";
    var int32 cursorPosition = Text.String.length - 1; 

    if( KeyHandler.CharCode != '\0' )
    {  
      str = KeyHandler.CharCode;
    }
    else
    {
      str = Keypad.keyString;
    }

    if( Text.String == "result here" || str == "C" || str == "c" )
    {
      ResetVariables();
    }

    if(KeyHandler.Code == Core::KeyCode.Left)
    {
      if (cursorPosition > 0)
      {    
        cursorPosition--; 
      }
    }

    if( KeyHandler.Code == Core::KeyCode.Right )
    {
      if (cursorPosition < Text.String.length)
      {
        
        cursorPosition++; 
      }
    }

    if ( str != "=" &&  str != "C" && str != "c" && OutputBgk.Color != ScreenOff)
    {
        var char lastChar = Text.String[Text.String.length - 1];
        if ( str == "(" )
        {               
            if ( Text.String.length > 0 )
            {
                if ( IsDigit(lastChar) || lastChar == ')' )
                {
                    temp = Text.String + "x" + str;
                }
                else
                {
                    temp = Text.String + str;
                }
            }
            else
            {
                temp = Text.String + str;
            }
        }
        else if( str == "B" || str == "b" || KeyHandler.Code == Core::KeyCode.Delete )
        {
            temp = Text.String.remove(Text.String.length - 1, 1);
        }
        else if( IsDigit(str[0]) )
        {
           if( lastChar == ')' )
           {
               temp = Text.String + "x" + str;
           }
           else
           {
               temp = Text.String + str;
           }
        }
        else if ( str == "%" || str == "^" )
        {
          temp = Text.String + "%" + str;
        }
        else
        {
            temp = Text.String + str;
        }
        Text.String = temp;
        cursorPosition++;
    }

    if (str == "=" )
    {
      temp = Text.String;
      Text.String = RemoveExtraSymbols(temp);
      if(IsExpressionValid(Text.String))
      {
        Text.String = EvaluateRPN(Text.String);
        cursorPosition = Text.String.length;
      }
    }


  }

  // Key Event Handler
  note group KeyHandlerNote
  {
    attr Bounds = <380,0,670,160>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Bgk
  {
    preset Bounds = <0,0,340,590>;
    preset Color = #E2E6E9FF;
  }

  $rect <420,370,630,410>
  method float ExecTwoOp( arg float first, arg float second, arg string op )
  {
    var float res = 0.0;

    switch ( op[0] )
          {
            case '+':
              res = first + second;
            case '-':
              res = first - second;
            case 'x':
              res = first * second;
            case '/':
              if (second != 0.0)
                res = first / second;
              else
              { 
                if(first < 0.0)
                  {res = float_infn();}
                if(first > 0.0)
                  {res = float_infp();}
                if(first == 0.0)
                  {res = float_nan();}
              }
            case '%':
              { 
                var float temp = first * second;
                res = temp / 100;     
              }
            case '^': 
              res =  math_pow( first, second );
            default:
              res = 0.0;
          }

    return res;
  }

  $rect <420,470,630,510>
  method void ResetVariables()
  {
    Text.String = "";
  }

  $rect <730,50,930,90>
  method bool IsOperator( arg char op )
  {
    return ( op == '+' || op == '-' || op == 'x' || op == '/' ||  op == '%' || op == '^');
  }

  // Operation Handler
  note group Note
  {
    attr Bounds = <380,180,670,530>;
  }

  $rect <1050,50,1250,90>
  method int32 GetPriorityOfOperator( arg char op )
  {
    var int32 priority = 0;

    switch ( op )
          {
            case '+':
              priority = 1;
            case '-':
              priority = 1;
            case 'x':
              priority = 2;
            case '/':
              priority = 2;
            case '%':
             priority = 3;
            case '^': 
              priority = 3;
            default:
              priority = 1;
          }

    return priority;
  }

  $rect <1035,100,1260,140>
  method Application::Tuple GetNumberFromPosition( arg int32 startPos, arg string expression )
  {
    var int32 endPos;
    var Application::Tuple res = new Application::Tuple;
    var string nrStr = "";
    var int32 i = startPos;

    if( expression != "" )
    {
      if ( expression[i] == '-' )  
      {
        nrStr += expression[i];
        i++;
      }
      for( ; i < expression.length; i++ )
      {
        if( !IsOperator( expression[i] ) && IsDigit( expression[i] ) )
        {  
          nrStr += expression[i];
          endPos = i;
        }
        else
        {  
          break;    
        }
      }
    } 

    res.EndPosition = endPos;
    res.Subexpression = "none";
    res.IdentifiedNumber = nrStr.parse_float( -1.0 );
    return res; 
  }

  $rect <730,350,930,390>
  method bool IsExpressionValid( arg string expression )
  {
    // check for valid operators
    // check that operators are used correctly
    // correct paranthesis

    if ( expression == "" )
    {
         signal onOpenDialog;
         ErrorDialog.ErrorText.String = "Expression is null.";
         return false;
    }
    else
    {
        if( !CorrectParentheses(expression) )
        {
           signal onOpenDialog;
           ErrorDialog.ErrorText.String = "Parantheses used incorrectly.";
           return false;
        }
        else if ( !CharactersAllowed(expression) )
        {
           signal onOpenDialog;
           ErrorDialog.ErrorText.String = "Expression contains characters that are not allowed.";
           return false;
        }
        else if( !OperatorsCorrectlyUsed(expression) )
        {
           signal onOpenDialog;
           ErrorDialog.ErrorText.String = "Operators used incorrectly.";
           return false;
        }    
    }

    return true;
  }

  $rect <730,300,930,340>
  method bool IsDigit( arg char op )
  {
    return ( (op >= '0') && (op <= '9') || op == '.');
  }

  $rect <730,200,930,240>
  method bool CorrectParentheses( arg string expression )
  {
    var Application::CharStack stk = new Application::CharStack;
    var int32 i = 0;

    for( ; i < expression.length ; i++ )
    {
      if( expression[i] == '(' )
      {
        stk.Push(expression[i]);
      }
      else if( expression[i] == ')' ) 
      {
        if( stk.IsEmpty() )
        {
          return false;
        }
        stk.Pop();
      }
    }

    return stk.IsEmpty();
  }

  $rect <730,250,940,290>
  method bool OperatorsCorrectlyUsed( arg string expression )
  {
    var int32 i = 0;

    if( expression != "" )
    {  
      for ( ; i < expression.length; i++ )
      {
       if (i == 0)
        {
          if ( !((expression[i] >= '0' && expression[i] <= '9') || expression[i] == '-' || expression[i] == '(') )
          {
            return false; 
          }
        }
        else
        {
          if ( expression[i] == '-' && IsOperator(expression[i - 1]) && !IsDigit(expression[i + 1]) )
          {
              return false;
          }
          if ( IsOperator(expression[i]) && IsOperator(expression[i - 1]) && expression[i - 1] == '-' && expression[i] == '-' )
          {
            return false; 
          }
          if ( expression[i] == '.' && expression[i - 1] == '.' )
          {
            return false; 
          }
          
          if ( i == expression.length - 1 && IsOperator(expression[i]) )
          {
            return false;  
          }
        }
      }
    }

    return true;
  }

  $rect <730,100,930,140>
  method bool IsParenthesis( arg char op )
  {
    if( op == '(' || op == ')')
      return true;

    return false;
  }

  $rect <730,150,930,190>
  method bool CharactersAllowed( arg string expression )
  {
    var int32 i = 0;

    for( ; i < expression.length; i++ )
    {
      if ( IsOperator(expression[i]) == false && IsParenthesis(expression[i]) == false && IsDigit(expression[i]) == false
          && IsWhiteSpace(expression[i]) == false )
        return false;
    }

    return true;
  }

  $rect <730,450,930,490>
  method bool IsWhiteSpace( arg char op )
  {
    return ( op == ' ' || op == '\t' );
  }

  $rect <20,20,160,60>
  object Application::ErrorDialog ErrorDialog
  {
    preset StackingPriority = 3;
    preset Bounds = <-270,207,-20,307>;
    preset Visible = false;
    preset OnCloseDialog = onDialogHandled;
  }

  $rect <1050,280,1250,320>
  slot onOpenDialog
  {
    Int32Effect.Enabled = true;
    ErrorDialog.Visible = true;
    ErrorDialog.Bounds.x = 45;
    ErrorDialog.OnCloseDialog = onDialogHandled;
  }

  $rect <1050,330,1250,370>
  slot onDialogHandled
  {
    ErrorDialog.Bounds.x = -270;
    ErrorDialog.Visible = false;
  }

  $rect <1050,230,1250,270>
  inherited method Init()
  {
    signal BatteryDialog.onUseBattery;
  }

  $rect <20,20,160,60>
  object Application::Battery BatteryDialog
  {
    preset Bounds = <110,144,230,199>;
    preset Visible = true;
  }

  $rect <1050,380,1250,420>
  object Effects::Int32Effect Int32Effect
  {
    preset NoOfCycles = 3;
    preset CycleDuration = 400;
    preset InterCycleDelay = 0;
    preset Enabled = true;
    preset Value1 = 155;
    preset Outlet = ^ErrorDialog.Opacity;
  }

  // Validations
  note group Note1
  {
    attr Bounds = <690,0,980,670>;
  }

  // Error Dialog
  note group Note2
  {
    attr Bounds = <1000,180,1290,450>;
  }

  // Get Methods
  note group Note3
  {
    attr Bounds = <1000,0,1290,160>;
  }

  $rect <730,550,930,590>
  method bool IsNumber( arg string expression )
  {
    var int32 i = 0;

    for( ; i < expression.length ; i++ )
    {
      if( !IsDigit(expression[i]) && !IsDot(expression[i]) )
      {
        return false;
      }
    }

    return true;
  }

  $rect <730,500,930,540>
  method bool IsDot( arg char op )
  {
    return op == '.';
  }

  $rect <420,320,630,360>
  method Application::StrVector TokenizeExpression( arg string expression )
  {
    var Application::StrVector tokens = new Application::StrVector;
    var int32 i = 0;

    for ( ; i < expression.length; i++ )  
    {
        if ( IsSpace(expression[i]) )
        {
            continue;
        }
        else if ( IsDigit(expression[i]) || (expression[i] == '.' && IsDigit(expression[i + 1])) ||
                 (expression[i] == '-' && (i == 0 || IsOperator(expression[i - 1]) || expression[i - 1] == '(') && (IsDigit(expression[i + 1]) || expression[i + 1] == '.')) )
        {
            var Application::Tuple gr = GetNumberFromPosition(i, expression);
            var string number = gr.IdentifiedNumber;
            i = gr.EndPosition;
            tokens.PushBack(number);
            continue;    
        }
        else if ( IsOperator(expression[i]) || IsParenthesis(expression[i]) )
        {
            var string c = "";
            c = expression[i];
            tokens.PushBack(c);
            continue;
        }
        else
        {
            continue;
        }
    }

    return tokens;



  }

  $rect <730,400,930,440>
  method bool IsSpace( arg char op )
  {
    return op == '\0' || op == '\t' || op =='\n';
  }

  $rect <420,270,640,310>
  method Application::StrVector ShuntingYardAlgorithm( arg string expression )
  {
    var Application::StrVector tokens  = new Application::StrVector;
    var Application::StrQueue output = new Application::StrQueue;
    var Application::StrStack operators = new Application::StrStack;

    tokens = TokenizeExpression( expression );
    var Application::StringElement token = tokens.Front;

    while( token != null )
    {
      if( token.DataStr.length == 1 )
      {
        var char t = token.DataStr[0];
        if( IsDigit(t) )
        {
          output.Push(token.DataStr);
          output.Print();
        }
        else if( IsParenthesis(t) )
        {
          if( t == '(')
          {
            operators.Push("(");
          }
          else if( t == ')')
          {
            while ( !operators.IsEmpty() && operators.GetTop() != "(" )
            {
              output.Push(operators.GetTop());
              operators.Pop();
            }
            if( !operators.IsEmpty() )
            {
              operators.Pop();
            }
          }
        }
        else if ( IsOperator(t) )
        {
          if( !operators.IsEmpty() )
          {
            var char top = operators.GetTop()[0];
            if( IsOperator(top) )
            {   
              while( !operators.IsEmpty() && operators.GetTop() != "(" && 
                  (GetPriorityOfOperator(top) == GetPriorityOfOperator(t) || GetPriorityOfOperator(top) > GetPriorityOfOperator(t)) )
              {
                output.Push(operators.GetTop());
                operators.Pop();
              }
              operators.Push(token.DataStr);
            }
            if( top == '(' )
            {
              operators.Push(token.DataStr);
            }
          }
          else
          {
            operators.Push(token.DataStr);
          }
        }   
      }
      else if( IsNumber(token.DataStr) || IsNegativeNumber(token.DataStr) )
      {
        output.Push(token.DataStr);
      }

      token = token.Next;
    }

    while( !operators.IsEmpty() )
    {
      output.Push(operators.GetTop());
      operators.Pop();
    }

    var Application::StrVector expr  = new Application::StrVector;
    var Application::SimpleStringElement aux = output.Front;

    while( aux != null )
    {
      expr.PushBack(aux.DataStr);
      aux = aux.Next;
    }
    aux = null;

    return expr;

  }

  $rect <420,220,640,260>
  method string EvaluateRPN( arg string expression )
  {
    var Application::StrVector RPN  = new Application::StrVector;
    var Application::FloatStack stk = new Application::FloatStack;
    var float firstOp;
    var float secondOp;

    RPN = ShuntingYardAlgorithm( expression );
    var Application::StringElement token = RPN.Front;

    while( token != null )
    {
      if( IsOperator(token.DataStr[0]) && !IsNegativeNumber(token.DataStr) )
      {
        secondOp = stk.GetTop();
        stk.Pop();
        firstOp = stk.GetTop();
        stk.Pop();
        stk.Push(ExecTwoOp(firstOp, secondOp, token.DataStr[0]));
      }
      else 
      {
        stk.Push(token.DataStr.parse_float( -1.0 ));
      }
      token = token.Next;
    }

    var string result = "";
    result = stk.GetTop();

    return result;
  }

  $rect <730,600,930,640>
  method bool IsNegativeNumber( arg string expression )
  {
    var string subexpr = expression.right(expression.length - 1);

    if( expression[0] == '-' && IsNumber(subexpr) && expression.length > 1)
    {
      return true;
    }

    return false;
  }

  $rect <1010,610,1210,650>
  method void PowerOff()
  {
    BatteryDialog.Int32Effect.Enabled = true;
    TurnScreenOff();
    ResetVariables();
  }

  $rect <1010,510,1210,550>
  object Core::PropertyObserver BatteryLevelObserver
  {
    preset OnEvent = onBatteryOut;
    preset Outlet = ^BatteryDialog.BatteryPercentage;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver' \
  // is notified.
  $rect <1010,560,1210,600>
  slot onBatteryOut
  {
    if( BatteryDialog.BatteryPercentage == 0 )
    {
      PowerOff();
    }
  }

  $rect <1380,40,1580,80>
  var color ScreenOn = #CFE4F8FF;

  $rect <1380,90,1580,130>
  var color ScreenOnB = #99A8B7FF;

  $rect <1380,140,1580,180>
  var color ScreenT = #FFFFFFFF;

  $rect <1380,190,1580,230>
  var color ScreenOff = #4E555CFF;

  $rect <1380,240,1580,280>
  var color ScreenOffBL = #948F64FF;

  $rect <1380,290,1580,330>
  var color ScreenOffBR = #9E986AFF;

  // Screen Colors & Methods
  note group Note4
  {
    attr Bounds = <1330,0,1620,450>;
  }

  $rect <20,20,160,60>
  object Application::ChangeBattery ReplaceBatteryDialog
  {
    preset Bounds = <-151,138,-21,203>;
    preset Visible = false;
  }

  $rect <1220,510,1410,550>
  object Core::PropertyObserver StateObserver
  {
    preset OnEvent = onStateTrue;
    preset Outlet = ^BatteryDialog.State;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver' \
  // is notified.
  $rect <1210,560,1410,600>
  slot onStateTrue
  {
    if ( BatteryDialog.State == true )
    {
      BatteryDialog.Visible = false;
      ReplaceBatteryDialog.Visible = true;
      ReplaceBatteryDialog.Bounds.x = 105;
      ReplaceBatteryDialog.Text.String = "add new battery..";
      ReplaceBatteryDialog.Enabled = true; 
    }
  }

  $rect <1380,340,1580,380>
  method void TurnScreenOn()
  {
    OutputBgk.Color = ScreenOn;
    OutputBgk.ColorBL = ScreenOnB;
    OutputBgk.ColorBR = ScreenOnB;
  }

  $rect <1380,390,1580,430>
  method void TurnScreenOff()
  {
    OutputBgk.Color = ScreenOff;
    OutputBgk.ColorBL = ScreenOffBL;
    OutputBgk.ColorBR = ScreenOffBR;
  }

  // Battery Dialog
  note group Note5
  {
    attr Bounds = <1000,470,1630,660>;
  }

  $rect <1420,510,1620,550>
  object Core::PropertyObserver NewBatteryObserver
  {
    preset OnEvent = onValidBattery;
    preset Outlet = ^ReplaceBatteryDialog.NewBatteryLvl;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver' \
  // is notified.
  $rect <1420,560,1620,600>
  slot onValidBattery
  {
    if( ReplaceBatteryDialog.NewBatteryLvl >= 20 || ReplaceBatteryDialog.Enabled == false)
    {
      PowerOn();
    }
    else if ( ReplaceBatteryDialog.NewBatteryLvl < 20)
    {
      signal onOpenDialog;
      ErrorDialog.ErrorText.String = "Battery not charged.";
    }
  }

  $rect <1210,610,1410,650>
  method void PowerOn()
  {
    KeyHandler.Enabled = true;
    TurnScreenOn();
    ResetVariables();
    BatteryDialog.State = false;
    BatteryDialog.BatteryPercentage = ReplaceBatteryDialog.NewBatteryLvl;
    BatteryDialog.Text.Color = BatteryDialog.Green;
    BatteryDialog.Visible = true; 
    BatteryDialog.Enabled = true;
    Keypad.StackingPriority = 3;
  }

  $rect <420,420,620,460>
  method string RemoveExtraSymbols( arg string expression )
  {
    var int32 i = 0;
    var string cleanExpression = "";

    for( ; i < expression.length; i++ )
    {
      if( expression [i] == '%' && ( expression[i + 1] == '%' || expression[i + 1] == '^' ))
      {
        continue;
      }
      cleanExpression += expression[i];
    }

    return cleanExpression;
  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Init
  $member Bounds
  $member KeyHandlerNote
  $member ScreenOn
  $member ScreenOnB
  $member ScreenT
  $member ScreenOff
  $member ScreenOffBL
  $member ScreenOffBR
  $member Bgk
  $member OutputBgk
  $member Border
  $member Text
  $member Keypad
  $member KeyHandler
  $member CalculateExpression
  $member ExecTwoOp
  $member ResetVariables
  $member IsOperator
  $member Note
  $member GetPriorityOfOperator
  $member GetNumberFromPosition
  $member IsExpressionValid
  $member IsDigit
  $member CorrectParentheses
  $member OperatorsCorrectlyUsed
  $member IsParenthesis
  $member CharactersAllowed
  $member IsWhiteSpace
  $member IsNumber
  $member IsDot
  $member IsNegativeNumber
  $member IsSpace
  $member TokenizeExpression
  $member ShuntingYardAlgorithm
  $member EvaluateRPN
  $member ErrorDialog
  $member onOpenDialog
  $member onDialogHandled
  $member BatteryDialog
  $member Int32Effect
  $member Note1
  $member Note2
  $member Note3
  $member Note4
  $member PowerOff
  $member BatteryLevelObserver
  $member onBatteryOut
  $member ReplaceBatteryDialog
  $member StateObserver
  $member onStateTrue
  $member TurnScreenOn
  $member TurnScreenOff
  $member Note5
  $member NewBatteryObserver
  $member onValidBattery
  $member PowerOn
  $member RemoveExtraSymbols
}

$rect <460,20,660,60>
$output false
resource Resources::Font NumFont
{
  attr fontname FontName = Book Antiqua;
  attr fontheight Height = 50;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <460,120,660,160>
$output false
resource Resources::Font DigitalResFont
{
  attr fontname FontName = Digital-7;
  attr fontheight Height = 60;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <-300,130,-100,170>
$output false
class NumKeyBtns : Core::Group
{
  $rect <340,370,540,410>
  inherited property Bounds = <0,0,300,440>;

  $rect <360,100,560,140>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <360,50,560,90>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );
  }

  $rect <870,40,1110,80>
  object WidgetSet::PushButtonConfig DigitOpConfig
  {
    preset KeyCode = Core::KeyCode.NoKey;
    preset AccentColorFocused = #03040000;
    preset AccentColorDefault = #00000000;
    preset AccentLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset LabelColorActive = #8E6B74FF;
    preset LabelColorFocused = #8E6B74FF;
    preset LabelColorDisabled = #8E6B74FF;
    preset LabelColorDefault = #000000FF;
    preset LabelFont = Application::NumFont;
    preset FaceLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset FaceFrameActive = 1;
    preset FaceFrameFocused = 1;
    preset FaceFrameDisabled = 0;
    preset FaceFrameDefault = 0;
    preset FaceBitmapActive = Application::CustomBtn;
    preset FaceBitmapFocused = Application::CustomBtn;
    preset FaceBitmapDisabled = Application::CustomBtn;
    preset FaceBitmapDefault = Application::CustomBtn;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Two
  {
    preset Bounds = <80,150,150,220>;
    preset OnActivate = onActivateKey;
    preset Label = "2";
    preset Appearance = DigitOpConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Three
  {
    preset Bounds = <151,150,221,220>;
    preset OnActivate = onActivateKey;
    preset Label = "3";
    preset Appearance = DigitOpConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Four
  {
    preset Bounds = <10,220,80,290>;
    preset OnActivate = onActivateKey;
    preset Label = "4";
    preset Appearance = DigitOpConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Five
  {
    preset Bounds = <80,220,150,290>;
    preset OnActivate = onActivateKey;
    preset Label = "5";
    preset Appearance = DigitOpConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Six
  {
    preset Bounds = <150,220,220,290>;
    preset OnActivate = onActivateKey;
    preset Label = "6";
    preset Appearance = DigitOpConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Seven
  {
    preset Bounds = <10,290,80,360>;
    preset OnActivate = onActivateKey;
    preset Label = "7";
    preset Appearance = DigitOpConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Eight
  {
    preset Bounds = <80,290,150,360>;
    preset OnActivate = onActivateKey;
    preset Label = "8";
    preset Appearance = DigitOpConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Nine
  {
    preset Bounds = <150,290,220,360>;
    preset OnActivate = onActivateKey;
    preset Label = "9";
    preset Appearance = DigitOpConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Zero
  {
    preset Bounds = <80,360,150,430>;
    preset OnActivate = onActivateKey;
    preset Label = "0";
    preset Appearance = DigitOpConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Clear
  {
    preset Bounds = <10,7,80,77>;
    preset OnActivate = onActivateKey;
    preset Label = "C";
    preset Appearance = MultiplyConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Equals
  {
    preset Bounds = <149,360,293,428>;
    preset OnActivate = onActivateKey;
    preset Label = "=";
    preset Appearance = EqualsConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Plus
  {
    preset Bounds = <222,290,292,360>;
    preset OnActivate = onActivateKey;
    preset Label = "+";
    preset Appearance = DigitOpBoldConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Minus
  {
    preset Bounds = <223,220,293,290>;
    preset OnActivate = onActivateKey;
    preset Label = "-";
    preset Appearance = MultiplyConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Multiply
  {
    preset Bounds = <221,150,291,220>;
    preset OnActivate = onActivateKey;
    preset Label = "x";
    preset Appearance = MultiplyConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Divide
  {
    preset Bounds = <222,80,292,150>;
    preset OnActivate = onActivateKey;
    preset Label = "/";
    preset Appearance = DivideConfig;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset StackingPriority = -1;
    preset Bounds = <0,1,300,440>;
    preset Radius = 5;
    preset Width = 2;
    preset Color = #030324FF;
  }

  $rect <870,290,1110,330>
  object WidgetSet::PushButtonConfig EqualsConfig
  {
    preset OnUpdate = null;
    preset KeyCode = Core::KeyCode.Equals;
    preset LabelColorActive = #FFFCFEFF;
    preset LabelColorFocused = #FFFCFEFF;
    preset LabelColorDisabled = #FFFCFEFF;
    preset LabelColorDefault = #990002FF;
    preset LabelFont = Application::EqFont;
    preset FaceFrameActive = 1;
    preset FaceFrameFocused = 1;
    preset FaceFrameDisabled = 0;
    preset FaceFrameDefault = 0;
    preset FaceBitmapActive = Application::EqualsBtn;
    preset FaceBitmapFocused = Application::EqualsBtn;
    preset FaceBitmapDisabled = Application::EqualsBtn;
    preset FaceBitmapDefault = Application::EqualsBtn;
  }

  $rect <360,150,560,190>
  slot onActivateKey
  {
    sender; /* the method is called from the sender object */
    var WidgetSet::PushButton currentSender = ( WidgetSet::PushButton )sender;

    if ( currentSender != null ) 
    {
      keyString = currentSender.Label;
      var char charCode = '\0';
      var Core::KeyCode keyCode = Core::KeyCode.NoKey;

      if ( keyString != "" ) 
      {   
        charCode = keyString[0];
        if ( charCode != '\0' && keyCode == Core::KeyCode.NoKey ) 
        {
          GetRoot().DriveKeyboardHitting(Core::KeyCode.NoKey, charCode, true);
          GetRoot().DriveKeyboardHitting(Core::KeyCode.NoKey, charCode, false);
        }

        if ( keyCode != Core::KeyCode.NoKey ) 
        {
          GetRoot().DriveKeyboardHitting(keyCode, '\0', true);
          GetRoot().DriveKeyboardHitting(keyCode, '\0', false);
        }

      } 
      else
        trace "textKeyView is null";
    } 
    else 
        trace "focusedView is null";
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Dot
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <9,360,79,430>;
    preset OnActivate = onActivateKey;
    preset Label = ".";
    preset Appearance = DigitOpConfig;
  }

  $rect <360,290,560,330>
  object Core::Timer FlashKeyTimer
  {
    preset OnTrigger = triggerTimer;
    preset Period = 0;
    preset Begin = 100;
    preset Enabled = false;
  }

  $rect <600,290,800,330>
  slot triggerTimer
  {
    sender; /* the method is called from the sender object */
    InvalidateViewState();
  }

  // Flash effect
  note group Note
  {
    attr Bounds = <340,240,820,360>;
  }

  // Handling pressed key
  note group Note1
  {
    attr Bounds = <340,0,820,220>;
  }

  // Push Button Configurations
  note group Note2
  {
    attr Bounds = <840,0,1140,500>;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton empty00
  {
    preset Bounds = <1189,145,1254,195>;
    preset Label = "Caption";
    preset Appearance = DigitOpConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton One
  {
    preset Bounds = <10,150,80,220>;
    preset OnActivate = onActivateKey;
    preset Label = "1";
    preset Appearance = DigitOpConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Power
  {
    preset Bounds = <80,80,150,150>;
    preset OnActivate = onActivateKey;
    preset IconFrameActive = 1;
    preset IconFrameFocused = 1;
    preset IconFrameDefault = 0;
    preset IconFrame = 0;
    preset Icon = null;
    preset Label = "^";
    preset Appearance = PowConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Percentage
  {
    preset Bounds = <150,79,220,149>;
    preset OnActivate = onActivateKey;
    preset Label = "%";
    preset Appearance = PercentConfig;
  }

  $rect <870,140,1110,180>
  object WidgetSet::PushButtonConfig PowConfig
  {
    preset KeyCode = Core::KeyCode.Power;
    preset IconMarginBottom = 2;
    preset IconMarginTop = 2;
    preset IconMarginRight = 2;
    preset IconMarginLeft = 2;
    preset IconAlignment = Views::ImageAlignment[AlignHorzCenter, AlignVertCenter];
    preset FaceFrameActive = 1;
    preset FaceFrameFocused = 1;
    preset FaceFrameDisabled = 0;
    preset FaceFrameDefault = 0;
    preset FaceBitmapActive = Application::PowBtn;
    preset FaceBitmapFocused = Application::PowBtn;
    preset FaceBitmapDisabled = Application::PowBtn;
    preset FaceBitmapDefault = Application::PowBtn;
  }

  $rect <870,190,1110,230>
  object WidgetSet::PushButtonConfig PercentConfig
  {
    preset KeyCode = Core::KeyCode.NoKey;
    preset FaceFrameActive = 1;
    preset FaceFrameFocused = 1;
    preset FaceFrameDisabled = 0;
    preset FaceFrameDefault = 0;
    preset FaceBitmapActive = Application::PercentBtn;
    preset FaceBitmapFocused = Application::PercentBtn;
    preset FaceBitmapDisabled = Application::PercentBtn;
    preset FaceBitmapDefault = Application::PercentBtn;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton empty01
  {
    preset Bounds = <1189,5,1254,55>;
    preset Label = "Caption";
    preset Appearance = PowConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton empty02
  {
    preset Bounds = <1189,75,1254,125>;
    preset Label = "Caption";
    preset Appearance = PercentConfig;
  }

  $rect <870,90,1110,130>
  object WidgetSet::PushButtonConfig DigitOpBoldConfig
  {
    preset KeyCode = Core::KeyCode.NoKey;
    preset AccentColorFocused = #03040000;
    preset AccentColorDefault = #00000000;
    preset AccentLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset LabelColorActive = #8E6B74FF;
    preset LabelColorFocused = #8E6B74FF;
    preset LabelColorDisabled = #8E6B74FF;
    preset LabelColorDefault = #000000FF;
    preset LabelFont = Application::NumBoldFont;
    preset FaceLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset FaceFrameActive = 1;
    preset FaceFrameFocused = 1;
    preset FaceFrameDisabled = 0;
    preset FaceFrameDefault = 0;
    preset FaceBitmapActive = Application::CustomBtn;
    preset FaceBitmapFocused = Application::CustomBtn;
    preset FaceBitmapDisabled = Application::CustomBtn;
    preset FaceBitmapDefault = Application::CustomBtn;
  }

  $rect <870,240,1110,280>
  object WidgetSet::PushButtonConfig DivideConfig
  {
    preset KeyCode = Core::KeyCode.Divide;
    preset FaceFrameActive = 1;
    preset FaceFrameFocused = 1;
    preset FaceFrameDisabled = 0;
    preset FaceFrameDefault = 0;
    preset FaceBitmapActive = Application::DivideBtn;
    preset FaceBitmapFocused = Application::DivideBtn;
    preset FaceBitmapDisabled = Application::DivideBtn;
    preset FaceBitmapDefault = Application::DivideBtn;
  }

  $rect <870,340,1110,380>
  object WidgetSet::PushButtonConfig MultiplyConfig
  {
    preset KeyCode = Core::KeyCode.Multiply;
    preset AccentColorFocused = #03040000;
    preset AccentColorDefault = #00000000;
    preset AccentLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset LabelColorActive = #8E6B74FF;
    preset LabelColorFocused = #8E6B74FF;
    preset LabelColorDisabled = #8E6B74FF;
    preset LabelColorDefault = #000000FF;
    preset LabelFont = Application::MultiplyFont;
    preset FaceLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset FaceFrameActive = 1;
    preset FaceFrameFocused = 1;
    preset FaceFrameDisabled = 0;
    preset FaceFrameDefault = 0;
    preset FaceBitmapActive = Application::CustomBtn;
    preset FaceBitmapFocused = Application::CustomBtn;
    preset FaceBitmapDisabled = Application::CustomBtn;
    preset FaceBitmapDefault = Application::CustomBtn;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton OpenParanthesis
  {
    preset Bounds = <10,80,45,150>;
    preset OnActivate = onActivateKey;
    preset Label = "(";
    preset Appearance = ParanthesisConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton ClosedParanthesis
  {
    preset Bounds = <45,80,80,150>;
    preset OnActivate = onActivateKey;
    preset Label = ")";
    preset Appearance = ParanthesisConfig;
  }

  $rect <870,390,1110,430>
  object WidgetSet::PushButtonConfig ParanthesisConfig
  {
    preset KeyCode = Core::KeyCode.NoKey;
    preset AccentColorFocused = #03040000;
    preset AccentColorDefault = #00000000;
    preset AccentLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset LabelColorActive = #FFFCFEFF;
    preset LabelColorFocused = #FFFCFEFF;
    preset LabelColorDisabled = #FFFCFEFF;
    preset LabelColorDefault = #000000FF;
    preset LabelFont = Application::NumFont;
    preset FaceLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset FaceFrameActive = 1;
    preset FaceFrameFocused = 1;
    preset FaceFrameDisabled = 0;
    preset FaceFrameDefault = 0;
    preset FaceBitmapActive = Application::ParenthesisBtn;
    preset FaceBitmapFocused = Application::ParenthesisBtn;
    preset FaceBitmapDisabled = Application::ParenthesisBtn;
    preset FaceBitmapDefault = Application::ParenthesisBtn;
  }

  $rect <870,440,1110,480>
  object WidgetSet::PushButtonConfig BackConfig
  {
    preset KeyCode = Core::KeyCode.Backspace;
    preset FaceFrameActive = 1;
    preset FaceFrameFocused = 1;
    preset FaceFrameDisabled = 0;
    preset FaceFrameDefault = 0;
    preset FaceBitmapActive = Application::BackBtn;
    preset FaceBitmapFocused = Application::BackBtn;
    preset FaceBitmapDisabled = Application::BackBtn;
    preset FaceBitmapDefault = Application::BackBtn;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton BackBtn
  {
    preset Bounds = <222,7,292,77>;
    preset OnActivate = onActivateKey;
    preset Label = "B";
    preset Appearance = BackConfig;
  }

  $rect <590,50,790,90>
  property string keyString;

  $rect <590,90,790,130>
  onset keyString
  {
    // The value doesn't change - nothing to do.
    if ( pure keyString == value )
      return;

    // Remember the property's new value.
    pure keyString = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <590,130,790,170>
  onget keyString
  {
    return pure keyString;
  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Bounds
  $member UpdateLayout
  $member UpdateViewState
  $member Border
  $member DigitOpConfig
  $member EqualsConfig
  $member onActivateKey
  $member FlashKeyTimer
  $member triggerTimer
  $member Note
  $member Note1
  $member Note2
  $member empty00
  $member empty01
  $member empty02
  $member One
  $member Two
  $member Three
  $member Four
  $member Five
  $member Six
  $member Seven
  $member Eight
  $member Nine
  $member Zero
  $member Clear
  $member Plus
  $member Minus
  $member Multiply
  $member Divide
  $member Dot
  $member Power
  $member Percentage
  $member OpenParanthesis
  $member ClosedParanthesis
  $member Equals
  $member PowConfig
  $member PercentConfig
  $member DigitOpBoldConfig
  $member DivideConfig
  $member MultiplyConfig
  $member ParanthesisConfig
  $member BackConfig
  $member BackBtn
  $member keyString
  $member OnSetkeyString
  $member OnGetkeyString
}

$rect <-37,340,163,380>
$output false
resource Resources::Bitmap CustomBtn
{
  attr bitmapfile FileName = .\resources\buttons.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <70,70>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <-37,390,163,430>
$output false
resource Resources::Bitmap EqualsBtn
{
  attr bitmapfile FileName = .\resources\equals.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <140,70>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <460,170,660,210>
$output false
resource Resources::Font EqFont
{
  attr fontname FontName = Book Antiqua;
  attr fontheight Height = 90;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <-37,440,163,480>
$output false
resource Resources::Bitmap PercentBtn
{
  attr bitmapfile FileName = .\resources\percent.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <70,70>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <-37,490,163,530>
$output false
resource Resources::Bitmap PowBtn
{
  attr bitmapfile FileName = .\resources\pow.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <70,70>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// Components
note group Note
{
  attr Bounds = <-330,90,-80,340>;
}

// Bitmaps
note group Note1
{
  attr Bounds = <-60,300,420,700>;
}

// Fonts
note group Note2
{
  attr Bounds = <440,-20,680,480>;
}

// Application
note group Note3
{
  attr Bounds = <-330,-20,-80,80>;
}

$rect <460,70,660,110>
$output false
resource Resources::Font NumBoldFont
{
  attr fontname FontName = Book Antiqua;
  attr fontheight Height = 50;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <-40,539,160,579>
$output false
resource Resources::Bitmap DivideBtn
{
  attr bitmapfile FileName = .\resources\divide.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <70,70>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <460,270,660,310>
$output false
resource Resources::Font MultiplyFont
{
  attr fontname FontName = Consolas;
  attr fontheight Height = 50;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <200,230,400,270>
$output false
class Tuple
{
  $rect <239,-10,439,30>
  property float IdentifiedNumber;

  $rect <239,30,439,70>
  onset IdentifiedNumber
  {
    // The value doesn't change - nothing to do.
    if ( pure IdentifiedNumber == value )
      return;

    // Remember the property's new value.
    pure IdentifiedNumber = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <239,70,439,110>
  onget IdentifiedNumber
  {
    return pure IdentifiedNumber;
  }

  $rect <240,120,440,160>
  property int32 EndPosition = -1;

  $rect <240,160,440,200>
  onset EndPosition
  {
    // The value doesn't change - nothing to do.
    if ( pure EndPosition == value )
      return;

    // Remember the property's new value.
    pure EndPosition = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <240,200,440,240>
  onget EndPosition
  {
    return pure EndPosition;
  }

  $rect <480,-10,680,30>
  property string Subexpression = "none";

  $rect <480,30,680,70>
  onset Subexpression
  {
    // The value doesn't change - nothing to do.
    if ( pure Subexpression == value )
      return;

    // Remember the property's new value.
    pure Subexpression = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <480,70,680,110>
  onget Subexpression
  {
    return pure Subexpression;
  }

  $rect <10,10,160,50>
  inherited method Init()
  {
    aArg;
    IdentifiedNumber = float_infp();
    EndPosition = -1;
    Subexpression = "none";
  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Init
  $member IdentifiedNumber
  $member OnSetIdentifiedNumber
  $member OnGetIdentifiedNumber
  $member EndPosition
  $member OnSetEndPosition
  $member OnGetEndPosition
  $member Subexpression
  $member OnSetSubexpression
  $member OnGetSubexpression
}

$rect <-300,180,-100,220>
$output false
class ErrorDialog : Core::Group
{
  $rect <20,130,220,170>
  inherited property Bounds = <0,0,250,100>;

  $rect <20,20,160,60>
  object Views::Rectangle Bgk
  {
    preset Bounds = <0,0,250,100>;
    preset Radius = 3;
    preset Color = #E2E6E9FF;
  }

  $rect <20,20,160,60>
  object Views::Border BgkBorder
  {
    preset Bounds = <0,-1,250,100>;
    preset Radius = 3;
    preset Width = 2;
    preset Color = #470400FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle TopBar
  {
    preset Bounds = <0,0,250,30>;
    preset RadiusTR = 3;
    preset RadiusTL = 3;
    preset Radius = 3;
    preset Color = #990002FF;
  }

  $rect <20,20,160,60>
  object Views::Border TopBarBgk
  {
    preset Bounds = <0,0,250,30>;
    preset Width = 2;
    preset Color = #460400FF;
  }

  $rect <630,40,870,80>
  object WidgetSet::PushButtonConfig ExitBtnConfig
  {
    preset KeyCode = Core::KeyCode.Enter;
    preset LabelColorActive = #FFFFFFFF;
    preset LabelColorDisabled = #FFFFFFFF;
    preset LabelColorDefault = #000000FF;
    preset LabelMarginBottom = 3;
    preset LabelAlignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset LabelFont = Application::BtnFont;
  }

  $rect <20,20,160,60>
  object Views::Text ErrorText
  {
    preset Bounds = <5,38,235,78>;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertTop];
    preset String = "no errors";
    preset Font = Application::ErrorFont;
    preset Color = #2D0200FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <213,3,243,28>;
    preset OnActivate = onClose;
    preset Label = "X";
    preset Appearance = ExitBtnConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <159,61,243,91>;
    preset OnActivate = onClose;
    preset Label = "OK";
    preset Appearance = OkBtnConfig;
  }

  $rect <630,90,870,130>
  object WidgetSet::PushButtonConfig OkBtnConfig
  {
    preset KeyCode = Core::KeyCode.Enter;
    preset ThumbBorderColorActive = #20943100;
    preset ThumbBorderColorDefault = #3A842A00;
    preset ThumbBorderWidthActive = 0;
    preset ThumbBorderWidthDefault = 0;
    preset ThumbColorActive = #CC7E5100;
    preset ThumbColorDefault = #B7321F00;
    preset ThumbLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset LabelColorActive = #FFFFFFFF;
    preset LabelColorDisabled = #FFFFFFFF;
    preset LabelColorDefault = #000000FF;
    preset LabelMarginBottom = 3;
    preset LabelAlignment = Views::TextAlignment[AlignHorzAuto, AlignHorzCenter, AlignVertCenter];
    preset LabelFont = Application::BtnFont;
    preset FaceFrameActive = 1;
    preset FaceFrameFocused = 1;
    preset FaceFrameDisabled = 0;
    preset FaceFrameDefault = 0;
    preset FaceBitmapActive = Application::OKBtn;
    preset FaceBitmapFocused = Application::OKBtn;
    preset FaceBitmapDisabled = Application::OKBtn;
    preset FaceBitmapDefault = Application::OKBtn;
  }

  $rect <330,90,530,130>
  slot onClose
  {
    idlesignal OnCloseDialog;
  }

  $rect <330,40,530,80>
  property slot OnCloseDialog = null;

  $rect <20,20,160,60>
  object Views::Text Title
  {
    preset Bounds = <5,0,145,30>;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter, AlignVertTop];
    preset String = "CALCULATOR ERROR";
    preset Font = Application::ErrorFont;
    preset Color = #F2E6DDFF;
  }

  // Button Configs
  note group Note
  {
    attr Bounds = <600,0,900,150>;
  }

  // Close Dialog
  note group Note1
  {
    attr Bounds = <280,0,580,150>;
  }
}

$rect <460,320,660,360>
$output false
resource Resources::Font ErrorFont
{
  attr fontname FontName = Asap Condensed Medium;
  attr fontheight Height = 15;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <460,370,660,410>
$output false
resource Resources::Font BtnFont
{
  attr fontname FontName = Microsoft Yi Baiti;
  attr fontheight Height = 27;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <-37,640,163,680>
$output false
resource Resources::Bitmap OKBtn
{
  attr bitmapfile FileName = .\resources\ok.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <70,30>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <-37,590,163,630>
$output false
resource Resources::Bitmap ParenthesisBtn
{
  attr bitmapfile FileName = .\resources\paranthesis.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <35,70>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <193,340,393,380>
$output false
resource Resources::Bitmap BackBtn
{
  attr bitmapfile FileName = .\resources\back.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <70,70>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <193,390,393,430>
$output false
resource Resources::Bitmap BatteryBgk
{
  attr bitmapfile FileName = .\resources\battery-filled.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <110,50>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <193,440,393,480>
$output false
resource Resources::Bitmap BatteryLine
{
  attr bitmapfile FileName = .\resources\battery-line.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <5,46>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <-300,230,-100,270>
$output false
class Battery : Core::Group
{
  $rect <140,0,340,40>
  inherited property Bounds = <0,0,120,54>;

  $rect <20,20,160,60>
  object Views::Image Bgk
  {
    preset Bounds = <5,2,115,52>;
    preset Bitmap = Application::BatteryBgk;
  }

  $rect <20,20,160,60>
  object Views::Image line1
  {
    preset Bounds = <7,4,12,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <0,350,200,390>
  slot onUseBattery
  {
    BatteryPercentage -= 0.05;
    var string str = "100";

    str = BatteryPercentage;

    if( BatteryPercentage < 50 )
    {
      Text.Color = Orange;
    }
    if ( BatteryPercentage < 20 )
    {
      Text.Color = Red;
    }

    Text.String = str;

    if( BatteryPercentage < 0 )
      BatteryPercentage = 0;

    if( BatteryPercentage < 20 )
      UpdateLowBatteryLines(BatteryPercentage);
    else
      UpdateBatteryLines(BatteryPercentage);
  }

  $rect <20,20,160,60>
  object Views::Image line2
  {
    preset Bounds = <12,4,17,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line3
  {
    preset Bounds = <17,4,22,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line4
  {
    preset Bounds = <22,4,27,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line5
  {
    preset Bounds = <27,4,32,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line6
  {
    preset Bounds = <32,4,37,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line7
  {
    preset Bounds = <37,4,42,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line8
  {
    preset Bounds = <42,4,47,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line9
  {
    preset Bounds = <47,4,52,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line10
  {
    preset Bounds = <52,4,57,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line11
  {
    preset Bounds = <57,4,62,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line12
  {
    preset Bounds = <62,4,67,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line13
  {
    preset Bounds = <67,4,72,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line14
  {
    preset Bounds = <72,4,77,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line15
  {
    preset Bounds = <77,4,82,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line16
  {
    preset Bounds = <82,4,87,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line17
  {
    preset Bounds = <87,4,92,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line18
  {
    preset Bounds = <92,4,97,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line19
  {
    preset Bounds = <97,4,102,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <20,20,160,60>
  object Views::Image line20
  {
    preset Bounds = <102,4,107,50>;
    preset Bitmap = Application::BatteryLine;
  }

  $rect <0,300,200,340>
  object Core::Timer Timer
  {
    preset OnTrigger = onUseBattery;
    preset Period = 7000;
    preset Enabled = true;
  }

  $rect <200,300,400,340>
  method void UpdateBatteryLines( arg int32 percentage )
  {
    var int32 linesToShow = percentage / 5;

    var int32 i = 0;
      
    for( ; i < 20; i++ )
    {
      if( i < linesToShow )
      {
        batteryLines[i].Visible = true;
      }
      else
      {
        batteryLines[i].Visible = false;
      }     
    }
  }

  $rect <560,0,760,40>
  array Views::Image batteryLines[ 20 ] =
  (
    Default[0] = line1;
    Default[1] = line2;
    Default[2] = line3;
    Default[3] = line4;
    Default[4] = line5;
    Default[5] = line6;
    Default[6] = line7;
    Default[7] = line8;
    Default[8] = line9;
    Default[9] = line10;
    Default[10] = line11;
    Default[11] = line12;
    Default[12] = line13;
    Default[13] = line14;
    Default[14] = line15;
    Default[15] = line16;
    Default[16] = line17;
    Default[17] = line18;
    Default[18] = line19;
    Default[19] = line20;
  );

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <13,6,97,46>;
    preset String = "";
    preset Font = Application::BatteryFont;
    preset Color = #004606FF;
  }

  $rect <20,20,160,60>
  object Views::Image low1
  {
    preset Bounds = <7,4,12,50>;
    preset Bitmap = Application::LowBattery;
    preset Visible = true;
  }

  $rect <20,20,160,60>
  object Views::Image low2
  {
    preset Bounds = <12,4,17,50>;
    preset Bitmap = Application::LowBattery;
    preset Visible = true;
  }

  $rect <20,20,160,60>
  object Views::Image low3
  {
    preset Bounds = <17,4,22,50>;
    preset Bitmap = Application::LowBattery;
    preset Visible = true;
  }

  $rect <20,20,160,60>
  object Views::Image low4
  {
    preset Bounds = <22,4,27,50>;
    preset Bitmap = Application::LowBattery;
    preset Visible = true;
  }

  $rect <350,0,550,40>
  array Views::Image lowBatteryLines[ 20 ] =
  (
    Default[0] = low1;
    Default[1] = low2;
    Default[2] = low3;
    Default[3] = low4;
    Default[4] = line5;
    Default[5] = line6;
    Default[6] = line7;
    Default[7] = line8;
    Default[8] = line9;
    Default[9] = line10;
    Default[10] = line11;
    Default[11] = line12;
    Default[12] = line13;
    Default[13] = line14;
    Default[14] = line15;
    Default[15] = line16;
    Default[16] = line17;
    Default[17] = line18;
    Default[18] = line19;
    Default[19] = line20;
  );

  $rect <200,350,420,390>
  method void UpdateLowBatteryLines( arg int32 percentage )
  {
    HideInitialLines();

    var int32 linesToShow = percentage / 5;

    var int32 i = 0;
      
    for( ; i < 20; i++ )
    {
      if( i < linesToShow )
      {
        lowBatteryLines[i].Visible = true;
      }
      else
      {
        lowBatteryLines[i].Visible = false;
      }     
    }
  }

  $rect <400,300,600,340>
  method void HideInitialLines()
  {
    batteryLines[0].Visible = false;
    batteryLines[1].Visible = false;
    batteryLines[2].Visible = false;
    batteryLines[3].Visible = false;
    batteryLines[4].Visible = false;
    batteryLines[5].Visible = false;
    batteryLines[6].Visible = false;
    batteryLines[7].Visible = false;
    batteryLines[8].Visible = false;
    batteryLines[9].Visible = false;
    batteryLines[10].Visible = false;
    batteryLines[11].Visible = false;
    batteryLines[12].Visible = false;
    batteryLines[13].Visible = false;
    batteryLines[14].Visible = false;
    batteryLines[15].Visible = false;
    batteryLines[16].Visible = false;
    batteryLines[17].Visible = false;
    batteryLines[18].Visible = false;
    batteryLines[19].Visible = false;

  }

  $rect <200,120,400,160>
  property int32 BatteryPercentage = 101;

  $rect <600,120,800,160>
  onget BatteryPercentage
  {
    // Per default return the value stored already in the property.
    return pure BatteryPercentage;

    /*

      TO DO:

      If the property should return the value stored in the underlying device
      or in the middleware, remove the above 'return' statement and instead do
      following:

      Declare a local variable to receive the value from the underlying device.
      The type of the variable has to correspond to the data type of the property.
      For example in case of an 'int32' property:
      
        var int32 result;

      Implement a native statement to access the value and to store it in the
      variable 'result'. Then return the value. For example:

        $if !$prototyper
          native ( result )
          {
            result = YourDevice_GetSomeValue();
          }
        $endif

        return result;

    */
  }

  $rect <400,120,600,160>
  onset BatteryPercentage
  {
    // The property doesn't change -> nothing to do.
    if ( pure BatteryPercentage == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure BatteryPercentage = value;

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^BatteryPercentage;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <0,120,200,160>
  $output true
  method void UpdateBatteryPercentage( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure BatteryPercentage )
    {
      // Remember the new value in the internal memory of the property.
      pure BatteryPercentage = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^BatteryPercentage;
    }
  }

  $rect <600,300,800,340>
  object Effects::Int32Effect Int32Effect
  {
    preset OnFinished = onEffectFinished;
    preset NoOfCycles = 7;
    preset CycleDuration = 500;
    preset Outlet = ^Text.Opacity;
  }

  $rect <600,350,800,390>
  slot onEffectFinished
  {
    State = true; 
  }

  $rect <200,170,400,210>
  property bool State = false;

  $rect <600,170,800,210>
  onget State
  {
    // Per default return the value stored already in the property.
    return pure State;

    /*

      TO DO:

      If the property should return the value stored in the underlying device
      or in the middleware, remove the above 'return' statement and instead do
      following:

      Declare a local variable to receive the value from the underlying device.
      The type of the variable has to correspond to the data type of the property.
      For example in case of an 'int32' property:
      
        var int32 result;

      Implement a native statement to access the value and to store it in the
      variable 'result'. Then return the value. For example:

        $if !$prototyper
          native ( result )
          {
            result = YourDevice_GetSomeValue();
          }
        $endif

        return result;

    */
  }

  $rect <400,170,600,210>
  onset State
  {
    // The property doesn't change -> nothing to do.
    if ( pure State == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure State = value;

    notifyobservers ^State;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <0,170,200,210>
  $output true
  method void UpdateState( arg bool aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure State )
    {
      // Remember the new value in the internal memory of the property.
      pure State = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^State;
    }
  }

  $rect <860,70,1060,110>
  var color Green = #004606FF;

  $rect <860,120,1060,160>
  var color Orange = #BC5F00FF;

  $rect <860,170,1060,210>
  var color Red = #CB0014FF;

  // Text Colors
  note group Note
  {
    attr Bounds = <840,30,1080,230>;
  }

  // Properties
  note group Note1
  {
    attr Bounds = <-10,80,810,230>;
  }

  // Timer, battery update & effects
  note group Note2
  {
    attr Bounds = <-10,250,810,410>;
  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Bounds
  $member Bgk
  $member low1
  $member low2
  $member low3
  $member low4
  $member line1
  $member line2
  $member line3
  $member line4
  $member line5
  $member line6
  $member line7
  $member line8
  $member line9
  $member line10
  $member line11
  $member line12
  $member line13
  $member line14
  $member line15
  $member line16
  $member line17
  $member line18
  $member line19
  $member line20
  $member onUseBattery
  $member Timer
  $member UpdateBatteryLines
  $member batteryLines
  $member Text
  $member lowBatteryLines
  $member UpdateLowBatteryLines
  $member HideInitialLines
  $member BatteryPercentage
  $member OnGetBatteryPercentage
  $member OnSetBatteryPercentage
  $member UpdateBatteryPercentage
  $member Int32Effect
  $member onEffectFinished
  $member State
  $member OnGetState
  $member OnSetState
  $member UpdateState
  $member Green
  $member Orange
  $member Red
  $member Note
  $member Note1
  $member Note2
}

$rect <200,130,400,170>
$output false
class SimpleStringElement
{
  $rect <112,67,312,107>
  property string DataStr;

  $rect <112,107,312,147>
  onset DataStr
  {
    // The value doesn't change - nothing to do.
    if ( pure DataStr == value )
      return;

    // Remember the property's new value.
    pure DataStr = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <112,147,312,187>
  onget DataStr
  {
    return pure DataStr;
  }

  $rect <350,70,550,110>
  property Application::SimpleStringElement Next;

  $rect <350,110,550,150>
  onset Next
  {
    // The value doesn't change - nothing to do.
    if ( pure Next == value )
      return;

    // Remember the property's new value.
    pure Next = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <350,150,550,190>
  onget Next
  {
    return pure Next;
  }

  // Directives to adapt the order of members belonging to this class so they appear 
  // correctly arranged relative to the members inherited from the ancestor (super) 
  // classes. The numbers indicate the order-displacement to apply on the respective 
  // member once all members have been loaded and combined with members from the 
  // ancestor classes.
  $reorder DataStr 1
  $reorder OnSetDataStr 1
  $reorder OnGetDataStr 1
}

$rect <-30,80,170,120>
$output false
class StrQueue
{
  $rect <640,150,840,190>
  method void Push( arg string aValue )
  {
    var Application::SimpleStringElement strElement = new Application::SimpleStringElement;
    strElement.DataStr = aValue;
    strElement.Next = null;

    if( Front == null )
    {
      Front = strElement;
      Back = strElement;
    }
    else
    {
      Back.Next = strElement;
      Back = strElement;
    }
  }

  $rect <640,200,840,240>
  method void Pop()
  {
    var Application::SimpleStringElement aux = Front;

    if( aux == null )
    {
      trace "Queue is empty!";
    }
    else 
    {
       Front = Front.Next;
       aux = null;
    }
  }

  $rect <880,150,1080,190>
  method string GetFront()
  {
    if( Front != null )
    {
      return Front.DataStr;
    }

    return "";
  }

  $rect <880,200,1080,240>
  method string GetBack()
  {
    if( Back != null )
    {
      return Back.DataStr;
    }

    return "";
  }

  $rect <640,300,840,340>
  method bool IsEmpty()
  {
    if( Front == null || Back == null )
    {
      return true; // queue is empty
    }

    return false;
  }

  $rect <640,250,840,290>
  method void Clear()
  {
    while( Front != null )
    {
      Pop();
    }

    Size = 0;
  }

  $rect <640,100,840,140>
  inherited method Init()
  {
    Front = null;
    Back = null;
    Size = 0;
    Empty = true;
  }

  $rect <880,100,1080,140>
  method int32 GetSize()
  {
    while( Front != null )
    {
      Size++;
      Front = Front.Next;
    }

    return Size;
  }

  $rect <880,250,1080,290>
  method void Print()
  {
    var Application::SimpleStringElement aux = Front;

    while( aux != null )
    {
      trace aux.DataStr;
      aux = aux.Next;
    }

    aux = null;
  }

  $rect <124,80,324,120>
  property Application::SimpleStringElement Front;

  $rect <124,120,324,160>
  onset Front
  {
    // The value doesn't change - nothing to do.
    if ( pure Front == value )
      return;

    // Remember the property's new value.
    pure Front = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <124,160,324,200>
  onget Front
  {
    return pure Front;
  }

  $rect <120,220,320,260>
  property Application::SimpleStringElement Back;

  $rect <120,260,320,300>
  onset Back
  {
    // The value doesn't change - nothing to do.
    if ( pure Back == value )
      return;

    // Remember the property's new value.
    pure Back = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <120,300,320,340>
  onget Back
  {
    return pure Back;
  }

  $rect <370,80,570,120>
  property int32 Size;

  $rect <370,120,570,160>
  onset Size
  {
    // The value doesn't change - nothing to do.
    if ( pure Size == value )
      return;

    // Remember the property's new value.
    pure Size = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <370,160,570,200>
  onget Size
  {
    return pure Size;
  }

  $rect <370,220,570,260>
  property bool Empty;

  $rect <370,260,570,300>
  onset Empty
  {
    // The value doesn't change - nothing to do.
    if ( pure Empty == value )
      return;

    // Remember the property's new value.
    pure Empty = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <370,300,570,340>
  onget Empty
  {
    return pure Empty;
  }

  // Properties
  note group Note
  {
    attr Bounds = <100,40,590,360>;
  }

  // Methods
  note group Note1
  {
    attr Bounds = <620,40,1110,360>;
  }

  // Directives to adapt the order of members belonging to this class so they appear 
  // correctly arranged relative to the members inherited from the ancestor (super) 
  // classes. The numbers indicate the order-displacement to apply on the respective 
  // member once all members have been loaded and combined with members from the 
  // ancestor classes.
  $reorder Push 3
  $reorder Pop 3
  $reorder GetFront 1
  $reorder GetBack 1
  $reorder IsEmpty 1
  $reorder Clear 1
}

$rect <-30,130,170,170>
$output false
class StrStack
{
  $rect <600,90,800,130>
  inherited method Init()
  {
    Top = null;
    Size = 0;
    Empty = true;
  }

  $rect <60,70,260,110>
  property Application::SimpleStringElement Top;

  $rect <60,110,260,150>
  onset Top
  {
    // The value doesn't change - nothing to do.
    if ( pure Top == value )
      return;

    // Remember the property's new value.
    pure Top = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <60,150,260,190>
  onget Top
  {
    return pure Top;
  }

  $rect <60,200,260,240>
  property int32 Size;

  $rect <60,240,260,280>
  onset Size
  {
    // The value doesn't change - nothing to do.
    if ( pure Size == value )
      return;

    // Remember the property's new value.
    pure Size = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <60,280,260,320>
  onget Size
  {
    return pure Size;
  }

  $rect <290,70,490,110>
  property bool Empty;

  $rect <290,110,490,150>
  onset Empty
  {
    // The value doesn't change - nothing to do.
    if ( pure Empty == value )
      return;

    // Remember the property's new value.
    pure Empty = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <290,150,490,190>
  onget Empty
  {
    return pure Empty;
  }

  $rect <600,140,800,180>
  method void Push( arg string aValue )
  {
    var Application::SimpleStringElement strElement = new Application::SimpleStringElement;
    strElement.DataStr = aValue;
    strElement.Next = Top;
    Top = strElement;
  }

  $rect <600,190,800,230>
  method void Pop()
  {
    var Application::SimpleStringElement aux = Top;

    if( aux == null )
    {
      trace "Stack is empty!";
    }
    else 
    {
       aux = Top;
       Top = Top.Next;
       aux = null;
    }
  }

  $rect <830,140,1030,180>
  method string GetTop()
  {
    if( Top != null ) 
    {
      return Top.DataStr;
    }

    return "";
  }

  $rect <830,90,1030,130>
  method bool IsEmpty()
  {
    if( Top == null )
    {
      return true; // Stack is empty
    }

    return false;
  }

  $rect <830,190,1030,230>
  method int32 GetSize()
  {
    while( Top != null )
    {
      Size++;
      Top = Top.Next;
    }

    return Size;
  }

  $rect <600,240,800,280>
  method void Clear()
  {
    while( Top != null )
    {
      Pop();
    }

    Size = 0;
  }

  $rect <830,240,1030,280>
  method void Print()
  {
    var Application::SimpleStringElement aux = Top;

    while( aux != null )
    {
      trace aux.DataStr;
      aux = aux.Next;
    }

    aux = null;
  }

  // Properties
  note group Note
  {
    attr Bounds = <30,20,520,340>;
  }

  // Methods
  note group Note1
  {
    attr Bounds = <560,20,1050,340>;
  }
}

$rect <200,180,400,220>
$output false
class SimpleFloatElement
{
  $rect <141,53,341,93>
  property float DataFloat;

  $rect <141,93,341,133>
  onset DataFloat
  {
    // The value doesn't change - nothing to do.
    if ( pure DataFloat == value )
      return;

    // Remember the property's new value.
    pure DataFloat = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <141,133,341,173>
  onget DataFloat
  {
    return pure DataFloat;
  }

  $rect <380,50,580,90>
  property Application::SimpleFloatElement Next;

  $rect <380,90,580,130>
  onset Next
  {
    // The value doesn't change - nothing to do.
    if ( pure Next == value )
      return;

    // Remember the property's new value.
    pure Next = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <380,130,580,170>
  onget Next
  {
    return pure Next;
  }
}

$rect <-30,180,170,220>
$output false
class FloatStack
{
  $rect <590,90,790,130>
  inherited method Init()
  {
    Top = null;
    Size = 0;
    Empty = true;
  }

  $rect <70,60,270,100>
  property Application::SimpleFloatElement Top;

  $rect <70,100,270,140>
  onset Top
  {
    // The value doesn't change - nothing to do.
    if ( pure Top == value )
      return;

    // Remember the property's new value.
    pure Top = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <70,140,270,180>
  onget Top
  {
    return pure Top;
  }

  $rect <70,200,270,240>
  property int32 Size;

  $rect <70,240,270,280>
  onset Size
  {
    // The value doesn't change - nothing to do.
    if ( pure Size == value )
      return;

    // Remember the property's new value.
    pure Size = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <70,280,270,320>
  onget Size
  {
    return pure Size;
  }

  $rect <310,60,510,100>
  property bool Empty;

  $rect <310,100,510,140>
  onset Empty
  {
    // The value doesn't change - nothing to do.
    if ( pure Empty == value )
      return;

    // Remember the property's new value.
    pure Empty = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <310,140,510,180>
  onget Empty
  {
    return pure Empty;
  }

  $rect <590,140,790,180>
  method void Push( arg float aValue )
  {
    var Application::SimpleFloatElement floatElement = new Application::SimpleFloatElement;
    floatElement.DataFloat = aValue;
    floatElement.Next = Top;
    Top = floatElement;
  }

  $rect <590,190,790,230>
  method void Pop()
  {
    var Application::SimpleFloatElement aux = Top;

    if( aux == null )
    {
      trace "Stack is empty!";
    }
    else 
    {
       aux = Top;
       Top = Top.Next;
       aux = null;
    }
  }

  $rect <830,190,1030,230>
  method float GetTop()
  {
    if( Top != null ) 
    {
      return Top.DataFloat;
    }

    return 0;
  }

  $rect <830,90,1030,130>
  method bool IsEmpty()
  {
    if( Top == null )
    {
      return true; // Stack is empty
    }

    return false;
  }

  $rect <830,140,1030,180>
  method int32 GetSize()
  {
    while( Top != null )
    {
      Size++;
      Top = Top.Next;
    }

    return Size;
  }

  $rect <590,240,790,280>
  method void Clear()
  {
    while( Top != null )
    {
      Pop();
    }

    Size = 0;
  }

  $rect <830,240,1030,280>
  method void Print()
  {
    var Application::SimpleFloatElement aux = Top;

    while( aux != null )
    {
      trace aux.DataFloat;
      aux = aux.Next;
    }

    aux = null;
  }

  // Properties
  note group Note
  {
    attr Bounds = <40,20,530,340>;
  }

  // Methods
  note group Note1
  {
    attr Bounds = <560,20,1050,340>;
  }
}

$rect <200,30,400,70>
$output false
class StringElement
{
  $rect <130,114,330,154>
  property string DataStr;

  $rect <130,154,330,194>
  onset DataStr
  {
    // The value doesn't change - nothing to do.
    if ( pure DataStr == value )
      return;

    // Remember the property's new value.
    pure DataStr = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <130,194,330,234>
  onget DataStr
  {
    return pure DataStr;
  }

  $rect <380,110,580,150>
  property Application::StringElement Next;

  $rect <380,150,580,190>
  onset Next
  {
    // The value doesn't change - nothing to do.
    if ( pure Next == value )
      return;

    // Remember the property's new value.
    pure Next = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <380,190,580,230>
  onget Next
  {
    return pure Next;
  }

  $rect <630,110,830,150>
  property Application::StringElement Prev;

  $rect <630,150,830,190>
  onset Prev
  {
    // The value doesn't change - nothing to do.
    if ( pure Prev == value )
      return;

    // Remember the property's new value.
    pure Prev = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <630,190,830,230>
  onget Prev
  {
    return pure Prev;
  }
}

$rect <-30,30,170,70>
$output false
class StrVector
{
  $rect <640,30,840,70>
  inherited method Init()
  {
    Front = null;
    Back = null;
    Size = 0;
    Empty = true;
  }

  $rect <130,20,330,60>
  property Application::StringElement Front;

  $rect <130,60,330,100>
  onset Front
  {
    // The value doesn't change - nothing to do.
    if ( pure Front == value )
      return;

    // Remember the property's new value.
    pure Front = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <130,100,330,140>
  onget Front
  {
    return pure Front;
  }

  $rect <130,160,330,200>
  property Application::StringElement Back;

  $rect <130,200,330,240>
  onset Back
  {
    // The value doesn't change - nothing to do.
    if ( pure Back == value )
      return;

    // Remember the property's new value.
    pure Back = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <130,240,330,280>
  onget Back
  {
    return pure Back;
  }

  $rect <360,20,560,60>
  property int32 Size;

  $rect <360,60,560,100>
  onset Size
  {
    // The value doesn't change - nothing to do.
    if ( pure Size == value )
      return;

    // Remember the property's new value.
    pure Size = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <360,100,560,140>
  onget Size
  {
    return pure Size;
  }

  $rect <360,160,560,200>
  property bool Empty;

  $rect <360,200,560,240>
  onset Empty
  {
    // The value doesn't change - nothing to do.
    if ( pure Empty == value )
      return;

    // Remember the property's new value.
    pure Empty = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <360,240,560,280>
  onget Empty
  {
    return pure Empty;
  }

  $rect <640,80,840,120>
  method void PushBack( arg string aValue )
  {
    var Application::StringElement strElement = new Application::StringElement;
    strElement.DataStr = aValue;
    strElement.Next = null;
    strElement.Prev = Back;

    if( Back != null )
    {
      Back.Next = strElement;
    }
    else
    {
      Front = strElement;
    }
    Back = strElement;
  }

  $rect <640,130,840,170>
  method void Pop()
  {
    if( Back != null ) 
    {
      Back = Back.Prev;
      Back.Next = null;
    }
    else
    {
      Back = null;
    }
  }

  $rect <640,180,840,220>
  method string At( arg int32 pos )
  {
    var int32 index = 0;
    var Application::StringElement aux = Front;

    while( aux != null && index != pos)
    {
      aux = aux.Next;
      index++;
    }

    return aux.DataStr;
  }

  $rect <880,30,1080,70>
  method bool IsEmpty()
  {
    if( Front == null || Back == null )
    {
      return true; // vectir is empty
    }

    return false;
  }

  $rect <880,180,1080,220>
  method int32 GetSize()
  {
    var Application::StringElement aux = Front;

    while( aux != null )
    {
      Size++;
      aux = aux.Next;
    }

    return Size;

  }

  $rect <640,230,840,270>
  method void Clear()
  {
    while( Front != Back )
    {
      Pop();
    }
    Front = null;
  }

  $rect <880,230,1080,270>
  method void Print()
  {
    var Application::StringElement aux = Front;

    while( aux != null )
    {
      trace aux.DataStr;
      aux = aux.Next;
    }

    aux = null;
  }

  $rect <880,80,1080,120>
  method string GetFront()
  {
    if( Front != null )
    {
      return Front.DataStr;
    }

    return "";
  }

  $rect <880,130,1080,170>
  method string GetBack()
  {
    if( Back != null )
    {
      return Back.DataStr;
    }

    return "";
  }

  // Properties
  note group Note
  {
    attr Bounds = <110,-20,580,300>;
  }

  // Methods
  note group Note1
  {
    attr Bounds = <610,-20,1100,300>;
  }
}

$rect <-30,230,170,270>
$output false
class CharStack
{
  $rect <590,100,790,140>
  inherited method Init()
  {
    Top = null;
    Size = 0;
    Empty = true;
  }

  $rect <60,60,260,100>
  property Application::SimpleCharElement Top;

  $rect <60,100,260,140>
  onset Top
  {
    // The value doesn't change - nothing to do.
    if ( pure Top == value )
      return;

    // Remember the property's new value.
    pure Top = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <60,140,260,180>
  onget Top
  {
    return pure Top;
  }

  $rect <60,200,260,240>
  property int32 Size;

  $rect <60,240,260,280>
  onset Size
  {
    // The value doesn't change - nothing to do.
    if ( pure Size == value )
      return;

    // Remember the property's new value.
    pure Size = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <60,280,260,320>
  onget Size
  {
    return pure Size;
  }

  $rect <300,60,500,100>
  property bool Empty;

  $rect <300,100,500,140>
  onset Empty
  {
    // The value doesn't change - nothing to do.
    if ( pure Empty == value )
      return;

    // Remember the property's new value.
    pure Empty = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <300,140,500,180>
  onget Empty
  {
    return pure Empty;
  }

  $rect <590,150,790,190>
  method void Push( arg char aValue )
  {
    var Application::SimpleCharElement charElement = new Application::SimpleCharElement;
    charElement.DataChar = aValue;
    charElement.Next = Top;
    Top = charElement;
  }

  $rect <590,200,790,240>
  method void Pop()
  {
    var Application::SimpleCharElement aux = Top;

    if( aux == null )
    {
      trace "Stack is empty!";
    }
    else 
    {
       aux = Top;
       Top = Top.Next;
       aux = null;
    }
  }

  $rect <830,150,1030,190>
  method char GetTop()
  {
    if( Top != null ) 
    {
      return Top.DataChar;
    }

    return 0;
  }

  $rect <830,100,1030,140>
  method bool IsEmpty()
  {
    if( Top == null )
    {
      return true; // Stack is empty
    }

    return false;
  }

  $rect <830,200,1030,240>
  method int32 GetSize()
  {
    while( Top != null )
    {
      Size++;
      Top = Top.Next;
    }

    return Size;
  }

  $rect <590,250,790,290>
  method void Clear()
  {
    while( Top != null )
    {
      Pop();
    }

    Size = 0;
  }

  $rect <830,250,1030,290>
  method void Print()
  {
    var Application::SimpleCharElement aux = Top;

    while( aux != null )
    {
      trace aux.DataChar;
      aux = aux.Next;
    }

    aux = null;
  }

  // Methods
  note group Note1
  {
    attr Bounds = <560,20,1050,340>;
  }

  // Properties
  note group Note
  {
    attr Bounds = <30,20,520,340>;
  }
}

$rect <200,80,400,120>
$output false
class SimpleCharElement
{
  $rect <141,53,341,93>
  property char DataChar;

  $rect <141,93,341,133>
  onset DataChar
  {
    // The value doesn't change - nothing to do.
    if ( pure DataChar == value )
      return;

    // Remember the property's new value.
    pure DataChar = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <141,133,341,173>
  onget DataChar
  {
    return pure DataChar;
  }

  $rect <380,50,580,90>
  property Application::SimpleCharElement Next;

  $rect <380,90,580,130>
  onset Next
  {
    // The value doesn't change - nothing to do.
    if ( pure Next == value )
      return;

    // Remember the property's new value.
    pure Next = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <380,130,580,170>
  onget Next
  {
    return pure Next;
  }
}

// Data Structures
note group Note4
{
  attr Bounds = <-60,-20,420,290>;
}

$rect <460,220,660,260>
$output false
resource Resources::Font BatteryFont
{
  attr fontname FontName = Digital-7;
  attr fontheight Height = 42;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <193,490,393,530>
$output false
resource Resources::Bitmap LowBattery
{
  attr bitmapfile FileName = .\resources\low-battery.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <5,46>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <-300,280,-100,320>
$output false
class ChangeBattery : Core::Group
{
  $rect <160,0,360,40>
  inherited property Bounds = <0,0,130,65>;

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,130,65>;
    preset Radius = 3;
    preset Color = #476984FF;
  }

  $rect <190,90,390,130>
  property int32 NewBatteryLvl;

  $rect <190,140,390,180>
  onget NewBatteryLvl
  {
    // Per default return the value stored already in the property.
    return pure NewBatteryLvl;

    /*

      TO DO:

      If the property should return the value stored in the underlying device
      or in the middleware, remove the above 'return' statement and instead do
      following:

      Declare a local variable to receive the value from the underlying device.
      The type of the variable has to correspond to the data type of the property.
      For example in case of an 'int32' property:
      
        var int32 result;

      Implement a native statement to access the value and to store it in the
      variable 'result'. Then return the value. For example:

        $if !$prototyper
          native ( result )
          {
            result = YourDevice_GetSomeValue();
          }
        $endif

        return result;

    */
  }

  $rect <-10,140,190,180>
  onset NewBatteryLvl
  {
    // The property doesn't change -> nothing to do.
    if ( pure NewBatteryLvl == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure NewBatteryLvl = value;

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^NewBatteryLvl;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <-10,90,190,130>
  $output true
  method void UpdateProperty( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure NewBatteryLvl )
    {
      // Remember the new value in the internal memory of the property.
      pure NewBatteryLvl = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^NewBatteryLvl;
    }
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalSlider HorizontalSlider
  {
    preset Bounds = <6,29,126,64>;
    preset OnChange = onChangeSlider;
    preset OnEnd = onEndSlider;
    preset Outlet = ^NewBatteryLvl;
    preset MinValue = 20;
    preset Appearance = HorizontalSliderConfig;
  }

  $rect <440,30,680,70>
  object WidgetSet::HorizontalSliderConfig HorizontalSliderConfig
  {
    preset ThumbFrameActive = 0;
    preset ThumbFrameFocused = 0;
    preset ThumbFrameDisabled = 0;
    preset ThumbFrameDefault = 1;
    preset ThumbBitmapActive = Application::EnergySymbol;
    preset ThumbBitmapFocused = Application::EnergySymbol;
    preset ThumbBitmapDisabled = Application::EnergySymbol;
    preset ThumbBitmapDefault = Application::EnergySymbol;
    preset TrackRightBitmapActive = Application::SliderBack;
    preset TrackRightBitmapFocused = Application::SliderBack;
    preset TrackRightBitmapDefault = Application::SliderBack;
    preset TrackLeftBitmapActive = Application::SliderFront;
    preset TrackLeftBitmapFocused = Application::SliderFront;
    preset TrackLeftBitmapDefault = Application::SliderFront;
  }

  $rect <460,130,660,170>
  slot onEndSlider
  {
    this.Enabled = false;
    this.Bounds.x = -270;
    this.Visible = true;

  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <10,2,120,32>;
    preset String = "add new battery..";
    preset Font = Application::ChangeFont;
  }

  $rect <460,80,660,120>
  slot onChangeSlider
  {
    this.Text.String = NewBatteryLvl;
  }

  // Slider Config
  note group Note
  {
    attr Bounds = <430,-10,690,190>;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Bounds = <0,0,130,65>;
    preset Radius = 3;
    preset Width = 2;
    preset Color = #050B25FF;
  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Bounds
  $member Rectangle
  $member Border
  $member NewBatteryLvl
  $member OnGetNewBatteryLvl
  $member OnSetNewBatteryLvl
  $member UpdateProperty
  $member HorizontalSlider
  $member HorizontalSliderConfig
  $member onEndSlider
  $member Text
  $member onChangeSlider
  $member Note
}

$rect <460,420,660,460>
$output false
resource Resources::Font ChangeFont
{
  attr fontname FontName = Bahnschrift SemiCondensed;
  attr fontheight Height = 16;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <190,540,390,580>
$output false
resource Resources::Bitmap EnergySymbol
{
  attr bitmapfile FileName = .\resources\battery-symbol.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <30,30>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <190,590,390,630>
$output false
resource Resources::Bitmap SliderFront
{
  attr bitmapfile FileName = .\resources\slider-front.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <120,20>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <190,640,390,680>
$output false
resource Resources::Bitmap SliderBack
{
  attr bitmapfile FileName = .\resources\slider-back.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize = <120,20>;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}
